[
{
    "code": "function [A, c, b, Eqin, MinMaxLP] = \n canonical2standard(A, c, b, Eqin, MinMaxLP) \n[m, n] = size(A); % size of matrix A \n for i = 1:m \n if Eqin(i) == -1 \n A = [A zeros(m, 1)]; \n A(i, n + 1) = 1; \n c = [c; 0]; \n Eqin(i) = 0; \n n = n + 1; \n end \n end \n end",
    "comment": "the function is an implementation of the transformation of an LP problem in its canonical form to its standard form"
 },
{
"code":"function g = conj(f)\n %CONJ  Complex conjugate of a BALLFUN.\n %   CONJ(F) is the complex conjugate of F.\n % Copyright 2019 by The University of Oxford and The Chebfun Developers.\n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @conj ); \n end",
"comment":"Complex conjugate of a BALLFUN."
},
{
"code":"function g = cos( f ) \n %COS   Cosine of a BALLFUN. \n %   COS(F) computes the cosine of F. \n % See also COSH, COS. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @cos ); \n end",
"comment":"Cosine of a BALLFUN."
},
{
"code":"function g = cosh(f) \n %COSH   Hyperbolic cosine of a BALLFUN. \n %   COSH(F) computes the hyperbolic cosine of F. \n % \n % See also SINH, COS, SIN \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @cosh );  \n end",
"comment":"Hyperbolic cosine of a BALLFUN"
},
{
"code":"function g = exp(f) \n %EXP   Exponential of a BALLFUN. \n %   EXP(F) computes the exponential of the BALLFUN F. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @exp ); \n end",
"comment":"Exponential of a BALLFUN."
},
{
"code":"function v = grad(f) \n %GRAD Gradient of a BALLFUN in cartesian coordinates. \n %   GRAD(F) is the gradient of the BALLFUN F expressed in \n %   cartesian coordinates. \n %   This is shorthand for the command GRADIENT. \n % See also DIV, CURL \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n v = gradient(f); \n end",
"comment":"Gradient of a BALLFUN in cartesian coordinates."
},
{
"code":"function g = imag(f) \n %IMAG   Complex imaginary part of a BALLFUN. \n %   IMAG(F) is the imaginary part of F. \n % See also REAL. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @imag );  \n end",
"comment":" Complex imaginary part of a BALLFUN."
},
{
"code":"function I = integral(f) \n %INTEGRAL   Triple integral of a BALLFUN over its domain. \n %   I = INTEGRAL(F) returns the double definite integral of a BALLFUN. \n % See also SUM3. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n I = sum3(f); \n end",
"comment":"Triple integral of a BALLFUN over its domain."
},
{
"code":"function out = isempty( f ) \n %ISEMPTY   True for empty BALLFUN. \n %   ISEMPTY(F) returns 1 if F is an empty BALLFUN and 0 otherwise. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers . \n % See http://www.chebfun.org/ for Chebfun information. \n out = isempty( f.coeffs ); \n end",
"comment":" True for empty BALLFUN."
},
{ 
"code":"function b = isequal(f, g) \n %ISEQUAL Equality test for BALLFUN. \n %   ISEQUAL(F, G) returns 1 if F =G, \n %   returns 0 otherwise \n %   See also ISZERO. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n % Test if f = g \n b = iszero( f - g ); \n end",
"comment":"Equality test for BALLFUN.  "
},
{
"code":"function varargout = lap(varargin) \n %LAP   Laplacian of a BALLFUN. \n %   L = LAP(F) returns a BALLFUN representing the Laplacian of F. \n %   This is shorthand for LAPLACIAN(F). \n % See also BALLFUN/LAPLACIAN. \n % Copyright 2017 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n [varargout{1:nargout}] = laplacian(varargin{:}); \n end",
"comment":"returns a BALLFUN representing the Laplacian of F."
},
{
"code":"function g = log(f) \n %LOG   Natural logarithm of a BALLFUN. \n %   LOG(F) returns the natural logarithm of F. If F has any roots over the \n %   unit ball, then the representation is likely to be inaccurate. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n % Return the logarithm of the ballfun function f \n g = compose( f, @log ); \n end",
"comment":" Natural logarithm of a BALLFUN"
},
{
"code":"function s = mean(f, dim) \n %MEAN   Average or mean value of a BALLFUN in a specific direction. \n %   MEAN(F, DIM) where DIM is 1, 2 or 3 is the mean of F over r (radial direction), \n %   lambda (azimuthal direction) or theta (polar direction) respectively and \n %   and returns as its output a spherefun if DIM is 1 or a diskfun otherwise. \n % See also BALLFUN/MEAN2, BALLFUN/MEAN3. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n if ( nargin == 1) \n % Default to the r-direction: \n dim = 1; \n end \n % Compute the definite integral of f \n s = sum(f, dim); \n if dim == 1 \n % Mean in the r direction \n s = s*3; \n elseif dim == 2\n % Mean in the lambda direction \n s = s/(2*pi); \n elseif dim == 3 \n % Mean in the theta direction \n s = s/2; \n else \n error('CHEBFUN:BALLFUN:mean:dim', ... \n Unrecognized input.') \n end \n end",
"comment":"Average or mean value of a BALLFUN in a specific direction. "
},
{
"code":"function h = minus(f, g) \n %BALLFUN minus. \n %   F - G subtracts BALLFUNs F and G, or a scalar from a BALLFUN if either F or \n %   G is a scalar. \n %   H = MINUS(F, G) is called for the syntax 'F - G'. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n h = f + (-g); \n end",
"comment":" subtracts BALLFUNs F and G,"
},
{
"code":"function g = mrdivide(f,c) \n %/   Right scalar divide for BALLFUN objects. \n %   X = B/A or X = mrdivide(B, A) is equivalent to X = B./A. \n % See also MTIMES. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = f*(1/c); \n end",
"comment":"Right scalar divide for BALLFUN objects."
},
{
"code":"function g = power(f,n) \n %.^   BALLFUN power. \n %   F.^G returns a BALLFUN F to the scalar power G. \n %   H = POWER(F, G) is called for the syntax 'F .^ G'. \n % See also SQRT. \n % Copyright 2018 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n n = ballfun( n ); \n g = compose(f, @power, n); \n end",
"comment":" F.^G returns a BALLFUN F to the scalar power G."
},
{
"code":"function g = real(f) \n %REAL Real part of a BALLFUN. \n %   REAL(F) is the real part of the BALLFUN F. \n % See also IMAG. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @real ); \n end",
"comment":"REAL(F) is the real part of the BALLFUN F."
},

{
"code":"function g = sin(f) \n %SIN  Sine of a BALLFUN. \n %   SIN(F) computes the sine of the BALLFUN F. \n % See also SINH, COS. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @sin ); \n end",
"comment":"computes the sine of the BALLFUN F."
},
{
"code":"function g = sinh(f) \n %SINH   Hyperbolic sine of a BALLFUN. \n %   SINH(F) computes the hyperbolic sine of the BALLFUN F. \n % See also SIN, COS. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @sinh ); \n end",
"comment":"  Hyperbolic sine of a BALLFUN."
},
{
"code":"function g = sqrt(f) \n %SQRT   Square root of a BALLFUN. \n %   SQRT(F) is the square root of a BALLFUN F. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @sqrt ); \n end",
"comment":"Square root of a BALLFUN."
},
{
"code":"function g = tan(f) \n %TAN   Tangent of a BALLFUN. \n %   TAN(F) computes the tangent of the BALLFUN F. \n % See also TANH, SIN, COS. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @tan ); \n end",
"comment":"Tangent of a BALLFUN."
},
{
"code":"function g = tanh(f) \n %TANH   Hyperbolic tangent of a BALLFUN. \n %   TANH(F) computes the hyperbolic tangent of the BALLFUN F. \n % See also TAN, SINH, COSH. \n % Copyright 2019 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n g = compose( f, @tanh ); \n end",
"comment":"Hyperbolic tangent of a BALLFUN."
},
{
"code":"function f = uminus(f) \n %-   BALLFUN unary minus. \n %   -F negates the BALLFUN F. \n %   G = UMINUS(F) is called for the syntax '-F'. \n % Copyright 2018 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n f.coeffs = -f.coeffs; \n end",
"comment":"BALLFUN unary minus."
},
{
"code":"function f = uplus(f) \n %+   BALLFUN unary plus. \n %   +F of a BALLFUN is F. \n %   G = UPLUS(F) is called for the syntax '+F'. \n % Copyright 2018 by The University of Oxford and The Chebfun Developers. \n % See http://www.chebfun.org/ for Chebfun information. \n end",
"comment":"BALLFUN unary plus."
},
{
"code":"function d = detperm(p) \n n = length(p); \n if isoctave(), P =   eye(n);  % Octave uses special representation \n else,          P = speye(n); \n end \n d = det(P(:,p)); \n end",
"comment":"computes the determinant (i.e., sign) D of the permutation"
},
{
"code":"function symm = chksymm(symm) \n symm = lower(symm); \n assert(strcmp(symm,'n') || strcmp(symm,'s') || strcmp(symm,'h') || ... \n strcmp(symm,'p'),'FLAM:chksymm:invalidSymm', ... \n 'Symmetry parameter must be one of ''N'', ''S'', ''H'', or ''P''.') \n end",
"comment":"Check symmetry parameter."
},
{
"code":"function trans = chktrans(trans) \n trans = lower(trans); \n assert(strcmp(trans,'n') || strcmp(trans,'t') || strcmp(trans,'c'), ... \n FLAM:chktrans:invalidTrans', ... \n 'Transpose parameter must be one of ''N'', ''T'', or ''C''.') \n end",
"comment":" Check transpose parameter."
},
{
"code":"function ld = logdet_ldl(D) \n idx = full(sum(D ~= 0)) == 1;  % find 1x1 blocks ... \n d = diag(D);                   % ... and compute determinant ... \n ld = sum(log(d(idx)));         % ... from corresponding diagonal \n idx = find(~idx);  % accumulate determinant for each 2x2 block \n for i = 1:2:length(idx), ld = ld + log(det(D(idx(i:i+1),idx(i:i+1)))); end \n end",
"comment":" Compute log-determinant of D factor from block LDL factorization"
},
{
"code":"function A = spaddv(A,I,J,V) \n n = numel(J); \n for j = 1:n, A{J(j)}(I) = A{J(j)}(I) + V(:,j); end \n end",
"comment":" Sparse matrix addition for sparse column cell array."
},
{
"code":"function S = spget(A,I,J) \n S = A(:,J); \n S = full(S(I,:)); \n end",
"comment":"Sparse matrix access."
},
{
"code":"function [I,J,nz] = sppush2(I,J,nz,i,j) \n N = length(I); \n n = numel(i); \n assert(length(J) == N && numel(j) == n,'FLAM:sppush2:sizeMismatch', ... \n Arrays I and J must have the same size.') \n nznew = nz + n; \n if N < nznew \n while N < nznew, N = 2*N; end  % exponentially increase capacity as needed \n e = zeros(N-length(I),1); \n I = [I; e]; \n J = [J; e]; \n end \n I(nz+(1:n)) = i; \n J(nz+(1:n)) = j; \n nz = nznew; \n end",
"comment":"Append to 2-array sparse matrix representation."
},
{
"code":"function [C,N,A] = tri3geom(V,F) \n % set default parameters \n if nargin < 2 || isempty(F), F = [1; 2; 3]; end \n % compute triangle information \n C = (V(:,F(1,:)) + V(:,F(2,:)) + V(:,F(3,:)))/3; \n V21 = V(:,F(2,:)) - V(:,F(1,:)); \n V32 = V(:,F(3,:)) - V(:,F(2,:)); \n N = cross(V21,V32); \n A = sqrt(sum(N.^2)); \n N = N./A; \n A = 0.5*A; \n end",
"comment":"Centroid, unit normal, and area of a triangle in 3D."
},
{
    "code": "function x=BackSub(U,b) \n % This function computes the vector $x$ by backward substitution. \n % We solve $Ux=b$, where $U$ is an $n \times n$ nonsingular upper triangular matrix \n % and $b$ is a known vector of the length $n$, finding the vector $x$. \n %% Compute x by backward substitution. \n s=size(U); \n n=s(1); \n x=zeros(n,1); \n %  $U(i,i)*x(i) = b(i) - \\sum_{j=i+1}^{n}$ \n x(n)=b(n)/U(n,n); \n for i=n-1:-1:1 \n x(i)=(b(i)-U(i,(i+1):n)*x((i+1):n))/U(i,i); \n end \n end",
    "comment": "This function computes the vector $x$ by backward substitution."
},
{
"code":"% ---------------------------------------- \n % Find all eigenvalues of the matrix A ion the input interval [a,b) \n % ---------------------------------------- \n % define size n of the  n-by-n matrix A \n n=5; \n % Generate the symmetric tridiagonal  matrix A \n A=randomTridiag(n); \n % Set bounds for the interval [a,b) in the algorithm and the tolerance \n a=-100;b=100; \n tol=0.000001; \n %Define functions for the worklist \n DeleteRowInWorklist=@(Worklist,linenr) ChangeRowInWorklist(Worklist,linenr,'delete'); \n InsertRowInWorklist=@(Worklist,LineToAdd)... \n ChangeRowInWorklist(Worklist,LineToAdd,'add'); \n % Set the info for the first worklist \n na=Negcount(A,a); \n nb=Negcount(A,b); \n Worklist=[]; \n %If no eigenvalues are found on the interval [a,b) then save an empty worklist \n if na ~= nb \n Worklist=InsertRowInWorklist(Worklist,[a,na,b,nb]); \n end \n while numel(Worklist) ~= 0 \n [Worklist, LineToWorkWith ]= DeleteRowInWorklist(Worklist,1); \n low=LineToWorkWith(1); \n n_low=LineToWorkWith(2); \n up=LineToWorkWith(3); \n n_up=LineToWorkWith(4); \n % if the upper and lower bounds are close enough we  print out this interval  \n if (up-low)< tol \n NrOfEigVal = n_up-n_low; \n fprintf('We have computed %3.0f eigenvalues in the interval [%4.4f,%4.4f) \n', ... \n NrOfEigVal,low,up); \n else \n % Perform the bisection step \n mid= (low+up)/2; \n n_mid= Negcount(A,mid); \n if n_mid > n_low \n Worklist = InsertRowInWorklist(Worklist,[low,n_low,mid,n_mid]); \n end \n if n_up>n_mid \n Worklist = InsertRowInWorklist(Worklist,[mid,n_mid,up,n_up]); \n end \n end \n end", 
"comment":"Find all eigenvalues of the matrix A ion the input interval [a,b)"
},
 {
    "code": "% ---------------------------------------- \n % Computes algorithm of Divide-and-Conquer: \n % eigenvalues will be roots of the secular equation and will lie \n % on the diagonal of the output matrix L. \n % In the output matrix Q will be corresponding eigenvectors. \n % ---------------------------------------- \n function [Q,L] = DivideandConq(T) \n % Compute size of input matrix T: \n [m,n] = size(T); \n % here we will divide the matrix \n m2 = floor(m/2); \n %if m=0 we shall return \n if m2 == 0 %1 by 1 \n Q = 1; L = T; \n return; \n %else we perform recursive computations \n else \n [T,T1,T2,bm,v] = formT(T,m2); \n %recursive computations \n [Q1,L1] = DivideandConq(T1); \n [Q2,L2] = DivideandConq(T2); \n %pick out the last and first columns of the transposes: \n Q1T = Q1'; \n Q2T = Q2'; \n u = [Q1T(:,end); Q2T(:,1)]; \n %Creating the D-matrix: \n D = zeros(n); \n D(1:m2,1:m2 ) = L1; \n D((m2+1):end,(m2+1):end) = L2; \n % The Q matrix (with Q1 and Q2 on the \"diagonals\") \n Q = zeros(n); \n Q(1:m2,1:m2) = Q1; \n Q((m2+1):end,(m2+1):end) = Q2; \n %Creating the matrix B, which determinant is the secular equation: \n % det B = f(\\lambda)=0 \n B = D+bm*u*u'; \n  % Compute eigenvalues as roots of the secular equation \n %  f(\\lambda)=0  using Newton's method \n eigs = NewtonMethod(D,bm,u); \n Q3 = zeros(m,n); \n % compute eigenvectors for corresponding eigenvalues \n for i = 1:length(eigs) \n Q3(:,i) = (D-eigs(i)*eye(m))\\u; \n Q3(:,i) = Q3(:,i)/norm(Q3(:,i)); \n end \n %Compute  eigenvectors of the original input matrix T \n Q = Q*Q3; \n % Present eigenvalues  of the original matrix input T \n %(they will be on diagonal) \n L = zeros(m,n); \n L(1:(m+1):end) = eigs; \n return; \n end \n end \n Compute T1, T2  constant bm  and the vector v \n %from the input matrix A. \n function [T,T1,T2,bm,v] = formT(A,m) \n T1 = A(1:m,1:m); \n T2 = A((m+1):end,(m+1):end); \n bm = A(m,m+1); \n T1(end) = T1(end)-bm; \n T2(1) = T2(1)-bm; \n v = zeros(size(A,1),1); \n v(m:m+1) = 1; \n T = zeros(size(A)); \n T(1:m,1:m) = T1; \n T((m+1):end,(m+1):end) = T2; \n end \n % compute eigenvalues in the secular equation \n % using the Newton's method \n function eigs = NewtonMethod(D,p,u) \n [m,n] = size(D); \n %The initial guess in  the Newton's method \n % will be the numbers d_i \n startingPoints = sort(diag(D)); \n %if p > 0 we have an eigenvalue on the right, else on the left \n if p >= 0 \n startingPoints = [startingPoints; startingPoints(end)+10000]; \n elseif p < 0 \n startingPoints = [startingPoints(1)-10000; startingPoints]; \n end \n eigs = zeros(m,1); \n % tolerance in Newton's method \n convCriteria = 1e-05; \n % step in the approximation of the derrivative \n % in Newton's method \n dx = 0.00001; \n %plot the secular equation \n X = linspace(-3,3,1000); \n for t = 1:1000 \n y(t) =SecularEqEval(D,p,u,X(t),m,n); \n end \n plot(X,y, 'LineWidth',2) \n axis([-3 3 -5 5]) \n legend('graph of the secular equation $f(\\lambda)=0$') \n %Start  Newton's method \n for i = 1:m \n %the starting value of lambda \n currentVal = (startingPoints(i)+startingPoints(i+1) )/ 2; \n % this value is used inthe stoppimg criterion below \n currentVal2 = inf; \n %  computed secular equation for \\lambda=currentVal \n fCurr = SecularEqEval(D,p,u,currentVal,m,n); \n rands = 0; \n k =0; \n j = 0; \n if  ~((startingPoints(i+1)-startingPoints(i)) < 0.0001) \n while ~(abs(fCurr) < convCriteria) \n %compute value of the function  dfApprox with small step dx to \n %approximate derivative \n fval2 = SecularEqEval(D,p,u,currentVal+dx,m,n); \n fval1 = SecularEqEval(D,p,u,currentVal,m,n); \n dfApprox = (fval2-fval1)/dx; \n % compute new value of  currentVal in Newton's method, \n % or perform one iteration in Newton's method \n currentVal = currentVal - fCurr/dfApprox; \n % check: if we are  outside of the current range, reinput inside: \n if currentVal <= startingPoints(i) \n currentVal= startingPoints(i)+0.0001; \n k=k+1; \n elseif currentVal >= startingPoints(i+1); \n currentVal= startingPoints(i+1)-0.0001; \n k=k+1; \n elseif dfApprox == Inf || dfApprox == -Inf \n currentVal= startingPoints(i) + ... \n rand*(startingPoints(i+1)-startingPoints(i)); \n rands = rands+1; \n end \n j=j+1; \n fCurr = SecularEqEval(D,p,u,currentVal,m,n); \n if k > 10 || j > 50; \n tempVec = [startingPoints(i),startingPoints(i+1)]; \n [val,ind] = min(abs([startingPoints(i),startingPoints(i+1)]-currentVal)); \n if ind == 1 \n currentVal = tempVec(ind)+0.00001; \n else \n currentVal = tempVec(ind)-0.00001; \n end \n break; \n elseif currentVal2 == currentVal || rands > 5 || isnan(currentVal) || isnan(fCurr) \n currentVal = currentVal2; \n break; \n end \n %save last value: \n currentVal2 = currentVal; \n end \n end \n %assigning eigenvalue in the right order \n eigs(i) = currentVal; \n end \n end \n % evaluate the  secular equation in Newton's method for the computed \n % eigenvalue x \n function fVal = SecularEqEval(D,p,u,x,m,n) \n fVal = 1+p*u'*inv((D-x*eye(m,n)))*u; \n end \n ",
    "comment": "Computes algorithm of Divide-and-Conquer:"
  },
{
"code":"function A=DiscretePoisson2D(n) \n % The function for 2D discretization  of the Laplace operator with sign minus: - laplace \n % Input parameters: \n % n -  number of inner nodes, which is assumed to be the same in both \n % the x_1- and x_2 directions. \n A = zeros(n*n,n*n); \n % Main diagonal \n for i=1:n*n \n A(i,i)=4; \n end \n % 1st and 2nd off-diagonals \n for k=1:n % go through block 1 to n \n for i=1:(n-1) \n A(n*(k-1)+i,n*(k-1)+i+1)=-1; % \n A(n*(k-1)+i+1,n*(k-1)+i)=-1; \n end \n end \n % 3rd and 4th off-diagonals \n for i=1:n*(n-1) \n A(i,i+n)=-1; \n A(i+n,i)=-1; \n end \n end",
"comment":"The function for 2D discretization  of the Laplace operator with sign minus: - laplace"
},
{
    "code": "function x=ForwSub(L,b) \n % This function computes the vector $x$, of length $n$, \n % given $Lx=b$ where $L$ is an $n \\times n$ nonsingular lower triangular matrix \n % and $b$ is a known vector of length $n$, by using forward substitution. \n %% Compute $x$ by forward substitution. \n s=size(L); \n n=s(1); \n x=zeros(n,1); \n % $L(i,i)*x(i)=b(i) - \\sum_{j=1}^{i-1}$ \n % First, set $x(i)=b(i)$, then subtract the known values. \n % Lastly, divide by diagonal entry $L(i,i)$ \n x(1)=b(1)/L(1,1); \n for i=2:n \n x(i)=(b(i)-L(i,1:(i-1))*x(1:(i-1)))/L(i,i); \n end \n end",
    "comment": "This function computes the vector $x$, of length $n$"
  },
{
"code":" \n % ---------------------------------------- \n % Run Hager's algorithm. \n % ---------------------------------------- \n function [LowerBound] = HagersAlg(B) \n x=(1/length(B))*ones(length(B),1); \n iter=1; \n while iter < 1000 \n w=B*x; xi=sign(w); z = B'*xi; \n if max(abs(z)) <= z'*x \n break \n else \n x= (max(abs(z))== abs(z)); \n end \n iter = iter + 1; \n end \n LowerBound = norm(w,1); \n end",
"comment":"Run Hager's algorithm."
},
{
"code":"function [bc] = mbinocof(n,k) \n if n<k \n   error('error - n<k!') \n elseif mod(n,1)~=0 || mod(k,1)~=0 \n error('error - input values are not integers') \n end \n %% the works \n if ~isa(n,'double'),n=double(n);end \n if ~isa(k,'double'),k=double(k);end \n bc = factorial(n) / (factorial(k)*factorial(n-k));",
"comment":"computes the binomial coefficient for values of n up to 170"
},
{
"code":"function AD = adjoint(A) \n %<<1/17/96   last updated>> \n %ADJOINT  Compute the classical adjoint of a square matrix A. \n % If A is not square an empty matrix is returned. \n % *** This routine should only be used by students to \n check adjoint computations and should not be used as \n % part of a routine to compute inverses. See invert or inv. \n % Use in the form   ==>  adjoint(A)  <== \n %     By: David R. Hill, MATH DEPT, Temple University, \n % Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n [m,n]=size(A); \n AD=[]; \n if m ~= n, return, end \n for ki=1:n \n for kj = 1:n \n AD(ki,kj) = (-1)^(ki+kj)*det(A([1:ki-1 ki+1:n],[1:kj-1 kj+1:n])); \n end \n end \n AD=AD'; \n end \n end \n AD=AD'; \n ",
"comment":"Compute the classical adjoint of a square matrix A."
},
{
"code":"function v=blkmat(m,n) \n %last updated 1/17/96 \n %BLKMAT  Generate a matrix of blanks of size m by n. \n %        Use in the form   ==>  blkmat(m,n)   <== \n %     By: David R. Hill, MATH DEPT, Temple University, \n %         Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n v=[]; \n for i=1:m \n v=[v;blanks(n)]; \n end",
"comment":"Generate a matrix of blanks of size m by n."
},
{
"code":"function val = cofactor(i,j,A)            %<<1/17/96   last updated>> \n %COFACTOR Computes the (i,j)-cofactor of matrix A. \n %If A is not sqaure an error message is displayed. \n % *** This routine should only be used by students to \n % check cofactor computations. \n % Use in the form  ==>  cofactor(i,j,A)  <== \n %% By: David R. Hill, MATH DEPT, Temple University, \n % Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n blk=setstr(219); \n [m,n]=size(A); \n if m ~= n, \n disp([[blk blk blk] ['Error: matrix is not square.']]) \n return \n end \n %range check on i and j \n if i==abs(i) & j==abs(j) & i==fix(i) & j==fix(j) \n disp(' '); \n else \n disp([[blk blk blk] ['Error: indices not positive or not integer.']]) \n return \n end \n if i>n | j>n | i==0 | j==0 \n disp([[blk blk blk] ['Error: indices out of range.']]) \n return \n end \n val = (-1)^(i+j)*det(A([1:i-1 i+1:n],[1:j-1 j+1:n])); \n ",
"comment":"Computes the (i,j)-cofactor of matrix A."
},
{
"code":"function v=crossprd(x,y)                       %last updated 1/26/96 \n %CROSSPRD  Compute the cross product of vectors x and y in 3-space. \n % The output is a vector orthogonal to both of the original \n %  vectors x and y. The output is returned as a row matrix \n %       with 3 components [v1 v2 v3] which is interpreted as \n % v1*i + v2*j + v3*k \n % where i, j, and k are the unit vectors in the x, y, and z \n %       directions respectively. \n % Use in the form   ==>   v = crossprd(x,y)   <== \n % By: David R. Hill, MATH DEPT, Temple University, \n % Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n [mx nx]=size(x);[my ny]=size(y); \n blk=setstr(219); \n er='Error in Cross: size of input vector is not appropriate.'; \n if mx*nx~=3 | my*ny~=3 \n disp([blk blk blk er]) \n return \n end \n v=[x(2)*y(3)-x(3)*y(2) x(3)*y(1)-x(1)*y(3) x(1)*y(2)-x(2)*y(1)];",
"comment":"Compute the cross product of vectors x and y in 3-space."
},
{
"code":"function v=dot(x,y)                         %last updated 5/27/92 \n %DOT   The dot product of two n-vectors x and y is computed. \n %      The vectors can be either rows, columns, or matrices \n %      of the same size. \n %      Use in the form \n %  --->  dot(x,y)  <--- \n %By: David R. Hill, Math. Dept., Temple University \n %    Philadelphia, Pa. 19122 \n blk=setstr(219); \n er='Error in dot: arguments not of same size.'; \n [mx nx]=size(x);[my ny]=size(y); \n if (mx*nx ~= max([mx nx])) | (my*ny ~= max([my ny])) \n %check if one is a row and one a column \n % if not check for same size \n if (mx == my) & (nx == ny) \n %things are same size but not rows or columns \n else \n disp([blk blk blk er]) \n return \n end \n end \n x=x(:);y=y(:); \n v=x'*y; \n  ",
"comment":"the dot product of two n-vectors x and y is computed."
},
{
"code":"function v=dotprod(x,y)                         %last updated 1/17/96 \n %DOTPROD   The dot product of two n-vectors x and y is computed. \n %          The vectors can be either rows, columns, or matrices \n %          of the same size. For complex vectors the dot product \n %          of x and y is compted as the conjugate transpose of  \n %          the first times the second. \n %      Use in the form  ==>  dotprod(x,y)  <== \n %  By: David R. Hill, Math Dept, Temple University, \n %Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n %Note: this routine varies from MATLAB's dot command in \n %      how complex vectors are handled and how rectangular \n %      matrices are handled. \n blk=setstr(219); \n er='Error in dotprod: arguments not of same size.'; \n [mx nx]=size(x);[my ny]=size(y); \n if (mx*nx ~= max([mx nx])) | (my*ny ~= max([my ny])) \n %check if one is a row and one a column \n % if not check for same size \n if (mx == my) & (nx == ny) \n %things are same size but not rows or columns \n else \n disp([blk blk blk er]) \n return \n end \n end \n x=x(:);y=y(:); \n v=x'*y; \n ",
"comment":" The dot product of two n-vectors x and y is computed."
},
{
"code":"function AD = adjoint(A)       %<<1/17/96   last updated>> \n %ADJOINT  Compute the classical adjoint of a square matrix A. \n %         If A is not square an empty matrix is returned. \n *** This routine should only be used by students to \n %check adjoint computations and should not be used as \n %         part of a routine to compute inverses. See invert or inv. \n %         Use in the form   ==>  adjoint(A)  <== \n %     By: David R. Hill, MATH DEPT, Temple University, \n %         Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n [m,n]=size(A); \n AD=[]; \n if m ~= n, return, end \n for ki=1:n \n for kj = 1:n \n AD(ki,kj) = (-1)^(ki+kj)*det(A([1:ki-1 ki+1:n],[1:kj-1 kj+1:n])); \n end \n end \n AD=AD'; \n end \n end \n AD=AD'; \n ",
"comment":" Compute the classical adjoint of a square matrix A."
},

{
"code":"function y = bksub(A,b)                     %last updated 1/17/96 \n %BKSUB   Perform back substitution on upper triangular \n %system Ax = b.  If A is not square, upper \n %triangular and nonsingular an error message is \n % displayed. In case of an error the solution returned is \n % all zeros. \n %   Use in the form ==> bksub(A,b)  <== \n %     By: David R. Hill, MATH DEPT, Temple University, \n %Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n if (size(A)==size(A') & all(all(A==triu(A))) & abs(prod(diag(A))) > eps) \n n=length(b); \n x=zeros(n,1); \n for j=n:-1:1 \n x(j)=(b(j)-A(j,:)*x)/A(j,j); \n end \n y=x; \n else \n disp('Error in function backsub.') \n disp('Coefficient matrix not square,') \n disp('not upper triangular, or is singular.') \n return \n end",
"comment":"Perform back substitution on upper triangular"
},
{
"code":"function v=blkmat(m,n)                    %last updated 1/17/96 \n %BLKMAT  Generate a matrix of blanks of size m by n. \n % Use in the form   ==>  blkmat(m,n)   <== \n % By: David R. Hill, MATH DEPT, Temple University, \n % Philadelphia, Pa. 19122   Email: hill@math.temple.edu \n v=[]; \n for i=1:m \n v=[v;blanks(n)]; \n end",
"comment":"Generate a matrix of blanks of size m by n."
},
{
"code":"function v=crossprd(x,y) \n [mx nx]=size(x);[my ny]=size(y); \n blk=setstr(219); \n er='Error in Cross: size of input vector is not appropriate.'; \n if mx*nx~=3 | my*ny~=3 \n disp([blk blk blk er]) \n return \n end \n v=[x(2)*y(3)-x(3)*y(2) x(3)*y(1)-x(1)*y(3) x(1)*y(2)-x(2)*y(1)];",
"comment":"Compute the cross product of vectors x and y in 3-space."
},
{
"code":"function B = cmult(A,i,r) \n B=A; \n B(:,i)=r*B(:,i);",
"comment":"Multiplies i-th column of A by r."
},
{
"code":"function B=colop(A,i,j,r) \n B=A; \n B(:,i)=B(:,i)+r*B(:,j);",
"comment":"Adds r times j-th column of A to i-th column."
},
{
"code":"function B = cperm(A,i,j) \n B=A; \n c=B(:,i);B(:,i)= B(:,j);B(:,j)=c; ",
"comment":"Interchanges i-th and j-th columns of matrix."
},
{
"code":"function B = mult(A,i,r) \n B=A;B(i,:)=r*B(i,:); ",
"comment":"Multiplies the i-th row by r."
},
{
"code":"function v = nullt(A) \n [m,n]=size(A); \n b=zeros(m,1); \n [v0,v1]=lsolve(A,b); \n v=v1; \n ",
"comment":"Finds null space of matrix using lsolve."
},
{
"code":"function addvec(v,w) \n v=v(:);     w=w(:); \n if (length(v)~=2) | (length(w)~=2) \n   error('Both v and w must be vectors of length two') \n end \n x = v + w; \n hold off \n clg \n plot([0 v(1)],[0, v(2)],'-',... \n [0 w(1)],[0, w(2)],'-',... \n [0 x(1)],[0, x(2)],'-') \n hold on \n text(v(1),v(2),'v') \n text(w(1),w(2),'w') \n text(x(1),x(2),'v+w') \n plot([w(1) x(1)],[w(2) x(2)],':') \n plot([v(1) x(1)],[v(2) x(2)],':') \n hold off ",
"comment":" Illustrate the sum v + w of 2-dimensional vectors."
},
{
"code":"function C = cofactor(A,i,j) \n if nargin == 3 \n M = A; \n M(i,:) = []; \n M(:,j) = []; \n C = (-1)^(i+j)*det(M); \n else \n [n,n] = size(A); \n for i = 1:n \n for j = 1:n \n C(i,j) = cofactor(A,i,j); \n end \n end \n end ",
"comment":"Cofactors and the cofactor matrix."
},
{
"code":"function cosine \n clc \n disp('This code illustrates the cosine formula and dot products') \n disp('found on p. 16 of G. Strang, 'Introduction to Linear Algebra.') \n clg \n axis([-10 10 -10 10]);axis('square') \n plot(0,0); hold on \n  axis([-10 10 -10 10]);axis('square') \n button = 1; \n fprintf('\n\n') \n disp('OPEN A FIGURE WINDOW') \n disp('Click at two points on the plot with the left button.') \n disp(' ') \n disp('Press any other key or button twice to exit.') \n [x,y,button]=ginput(2); \n clc \n while button==1 \n u=[x(1);y(1)]; \n  v=[x(2);y(2)]; \n plot([0 u(1)],[0 u(2)],'-',[0 v(1)],[0 v(2)],'-') \n text(u(1),u(2),'u') \n text(v(1),v(2),'v') \n axis([-10 10 -10 10]);axis('square') \n fprintf('\n\nThe cosine of the angle between the two vectors is\n') \n cosine = u'*v/(norm(u)*norm(v)); \n fprintf('cosine = u''*v/(norm(u)*norm(v)) = %g\n\n',cosine) \n disp('The angle between the two vectors in radians is') \n fprintf('acos(cosine) = %g\n\n',acos(cosine)) \n disp('The angle between the two vectors in degrees is') \n fprintf('180*acos(cosine)/pi = %g\n\n',180*acos(cosine)/pi) \n pause(3) \n disp('Click twice on the plot with the left button.') \n disp('Press any other key or button twice to exit.') \n [x,y,button]=ginput(2); \n clc \n clg \n axis([-10 10 -10 10]);axis('square') \n plot(0,0); hold on \n axis([-10 10 -10 10]);axis('square') ",
"comment":"Illustrates cosine formula and dot products."
},
{
"code":"function x = cramer(A,b) \n if det(A) == 0 \n error('Matrix is singular') \n end \n [n,n] = size(A); \n for j = 1:n \n B = A; \n B(:,j) = b; \n x(j) = det(B)/det(A); \n end \n x = x'; ",
"comment":"Solve linear system by Cramer's Rule."
},
{
"code":"function det = determ(A) \n [P,L,U,sign] = splu(A); \n det = sign*prod(diag(U));",
"comment":"computes the determinant of the square matrix A"
},
{
"code":"function eigen(A) \n disp(' ') \n disp('The trace and determinant are:') \n t = trace(A) \n d = det(A) \n disp(' ') \n disp('det(e*I-A) is :') \n disp(poly2str(poly(A),'e')) \n [S,LAMBDA] = eig(A); \n disp(' ') \n disp('The matrix of eigenvalues is: ') \n LAMBDA \n disp(' ') \n disp('The matrix of unit eigenvectors is: ') \n S \n ",
"comment":"Describe eigenvalues and eigenvectors."
},
{
"code":"function eigen2(a) \n d = a(1,1)*a(2,2) - a(1,2)*a(2,1); \n t = a(1,1) + a(2,2); \n e1 = (t + sqrt(t^2 - 4*d))/2; \n e2 = (t - sqrt(t^2 - 4*d))/2; \n if a(1,2) ~= 0 \n x1 = [a(1,2); e1-a(1,1)]; \n x2 = [a(1,2); e2-a(1,1)]; \n elseif a(2,1) ~= 0 \n x1 = [e1-a(2,2); a(2,1)]; \n x2 = [e2-a(2,2); a(2,1)]; \n else \n x1 = [1; 0]; \n x2 = [0; 1]; \n end \n disp(' ') \n disp('For this matrix, the polynomial whose roots are the eigenvalues is:') \n disp(['   e^2 - ' num2str(t) '*e + ' num2str(d) ' = 0']) \n disp(' ') \n disp('The first eigenvalue and eigenvector are:') \n e1 \n x1 \n disp(' ') \n disp('The second eigenvalue and eigenvector are:') \n e2 \n x2",
"comment":"Two by two eigenvalues and eigenvectors."
},

{
"code":"pause % Strike any key to continue \n clc \n A = [ 1      0    0.005    3 ]; \n v = [1      0 ]; \n pause(3) \n power(A,v,10); \n % Actual eigenvalues of A \n eig(A) \n % The method converged \n pause % Strike any key to continue \n clc \n A = [ 1       0    0.005  -1.05 ]; \n v = [1  0 ]; \n pause(3) \n power(A,v,10); \n [V,D] = eig(A) \n pause % Strike any key to continue \n clc \n A = [ 1   0 \n       0  -1 ];\n v = [1 \n      1 ]; \n pause(3) \n power(A,v,10); \n eig(A) \n pause % Strike any key to continue \n clc \n c = cos(.2); \n s = sin(.2); \n A = [ c  s  -s  c ]; \n v = [1  0 ]; \n pause(3) \n power(A,v,30); \n eig(A) \n echo off \n ",
"comment":"demonstrates the power method of finding the dominant eigenvalue"
},
{
"code":"function y = fastfour(x) \n n = length(x); \n i = sqrt(-1); \n omega = exp(-2*pi*i/n); \n if rem(n,2) == 0 \n k = (0:n/2-1)'; \n w = omega .^ k; \n u = fastfour(x(1:2:n-1)); \n v = w.*fastfour(x(2:2:n)); \n y = [u+v; u-v]; \n else \n j = 0:n-1; \n k = j'; \n F = omega .^ (k*j); \n y = F*x; \n end ",
"comment":"omputes the same finite Fourier transform as FFT(x)"
},
{
"code":"function [k,p] = findpiv(A,k,p,tol) \n [m,n] = size(A); \n r = find(abs(A(:))>tol); \n if isempty(r), return, end \n r = r(1); \n j = fix((r-1)/m)+1; \n p = p+j-1; \n k = k+r-(j-1)*m-1;",
"comment":"find a pivot for Gaussian elimination."
},
{
"code":"function X = inverse(A) \n [n,n] = size(A); \n I = eye(n,n); \n R = ref([A I]); \n X = R(:,n+1:n+n); ",
"comment":"Matrix inverse by Gauss Jordan elimination"
},
{
"code":"function s = permdet(p) \n n = length(p); \n I = eye(n); \n s = determ(I(p,:));",
"comment":"Determinant of a permutation."
},
{
"code":"function plot2d(X) \n x = X(1,:)'; \n y = X(2,:)'; \n plot(x,y,'c5o',x,y,'c6-'); \n axis([-10 10 -10 10]) \n axis('square') ",
"comment":"Two dimensional plot."
},
{
"code":"function p = randperm(n) \n [ignore,p] = sort(rand(1,n)); ",
"comment":"Random permutation."
},
{
"code":"function rats(A) \n tol = 1.e-6; \n A = A .* (abs(A)>tol); \n disp(' '); \n v = version; \n if v(1) == '4' \n f = get(0,'format'); \n format rat \n disp(A) \n format(f); \n else \n disp(rat(A,'s')) \n end \n disp(' ');",
"comment":"Print in rational form."
},
{
"code":"function s = signperm(p) \n n = length(p); \n s = 1; \n for j = 1:n \n k = find(p == j); \n if k ~= j \n p([k,j]) = p([j,k]); \n s = -s; \n end \n end ",
"comment":"Sign of a permutation."
},
{
"code":"function I = MutualInformation(X,Y); \n if (size(X,2) > 1)  \n I = JointEntropy(X) + Entropy(Y) - JointEntropy([X Y]); \n else \n I = Entropy(X) + Entropy(Y) - JointEntropy([X Y]); \n end",
"comment":"returns mutual information (in bits) of the 'X' and 'Y'"
},
{
"code":"function alpha = circ_ang2rad(alpha) \n alpha = alpha * pi /180;",
"comment":"converts values in degree to radians"
},
{
"code":"function alpha = circ_axial(alpha, p) \n if nargin < 2 \n p = 1; \n end \n alpha = mod(alpha*p,2*pi); ",
"comment":" Transforms p-axial data to a common scale."
},
{
"code":"function [r mu] = circ_axialmean(alphas, m, dim) \n if nargin < 3 \n dim = 1; \n end \n if nargin < 2 || isempty(m) \n m = 1; \n end \n zbarm = mean(exp(1i*alphas*m),dim); \n r = abs(zbarm); \n mu = angle(zbarm)/m;",
"comment":"Computes the mean direction for circular data with axial "
},
{
"code":"function [cid, alpha, mu] = circ_clust(alpha, numclust, disp) \n if nargin < 2, numclust = 5; end; \n if nargin < 3, disp = 0; end \n if nargin < 1 \n n = 20; \n alpha = 2*pi*rand(n,1)-pi; \n numclust = 4; \n disp = 1; \n end; \n n = length(alpha); \n if n < numclust, error('Not enough data for clusters.'), end \n cid = (1:n)'; \n num_unique = length(unique(cid)); \n num_clusters_wanted = numclust; \n while(num_unique > num_clusters_wanted) \n mu = NaN(n,1); \n for j=1:n \n if sum(cid==j)>0 \n mu(j) = circ_mean(alpha(cid==j)'); \n end \n end \n mudist = abs(circ_dist2(mu)); \n mindist = min(mudist(tril(ones(size(mudist)),-1)==1)); \n [row, col] = find(mudist==mindist); \n cid(cid==max(row)) = min(col); \n num_unique = length(unique(cid)); \n end \n cid2 = cid; \n uniquecids = unique(cid); \n for j=1:length(uniquecids) \n cid(cid2==uniquecids(j)) = j; \n end \n mu = NaN(num_unique,1); \n r = NaN(num_unique,1); \n for j=1:num_unique \n if sum(cid==j)>0 \n mu(j) = circ_mean(alpha(cid==j)'); \n r(j) = circ_r(alpha(cid==j)'); \n end \n end \n if disp \n z2 = exp(1i*alpha); \n plotColor(real(z2), imag(z2), cid, 2) \n zmu = r.*exp(1i*mu); \n plotColor(real(zmu), imag(zmu), 1:num_unique, 2, '*', 10, 1) \n     axis square \n set(gca, 'XLim', [-1, 1]); \n set(gca, 'YLim', [-1, 1]); \n end \n function plotColor(x, y, c, varargin) \n if nargin < 4 \n figurenum = 1; \n else \n figurenum = varargin{1}; \n end \n if nargin < 5 \n pstring = '.'; \n else \n pstring = varargin{2}; \n end \n if nargin < 6 \n ms = 10; \n else \n ms = varargin{3}; \n end \n if nargin < 7 \n overlay = 0; \n else \n overlay = varargin{4};  \n end \n csmall = unique(c); \n figure(figurenum); \n if ~overlay, close(figurenum); end \n  figure(figurenum); \n colors={'y', 'b', 'r', 'g', 'c', 'k', 'm'}; \n hold on; \n for j=1:length(csmall); \n ci = (c == csmall(j)); \n plot(x(ci), y(ci), strcat(pstring, colors{mod(j, length(colors))+1}), 'MarkerSize', ms); \n end \n if ~overlay, hold off; end \n figure(figurenum)",
"comment":" Performs a simple agglomerative clustering of angular data."
},
{
"code":"function [rho pval] = circ_corrcl(alpha, x) \n if size(alpha,2) > size(alpha,1) \n alpha = alpha'; \n end \n if size(x,2) > size(x,1) \n x = x'; \n end \n if length(alpha)~=length(x) \n error('Input dimensions do not match.') \n end \n n = length(alpha); \n rxs = corr(x,sin(alpha)); \n rxc = corr(x,cos(alpha)); \n rcs = corr(sin(alpha),cos(alpha)); \n rho = sqrt((rxc^2 + rxs^2 - 2*rxc*rxs*rcs)/(1-rcs^2)); \n pval = 1 - chi2cdf(n*rho^2,2); ",
"comment":"Correlation coefficient between one circular and one linear random"
},

{
"code":"function r =  circ_dist(x,y) \n if size(x,1)~=size(y,1) && size(x,2)~=size(y,2) && length(y)~=1 \n error('Input dimensions do not match.') \n end \n r = angle(exp(1i*x)./exp(1i*y));",
"comment":" Pairwise difference x_i-y_i around the circle computed efficiently."
},
{
  "code": "function [mu, ul, ll] = circ_mean(alpha, w, dim)\nif nargin < 3\n    dim = 1;\nend\nif nargin < 2 || isempty(w)\n    w = ones(size(alpha));\nelse\n    if size(w, 2) ~= size(alpha, 2) || size(w, 1) ~= size(alpha, 1)\n        error('Input dimensions do not match');\n    end\nend\nr = sum(w .* exp(1i * alpha), dim);\nmu = angle(r);\nif nargout > 1\n    t = circ_confmean(alpha, 0.05, w, [], dim);\n    ul = mu + t;\n    ll = mu - t;\nend",
  "comment": "Computes the mean direction for circular data."
},
{
"code":"function med = circ_median(alpha,dim) \n if nargin < 2 \n dim = 1; \n end \n M = size(alpha); \n med = NaN(M(3-dim),1); \n for i=1:M(3-dim) \n if dim == 2 \n beta = alpha(i,:)'; \n elseif dim ==1 \n beta = alpha(:,i); \n else \n error('circ_median only works along first two dimensions') \n end \n beta = mod(beta,2*pi); \n n = size(beta,1); \n dd = circ_dist2(beta,beta); \n m1 = sum(dd>=0,1); \n m2 = sum(dd<=0,1); \n dm = abs(m1-m2); \n if mod(n,2)==1 \n [m idx] = min(dm); \n else \n m = min(dm); \n idx = find(dm==m,2); \n end \n if m > 1 \n warning('Ties detected.') %#ok<WNTAG> \n end \n md = circ_mean(beta(idx)); \n if abs(circ_dist(circ_mean(beta),md)) > abs(circ_dist(circ_mean(beta),md+pi)) \n md = mod(md+pi,2*pi); \n end \n med(i) = md; \n end \n if dim == 2 \n med = med'; \n end",
"comment":" Computes the median direction for circular data."
},
{
"code":"function alpha = circ_rad2ang(alpha) \n alpha = alpha / pi *180;",
"comment":"  converts values in radians to values in degree"
},
{
"code":"function [b b0] = circ_skewness(alpha, w, dim) \n if nargin < 3 \n  dim = 1; \n end \n if nargin < 2 || isempty(w) \n w = ones(size(alpha)); \n else \n if size(w,2) ~= size(alpha,2) || size(w,1) ~= size(alpha,1)  \n error('Input dimensions do not match'); \n   end  \n end \n R = circ_r(alpha,w,[],dim); \n theta = circ_mean(alpha,w,dim); \n [~, rho2 mu2] = circ_moment(alpha,w,2,true,dim); \n theta2 = repmat(theta, size(alpha)./size(theta)); \n b = sum(w.*(sin(2*(circ_dist(alpha,theta2)))),dim)./sum(w,dim); \n b0 = rho2.*sin(circ_dist(mu2,2*theta))./(1-R).^(3/2);    % (formula 2.29) ",
"comment":"Calculates a measure of angular skewness"
},
{
"code":"function out = compq(X) \n if string(class(X)) == 'cell' \n c = 1; \n for i = 1:length(size(X)) \n c = c*size(X,i); \n end \n mat = cell(size(X)); \n for i = 1:c \n mat{i} = compq(X{i}); \n end \n elseif string(class(X)) ~= 'cell \n c = 1; \n for i = 1:length(size(X)) \n c = c*size(X,i); \n end \n mat = zeros(size(X)); \n for i = 1:c \n if imag(X(i)) ~= 0 & real(X(i)) ~= 0 & string(class(X)) ~= 'sym' \n mat(i) = true; \n elseif imag(X(i)) == 0 | real(X(i)) == 0 | string(class(X)) == 'sym' \n mat(i) = false; \n end \n end \n end \n out = mat; \n end",
"comment":"checks to see if the given number is a complex number."
},
{
"code":"function out = evenq(X) \n if string(class(X)) == 'cell' \n c = 1; \n for i = 1:length(size(X)) \n c = c*size(X,i); \n end \n mat = cell(size(X)); \n for i = 1:c \n mat{i} = evenq(X{i}); \n end \n elseif string(class(X)) ~= 'cell' \n c = 1; \n for i = 1:length(size(X)) \n c = c*size(X,i); \n end \n mat = zeros(size(X)); \n for i = 1:c \n if imag(X(i)) == 0 \n if mod(X(i),2) == 0 \n mat(i) = true; \n elseif mod(X(i),2) ~= 0 \n mat(i) = false; \n end \n elseif imag(X(i)) ~= 0 \n mat(i) = false; \n end \n end \n end \n out = mat; \n end",
"comment":"checks to see if the given number is even."
},
{
"code":"function out = imagq(X)\n if string(class(X)) == 'cell' \n c = 1; \n for i = 1:length(size(X)) \n c = c*size(X,i);\n     end \n mat = cell(size(X)); \n     for i = 1:c \n         mat{i} = imagq(X{i}); \n     end \n elseif string(class(X)) ~= 'cell' \n     im = sqrt(-1); \n    c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = zeros(size(X)); \n     for i = 1:c \n         if imag(X(i))*im == X(i) \n             mat(i) = true; \n         elseif imag(X(i))*im ~= X(i) \n             mat(i) = false; \n         end \n     end \n out = mat; \n end",
"comment":"checks to see if the given number is an imaginary number."
},
{ 
"code":"function out = intq(X) \n if string(class(X)) == 'cell' \n c = 1; \n for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = cell(size(X)); \n     for i = 1:c \n         mat{i} = intq(X{i}); \n     end \n elseif string(class(X)) ~= 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = zeros(size(X)); \n     for i = 1:c \n         if imag(X(i)) == 0 \n             if mod(X(i),2) == 1 | mod(X(i), 2) == 0  \n                 mat(i) = true; \n             elseif mod(X(i),2) ~= 1 & mod(X(1),2) ~= 0 \n                 mat(i) = false;  \n             end \n         elseif imag(X(i)) ~= 0 \n             mat(i) = false; \n         end \n     end \n end \n out = mat; \n end",
"comment":"checks to see if the given number is an integer."
},
{
"code":"function out = oddq(X) \n if string(class(X)) == 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = cell(size(X)); \n     for i = 1:c \n         mat{i} = oddq(X{i}); \n     end \n elseif string(class(X)) ~= 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = zeros(size(X)); \n     for i = 1:c \n         if imag(X(i)) == 0 \n             if mod(X(i),2) == 1 \n                 mat(i) = true; \n             elseif mod(X(i),2) ~= 1 \n                 mat(i) = false; \n             end \n         elseif imag(X(i)) ~= 0 \n             mat(i) = false; \n         end \n     end \n end \n out = mat; \n end",
"comment":"checks to see if the given number is odd."
},
{
"code":"function out = realq(X) \n if string(class(X)) == 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = cell(size(X)); \n     for i = 1:c \n         mat{i} = realq(X{i}); \n     end \n elseif string(class(X)) ~= 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = zeros(size(X));  \n     for i = 1:c \n         if real(X(i)) == X(i) \n             mat(i) = true; \n         elseif real(X(i)) ~= X(i) \n             mat(i) = false; \n         end \n     end \n end \n out = mat; \n end",
"comment":"checks to see if the given number is a real number."
},
{
"code":"function out = symq(X) \n if string(class(X)) == 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n     mat = cell(size(X)); \n     for i = 1:c \n         mat{i} = symq(X{i}); \n     end \n elseif string(class(X)) ~= 'cell' \n     c = 1; \n     for i = 1:length(size(X)) \n         c = c*size(X,i); \n     end \n    mat = zeros(size(X)); \n     for i = 1:c \n         if string(class(X(i))) == 'sym' \n             mat(i) = true; \n         elseif string(class(X(i))) ~= 'sym' \n             mat(i) = false; \n         end \n     end \n end \n out = mat; \n end",
"comment":"checks to see if the given input is a symbol."
},
{
"code":"function [X,Y]=ellipse(T, ax, ay, t0); \n X=ax*cos(T);   \n Y=ay*cos(T-t0);",
"comment":"Function Defining an Ellipse"
},
{
"code":"format long \n x=0.4,  s=sin(x)  \n a1=asin(s),  a2=pi-a1,  a3=a1-2*pi,  a4=a1+2*pi \n s1=sin(a1),  s2=sin(a2),  s3=sin(a3),  s4=sin(a4)",
"comment":"Test of angles corresponding to sin(x)"
},
{
  "code": "format long \n disp('The two sides and the angle:') \n a=4.1,  b=9.1,  A=20/180*pi   \n disp('Use the sine theorem to obtain sin(B), then B and C')  \n sB=b*sin(A)/a,  B=asin(sB),  C=pi-A-B \n disp('Calculate the side c by the sine theorem') \n c=a*sin(C)/sin(A) \n disp('Convert the angles to degrees') \n Adg=A/pi*180,  Bdg=B/pi*180,  Cdg=C/pi*180 \n disp('Repeat to find the second solution') \n a=4.1,  b=9.1,  A=20/180*pi \n sB=b*sin(A)/a,  B=pi-asin(sB),  C=pi-A-B \n disp('Convert the angles to degrees') \n Adg=A/pi*180,  Bdg=B/pi*180,  Cdg=C/pi*180",
  "comment": "Triangle with Two Sides and One Angle Known"
},
{
"code":"x0=5;  X=-x0:0.01:x0; \n Y1=sin(X);  Y2=cos(X);  Y3=tan(X);  Y4=cot(X);  \n figure(1),  plot(X,Y1,  X,Y2,  X,Y3,  X,Y4),  grid on \n y0=3; \n axis([-x0 x0 -y0 y0]) \n title('Trigonometric Functions'),  xlabel('x'),  ylabel('sin(x), cos(x), etc.') \n legend('sin(x)', 'cos(x)', 'tan(x)', 'cot(x)') ",
"comment":"Plot Trigonometric Functions"
},
{
"code":"x0=1;  X=-x0:0.01:x0;  \n Y1=acos(X);  Y2=atan(X);   \n figure(1),  plot(X,Y1, X,Y2),  grid on \n y0=2*pi;  \n axis([-x0 x0 -y0 y0]) \n title('Inverse Functions'),  xlabel('x'),  ylabel('acos(x), atan(x)') \n legend('acos(x)', 'atan(x)') ",
"comment":" Inverse Trigonometric Functions"
},
{
"code":"x0=2*pi;  X=-x0: 0.01: x0;  \n Y1=cos(X);  Y2=tan(X);  \n figure(1),  plot(Y1,X, Y2,X),  grid on \n y0=2*pi;   \n axis([-x0 x0 -y0 y0]) \n title('Inverse Functions'),  xlabel('x'),  ylabel('acos(x), atan(x)') \n legend('acos(x)', 'atan(x)')  \n ",
"comment":"Inverse Trigonometric Functions by Swapping "
},
{
"code":"x0=10;  X=-x0:0.01:x0; \n Y1=exp(X);  Y2=1e3*exp(X);  Y3=1e6*exp(X);     \n figure(1),  plot(X,Y1, X,Y2, X,Y3),  grid on \n title('Exponential functions'),  xlabel('x'),  ylabel('exp(x), etc.') \n legend('exp(x)', '1e3*exp(x)', '1e6*exp(x)') \n axis([-x0 x0 0 2.5e4])",
"comment":"Plot Exponential Functions"
},
{ 
"code":"% x0=10;  X=0.01: 0.01: x0;   \n Y1=log(X);  Y2=log(1e3*X);  Y3=log(1e6*X);  \n figure(1),  plot(X,Y1, X,Y2, X,Y3),  grid on \n title('Logarithmic functions'),  xlabel('x'),  ylabel('log(x), etc.') \n legend('ln(x)', 'ln(1e3*x)', 'ln(1e6*x)')",
"comment":"Plot  Logarithmic Functions"
},
{
"code":"x0=100;  X=-x0: 0.1: x0; \n Y=exp(X);   \n figure(1),  semilogy(X,Y),  grid on \n title('Exponential function'),  xlabel('x'),  ylabel('exp(x)')",
"comment":" Plot Exponential Functions"
},
{ 
"code":"x0=5;  X=-x0: 0.01: x0; \n Y1=exp(-X.^2);  Y2=exp(-3*X.^2);     \n figure(1),  semilogy(X,Y1,  X,Y2),  grid on \n title('Gaussian functions'),  xlabel('x'),  ylabel('exp(-x^2), exp(-3x^2)')legend('exp(-x^2)',  'exp(-3x^2)')",
"comment":"Plot Gaussian Functions"
},
{
"code":"X=-3: 0.01: 3;  Y1=gaussian(X,1);  Y2=gaussian(X,0.2); \n figure(1),  plot(X,Y1,  X,Y2),  grid on,  title('Gaussians') \n legend('a=1.0', 'a=0.2')",
"comment":"Plot  two Gaussians "
},
{
"code":"theta=0: 1e-3: 2*pi; figure(1);  polar(theta, sin(theta));  \n figure(2);  polar(theta, cos(theta));   \n rho3=cos(4*theta); \n figure(3);  polar(theta, rho3);   \n rho4=1+0.3*cos(8*theta); \n figure(4);  polar(theta, rho4);  \n figure(5);  polar(theta, pi*theta,'r'); \n theta=0: 1e-3: 6*pi; \n figure(6);  polar(theta, pi*theta,'r'); \n figure(7);  polar(theta, exp(0.05*theta),'r'); ",
"comment":" Plots in Polar Coordinates"
},
{
"code":"T= 0:1e-3:2*pi; \n [X1,Y1]=ellipse(T, 2, 1, 0);  \n [X2,Y2]=ellipse(T, 2, 1, pi/3);  \n [X3,Y3]=ellipse(T, 2, 1, pi/2);   \n figure(1);  plot(X1,Y1,  X2,Y2,  X3,Y3);  grid on;  axis equal; \n title('Ellipses'); \n legend('t0=0', 't0=pi/3', 't0=pi/2'),  xlabel('x'),  ylabel('y')  ",
"comment":"Plot of Ellipses"
},
{
"code":"f=inline('x^3- 2*x^2- x+2'); \n figure(1),  fplot(f, [-2 3]),  grid on,  zoom on \n    title('x^3-2*x^2-x+2'),  xlabel('x')",
"comment":"Plot a Cubic Polynomial "
},
{
"code":" clear all \n X=0: 0.01: 10;  Y=xcos(X); \n h=1e-4; \n Der=(xcos(X+h)- xcos(X))/ h; \n figure(1),  plot(X,Y,  X,Der),  grid on, \n    legend('f=x*cos(x)', 'df/dx'),  xlabel('x') \n Dex=cos(X)-X.*sin(X); \n figure(2),  plot(X,Der,  X,Dex),  grid on,  legend('df/dx', 'exact') \n figure(3),  plot(X, Der- Dex),  grid on,  title('Error in df/dx')",
"comment":" Plot a Function and its Derivative   "
},
{
"code":"clear all \n X=0: 0.01: 10;  Y=xcos(X); \n h=1e-4; \n Der=(xcos(X+h)- xcos(X-h))/(2*h); \n figure(1),  plot(X,Y,  X,Der),  grid on,   \n    legend('f=x*cos(x)', 'df/dx'),  xlabel('x') \n Dex=cos(X)-X.*sin(X); \n figure(2),  plot(X,Der,  X,Dex),  grid on,  legend('df/dx', 'exact') \n figure(3),  plot(X, Der- Dex),  grid on,  title('Error in df/dx')",
"comment":"Plot a Function and its Symmetric Derivative  "
},
{
"code":"  clear all \n X=0:0.01:10;  Y=xcos(X); \n h=1e-4; \n Der=(xcos(X+h)- xcos(X-h))/(2*h); \n Der2=(xcos(X+h)-2*xcos(X)+xcos(X-h))/h^2; \n figure(1),  plot(X,Y,  X,Der,  X,Der2),  grid on,  xlabel('x')  \n    legend('f=x*cos(x)', 'df/dx', 'd2f/dx2') \n D2ex=-sin(X)- sin(X)- X.*cos(X); \n figure(2),  plot(X,Der2,  X,D2ex),  grid on \n legend('d2f/dx2', 'exact') \n figure(3),  plot(X,Der2-D2ex),  grid on,  title('Error in d2f/dx2')",
"comment":" Plot Second-Order Derivative"
},
{
"code":"clear all,  format long \n k=input('k= (e.g. 2) '); \n si=0; \n for i=1:20 \n    term=k^(i-1); \n    si=si+term; \n    si_ex=(1-k^i)/(1-k); \n    sums=[si  si_ex],  pause \n end",
"comment":"Sum of a Geometric Series"
},

{
"code":"clear all,  format long; \n x=input('x= (e.g. 1) '); \n term=x;  s=x;  i=0; \n while 1==1 \n    i=i+1; \n    term=term*(-x^2)/(2*i+1)/(2*i); \n    s=s+ term; \n    if abs(term)<1e-15;  break;  end; \n end \n last_index_in_sum=i \n sum=s,  sin_ex=sin(x) \n format short e,  error=s- sin(x)",
"comment":"Power Series for sin(x)"
},
{
"code":"clear all,  format long \n xn=input('xn= (e.g. 1) '); \n x1=0;  n=500; \n h=(xn-x1)/n; \n X=x1: h: xn-h; \n F=cos(X); \n integral=sum(F)* h; \n int_ex=sin(xn)-sin(x1); \n integrals=[integral  int_ex] \n format short e,  error=integral-int_ex",
"comment":"Integration by Direct Summing"
},
{
"code":"clear all \n rand('seed',sum(100*clock)) \n n=5000; \n X=2*(rand(1,n)-0.5);  \n figure(1),  hist(X,10);  grid on \n   title('Number of Random Values in Each Container') ",
"comment":" Histogram of symmetric random numbers   "
},
{
"code":"clear all \n rand('seed',sum(100*clock)) \n while 1==1 \n    head=ceil(rand-0.5) \n    pause \n end",
"comment":" Tossing Coins   "
},
{
"code":"clear all \n m0=100; \n sdev=sqrt(m0)/2; \n for j=1:m0+1 \n    m=j-1; \n    Xm(j)=m; \n    Ybd(j)=prod(1:m0)/prod(1:m)/prod(1:(m0-m))*0.5^m0; \n    Nd(j)=1/sdev/sqrt(2*pi)* exp(-(m- m0/2)^2/2/sdev^2); \n end \n figure(1),  plot(Xm,Ybd,'g',  Xm,Nd,'k:'),  grid on,  axis([0 100 0 0.09]) \n    title('Binomial and Normal Distributions') \n    xlabel('number of heads'),  ylabel('probability') \n figure(2),  plot(Xm,Ybd-Nd),  grid on,  axis([0 100 0 3e-4]);",
"comment":" Binomial and Normal Distributions  "
},
{
"code":"clear all \n P=1: 1e-3: 2;  np=length(P); \n for i=1:np \n    F(i)=sdev(P(i)); \n end \n figure(1),  plot(P,F),  grid on,  xlabel('p'),  ylabel('sdev')",
"comment":" Standard Deviation to Minimize"
},
{
"code":"clear all \n T=[200  250  300  350  400]; \n I=[0.1176    0.0926    0.0735    0.0711    0.0594]*1e-7; \n P=1.5e-6: 5e-9: 3.5e-6; % Values of p for plot \n n=length(P); \n for i=1:n \n    F(i)=ssq1( P(i), T, I); \n end \n figure(2),  plot(T,I,'o',  T,2.34e-6./T),  grid on,  xlabel('temperature')   \n ",
"comment":"Minimize Standard Deviation, Plot Result"
},
{
"code":"function F= fun_fourier(T); \n F=exp(T);",
"comment":"Function for Fourier Series Expansion"
},
{
    "code": "plt.plot([1, 2, 3, 4]) \n plt.ylabel('Numbers') \n plt.show()",
    "comment": "Generating visualization with Pyplot"
 },
 {
    "code": "fig.savefig('plot1.png')",
    "comment": "Saving the figure"
 },
 {
    "code": "fig = plt.figure() \n ax = plt.axes() \n # Declare a variable x5 \n x5 = np.linspace(0, 10, 1000) \n # Plot the sinusoid function \n ax.plot(x5, np.sin(x5), 'b-');",
    "comment": "commands to draw the simple sinusoid line plot"
 },
 {
    "code": "x7 = np.linspace(0, 10, 30) \n y7 = np.sin(x7) \n plt.plot(x7, y7, 'o', color = 'black');",
    "comment": "functions to produce the scatter plots"
 },
 {
    "code": "data1 = np.random.randn(1000) \n plt.hist(data1);",
    "comment": "function can be used to plot a simple histogram"
 },
 {
    "code": "data2 = [5. , 25. , 50. , 20.] \n plt.bar(range(len(data2)), data2) \n plt.show()",
    "comment": "plot a bar chart "
 },
 {
    "code": "data2 = [5. , 25. , 50. , 20.] \n plt.barh(range(len(data2)), data2) \n plt.show()",
    "comment": "produce Horizontal Bar Chart "
 },
 {
    "code": "plt.figure(figsize=(7,7)) \n x10 = [35, 25, 20, 20] \n labels = ['Computer', 'Electronics', 'Mechanical', 'Chemical'] \n plt.pie(x10, labels=labels); \n plt.show()",
    "comment": "function to plot pie charts from an array X"
 },
 {
    "code": "data3 = np.random.randn(100) \n plt.boxplot(data3) \n plt.show();",
    "comment": "plot a boxplot with the boxplot() function"
 },
 {
    "code": "x12 = range(1, 6) \n y12 = [1, 4, 6, 8, 4] \n plt.fill_between(x12, y12) \n plt.show()",
    "comment": "create an Area Chart "
 },
 {
    "code": "matrix1 = np.random.rand(10, 20) \n cp = plt.contour(matrix1) \n plt.show() \n ",
    "comment": "Contour plot can be created with the plt.contour() function"
 },
 {
    "code": "u = [5, 4, 9, 7, 8, 9, 6, 5, 7, 8] \n plt.plot(u) \n plt.xticks([2, 4, 6, 8, 10]) \n plt.yticks([2, 4, 6, 8, 10]) \n plt.show()",
    "comment": "usage of the ticks functions in the code snippet"
 },
 {
    "code": "plt.plot([1, 3, 2, 4]) \n plt.xlabel('This is the X axis') \n plt.ylabel('This is the Y axis') \n plt.show()",
    "comment": "piece of information to add to a plot is the axes labels"
 },
 {
    "code": "plt.plot([1, 3, 2, 4]) \n plt.title('First Plot') \n plt.show() \n ",
    "comment": "simple function title() to add a title to an image"
 },
 {
    "code": "x16 = np.arange(1, 5) \n plt.plot(x16, 'r') \n plt.plot(x16+1, 'g') \n plt.plot(x16+2, 'b') \n plt.show()",
    "comment": "draw different lines or curves in a plot with different colours"
 },
 {
    "code": "function max = mymax(n1, n2, n3, n4, n5) \n max =  n1; \n if(n2 > max) \n max = n2; \n end \n if(n3 > max) \n max = n3; \n end \n if(n4 > max) \n max = n4; \n end \n if(n5 > max) \n max = n5; \n end",
    "comment": "Function to calculate the maximum of five number given as input"
 },
 {
    "code": "function boolean = compareArray(array1,array2) \n boolean =0; \n if(abs((array1(:)-array2(:))) < 1e-5) \n boolean = 1; \n end \n end",
    "comment": "Compare two array "
 },
 {
    "code": "function X=deleteRowsAndCols(X0,index) \n if(any(size(X0)==1)) \n X0(index)=[]; \n else \n X0(index,:)=[]; \n X0(:,index)=[]; \n end \n X=X0; \n end",
    "comment": "delete Rows And Columns"
 },
 {
    "code": "clear; \n close all; \n clc; \n\n msg = 'Please enter a number: '; \n msg2 = 'Invalid input! Please enter a number: '; \n a = input(msg); \n b = input(msg); \n fprintf('Enter 1 for addition.'); \n fprintf('Enter 2 for subtraction.'); \n fprintf('Enter 3 for multiplication.'); \n fprintf('Enter 4 for division.'); \n option = input(msg); \n while (option < 1 || option > 4) \n option = input(msg2); \n end \n if option == 1 \n y = a + b; \n disp(y); \n elseif option == 2 \n y = a - b; \n disp(y); \n elseif option == 3 \n y = a * b; \n disp(y); \n else \n y = a / b; \n disp(y); \n end \n ",
    "comment": "a simple calculator"
 },
 {
    "code": "function lxl = SmoothAbs(x,alpha) \n lxl = x.*tanh(x/alpha); \n end \n ",
    "comment": "This function is a smooth version of absolute value"
 },
 {
    "code": "N = 3; \n X = 0 ; \n for i = 1:N \n c = rand ; \n if c > 0.5 \n         fprintf('Tails\n') \n else \n X = X+1 ; \n fprintf('Heads\n') \n end \n end \n fprintf('In %d tosses,number of Heads=%d n',N,X)",
    "comment": "Matlab code that simulates 3 coin tosses and computes the value of the  variable X. (number of heads)"
 },
 {
    "code": "function alpha = circ_axial(alpha, p) \n if nargin < 2 \n p = 1; \n end \n alpha = mod(alpha*p,2*pi);",
    "comment": "Transforms p-axial data to a common scale."
 },
 {
    "code": "function [r mu] = circ_axialmean(alphas, m, dim) \n if nargin < 3 \n dim = 1; \n end \n if nargin < 2 || isempty(m) \n m = 1; \n end \n zbarm = mean(exp(1i*alphas*m),dim); \n r = abs(zbarm); \n mu = angle(zbarm)/m;",
    "comment": "Computes the mean direction for circular data with axial"
 },
 {
    "code":"function dispersion = calculate_dispersion(data, k) \n stop_w = warning('off', 'stats:kmeans:EmptyCluster'); \n stop_w2 = warning('off', 'stats:kmeans:EmptyClusterRep'); \n opts = statset('MaxIter', 400); \n [idx, C, sumD] = kmeans(data, k, 'EmptyAction', 'singleton', 'options', opts, 'Replicates', 2); \n dispersion = sum(sumD); \n end",
    "comment": "Calculate Dispersion"
 },
 {
    "code": "function [B W]=scattermat(data,Y) \n [~, l]=size(data); \n clases=unique(Y); \n tot_clases=length(clases); \n B=zeros(l,l); \n W=zeros(l,l); \n overallmean=mean(data); \n for i=1:tot_clases \n clasei = find(Y==clases(i)); \n xi=data(clasei,:); \n mci=mean(xi); \n xi=xi-repmat(mci,length(clasei),1); \n W=W+xi'*xi; \n B=B+length(clasei)*(mci-overallmean)'*(mci-overallmean); \n end \n end",
    "comment": "FUNCTION THAT CALCULATES SCATTER MATRIX"
 },
 {
    "code": "function output=array_adder(array1,array2) \n a=array1; \n b=array2; \n if(length(a)>length(b)) \n for(i=1:length(a)-length(b)) \n b=[0 b]; \n end \n end \n if(length(b)>length(a)) \n for(i=1:length(b)-length(a)) \n a=[0 a]; \n end \n end \n c=a+b; \n c=fliplr(c); \n c=[c 0]; \n for(i=2:length(c)) \n c(i)=c(i)+floor(c(i-1)/10); \n end \n for(i=1:length(c)) \n if(c(i)>9) \n c(i)=c(i)-10; \n end \n end \n output=fliplr(c);",
    "comment": "adds 2 arrays, after making them of equal lengths"
 },
 {
    "code": "function output=bin2hex(input) \n mat_1=['0000'; \n '0001'; \n '0010'; \n     '0011'; \n     '0100'; \n     '0101'; \n     '0110'; \n     '0111'; \n     '1000'; \n     '1001'; \n     '1010'; \n     '1011'; \n     '1100'; \n     '1101'; \n     '1110'; \n     '1111';]; \n mat_2='0123456789ABCDEF'; \n for i=1:16 \n     if(input==mat_1(i,:)) \n         output=mat_2(i); \n     end \n end",
    "comment": "function to converts a single-digit binary number into corresponding hexagonal number."
 },
 {
    "code": "function output=bin2oct(input) \n mat_1=['000'; \n     '001'; \n     '010'; \n     '011'; \n     '100'; \n     '101'; \n     '110'; \n     '111']; \n mat_2='01234567'; \n for i=1:8 \n     if(input==mat_1(i,:)) \n         output=mat_2(i); \n     end \n end",
    "comment": "function to converts a single-digit binary number into corresponding octagonal number."
 },
 {
    "code": "function output=bin_2_dec(input) \n if ( sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-1)+(input-48-1))) ) %#ok<BDLOG> \n     output ='Invalid Number'; \n else \n     if length(input)==1 \n         output=input; \n     else \n         a=str2num(input); %#ok<ST2NM> \n         a=fliplr(a); \n         b(1)=a(1); \n         for i=2:length(a) \n             gopi=str2num(powr2(i-1))*a(i); %#ok<ST2NM> \n             gopi2=array_adder(b,gopi); \n             b=gopi2; \n         end \n         for i=1:length(gopi2) \n             if(gopi2(i)~=0) \n                 got=i; \n                 break; \n             end \n         end \n         for i=1:length(gopi2)-got+1 \n             gopi3(i)=gopi2(i+got-1); \n         end \n         for i=1:length(gopi3) \n             output(i)=int2str(gopi3(i)); %#ok<AGROW> \n         end \n     end \n end \n end",
    "comment": "function to converts a binary number into corresponding decimal number."
 },
 {
    "code": "function output=bin_2_hex(input) \n if ( sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-1)+(input-48-1))) ) \n     output ='Invalid Number'; \n else \n if(rem(length(input),4)~=0) \n     for i=1:4-rem(length(input),4) \n         input=['0' input]; \n     end \n end \n [m n]=size(input); \n b=reshape(input,4,m*n/4)'; \n output=[]; \n for i=1:m*n/4 \n     output=[output bin2hex(b(i,:))]; \n end \n output=output(find(output-48,1):length(output)); \n end",
    "comment": "function to converts a binary number into corresponding hexagonal number."
 },
 {
    "code": "function output=bin_2_oct(input) \n if ( sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-1)+(input-48-1))) ) \n     output ='Invalid Number'; \n else \n     if input=='0' \n         output='0'; \n     else \n         if(rem(length(input),3)~=0) \n             for i=1:3-rem(length(input),3) \n                 input=['0' input]; \n             end \n         end \n         [m n]=size(input); \n         b=reshape(input,3,m*n/3)'; \n         output=[]; \n         for i=1:m*n/3 \n             output=[output bin2oct(b(i,:))]; \n         end \n     end \n     output=output(find(output-48,1):length(output)); \n end",
    "comment": "function converts an binary number into corresponding octagonal number."
 },
 {
    "code": "function output=dec2bin2(input) \n empt=[]; \n for i=1:length(input) \n     empt=[empt 0]; \n end \n d=[]; \n j=1; \n while(j<=9) \n     [b c]=div2(input); \n     d=[d c]; \n     input=b; \n     if(b==empt) \n         break; \n     end \n end \n output=fliplr(d);",
    "comment": "function converts an array in binary format to an array in decimal format."
 },
 {
    "code": "function output=dec_2_bin(input) \n if ( sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-9)+(input-48-9))) ) \n     output ='Invalid Number'; \n else \n     if input=='0' \n         output='0'; \n     else \n         for i=1:length(input) \n             array(i)=(input(i))-48; \n         end \n         b=dec2bin2(array); \n         for i=1:length(b) \n             output(i)=int2str(b(i)); \n         end \n     end \n end",
    "comment": "function to converts a decimal number into corresponding binary number."
 },
 {
    "code": "function output=dec_2_hex(input) \n if ( sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-9)+(input-48-9))) ) \n     output ='Invalid Number'; \n else \n     output=bin_2_hex(dec_2_bin(input)); \n end",
    "comment": "function converts an decimal number into corresponding hexagonal number."
 },
 {
    "code": "function output=dec_2_oct(input) \n if ( sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-9)+(input-48-9))) ) \n output ='Invalid Number'; \n else \n     output=bin_2_oct(dec_2_bin(input)); \n end",
    "comment": "This function converts a decimal number into corresponding octagonal number."
 },
 {
    "code": "function [e,factor]=div2(a) \n for i=1:length(a) \n     if(rem(a(i),2)==0) \n         b(i)=a(i)/2; \n         c(i)=0; \n     else \n         b(i)=(a(i)-1)/2; \n         c(i)=5; \n     end \n end \n c=[0 c]; \n b=[b 0]; \n d=b+c; \n for i=1:length(d)-1 \n     e(i)=d(i); \n end \n factor=d(length(d))/5;",
    "comment": "this function divides an array by 2 and calculates the remainder too."
 },
 {
    "code": "function output=hex2bin(input) \n mat_1=['0000'; \n     '0001'; \n     '0010'; \n     '0011'; \n     '0100'; \n     '0101'; \n     '0110'; \n     '0111'; \n     '1000'; \n     '1001'; \n     '1010'; \n     '1011'; \n     '1100'; \n     '1101'; \n     '1110'; \n     '1111';]; \n mat_2='0123456789ABCDEF'; \n for(i=1:16) \n     if(input==mat_2(i)) \n         output=mat_1(i,:); \n     end \n end",
    "comment": "This function converts a single-digit hexagonal number into corresponding binary number."
 },
 {
    "code": "function output=hex_2_bin(input) \n input=char(input-32.*floor((sign(123-input)+sign(input-96))/2)); \n check1=sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-22)+(input-48-22))); \n check2=sign(sum(sign(abs(input-48-9)+(input-48-9))-sign(abs(input-48-16)+(input-48-16)))); \n if ( check1 || check2 ) \n     output ='Invalid Number'; \n else \n     if input=='0' \n         output='0'; \n     else \n         c=[]; \n         for i=1:length(input) \n             c=[c hex2bin(input(i))]; \n         end \n         output=c(find(c-48,1):length(c)); \n     end \n end",
    "comment": "This function converts an decimal number into corresponding octagonal number."
 },
 {
    "code": "function output=hex_2_dec(input) \n input=char(input-32.*floor((sign(123-input)+sign(input-96))/2)); \n check1=sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-22)+(input-48-22))); \n check2=sign(sum(sign(abs(input-48-9)+(input-48-9))-sign(abs(input-48-16)+(input-48-16)))); \n if ( check1 || check2 ) \n     output ='Invalid Number'; \n else \n     output=bin_2_dec(hex_2_bin(input)); \n end",
    "comment": "This function converts an hexagonal number into corresponding decimal number."
 },
 {
    "code": "function output=hex_2_oct(input) \n input=char(input-32.*floor((sign(123-input)+sign(input-96))/2)); \n check1=sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-22)+(input-48-22))); \n check2=sign(sum(sign(abs(input-48-9)+(input-48-9))-sign(abs(input-48-16)+(input-48-16)))); \n if ( check1 || check2 ) \n     output ='Invalid Number'; \n else \n     output=bin_2_oct(hex_2_bin(input)); \n end",
    "comment": "This function converts an hexadecimal number into corresponding octagonal number"
 },
 {
    "code": "function output=oct2bin(input) \n mat_1=['000'; \n     '001'; \n     '010'; \n     '011'; \n     '100'; \n     '101'; \n     '110'; \n     '111']; \n mat_2='01234567'; \n for i=1:8 \n     if(input==mat_2(i)) \n         output=mat_1(i,:); \n     end \n end",
    "comment": "This function converts a single-digit octagonal number into corresponding binary number."
 },
 {
    "code": "function output=oct_2_bin(input) \n if ( sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-7)+(input-48-7))) ) \n     output ='Invalid Number'; \n else \n     if input=='0' \n         output='0'; \n     else \n         c=[]; \n         for i=1:length(input) \n             c=[c oct2bin(input(i))]; \n         end \n         output=c(find(c-48,1):length(c)); \n     end \n end",
    "comment": "This function converts an octagonal number into corresponding binary number."
 },
 {
    "code": "function output=oct_2_dec(input) \n if ( sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-7)+(input-48-7))) ) \n     output ='Invalid Number'; \n else \n     output=bin_2_dec(oct_2_bin(input)); \n end",
    "comment": "This function converts an octagonal number into corresponding decimal number."
 },
 {
    "code": "function output=oct_2_hex(input) \n if ( sign(length(input-48)-sum(sign(abs(input-48+1)+(input-48+1))))+sign(sum(abs(input-48-7)+(input-48-7))) ) \n     output ='Invalid Number'; \n else \n     output=bin_2_hex(oct_2_bin(input)); \n end",
    "comment": "This function converts an octagonal number into corresponding hexadecimal number."
 },
 {
    "code": "function b=str2num(a) \n for i=1:length(a) \n     b(i)=a(i)-48; \n end",
    "comment": "This function converts a string into an array."
 },
 {
    "code": "function C = comm(n,m) \n if (n*m)*(n*m) > 100 \n     C = reshape(kron(vec(speye(n)), speye(m)), n*m, n*m); \n else \n     C = reshape(kron(vec(eye(n)), eye(m)), n*m, n*m); \n end \n end",
    "comment": "Returns the commutator matrix C_{n,m} that turns vec(A) into vec(A')"
 },
 {
    "code": "function D = dupl(n) \n A = tril(ones(n)); \n A(logical(A)) = 1:(n*(n+1)/2); \n A = A + tril(A,-1)'; \n D = sparse(1:(n*n), A(:), ones(n*n,1), n*n, n*(n+1)/2); \n end",
    "comment": "Returns the duplication matrix D_n such that vec(S) = D_n*vech(S)."
 },
 {
    "code": "function C = comm(n,m) \n if (n*m)*(n*m) > 100 \n     C = reshape(kron(vec(speye(n)), speye(m)), n*m, n*m); \n else \n     C = reshape(kron(vec(eye(n)), eye(m)), n*m, n*m); \n end \n end",
    "comment": "Returns the commutator matrix C_{n,m} that turns vec(A) into vec(A')"
 },
 {
    "code": "function D = dupl(n) \n A = tril(ones(n)); \n A(logical(A)) = 1:(n*(n+1)/2); \n A = A + tril(A,-1)'; \n D = sparse(1:(n*n), A(:), ones(n*n,1), n*n, n*(n+1)/2); \n end",
    "comment": "Returns the duplication matrix D_n such that vec(S) = D_n*vech(S)."
 },
 {
    "code": "function E = elim(n) \n E = sparse(1:(n*(n+1)/2), vech(reshape(1:(n*n),n,n)), ones(n*(n+1)/2,1), n*(n+1)/2, n*n); \n end",
    "comment": "Returns the elimination matrix E_n such that vech(S) = E_n*vec(S)."
 },
 {
    "code": "function v = vec(A) \n v = A(:); \n end",
    "comment": "returns a vector of the stacked columns from the matrix A"
 },
 {
    "code": "function [p_vec,fp_vec] = bisect(f,a,b,Nmax) \n for i=1:Nmax \n     p=(a+b)/2; \n     f(p); \n     if f(p)*f(a)>0 \n         a=p; \n     else \n         b=p; \n     end \n     p_vec(i,1)=p; \n     fp_vec(i,1)=f(p); \n end",
    "comment": "This function is designed to find the root of f in interval [a,b] by bisection method with the number of iteraction being Nmacx. "
 },
 {
    "code": "function [p_vec] = fpiter(g,p0,Nmax)\n for i=1:Nmax \n     p=g(p0); \n     p0=p;\n    p_vec(i,1)=p;\nend",
	"comment": "This function is designed to find the root of f by fixed- point iteration "
 },
 {
    "code": "function [p_vec] = newton(f,df,p0,Nmax,tol)\n for i=1:Nmax\n    p=p0-f(p0)/df(p0);\n    p_vec(i,1)=p;\n    if abs(p-p0)<tol\n        break;\n    else\n        p0=p;\n    end\nend",
    "comment": "This function is designed to find the root of f by Newton's method with df being f',"
 },
 {
    "code": "function x = backSub(A)\n n = size(A,1);\n for i = n:-1:1\n    \n    sum=0; % Initialise the summation of aij*xj\n        \n    % Obtain summation of aij*xj\n    for j = n:-1:i+1\n        sum = sum+x(j,1)*A(i,j);\n    end\n    \n    x(i,1) = (A(i,n+1)-sum)/A(i,i);\nend",
    "comment": "performs the backward substitution step of Gaussian elimination"
 },
 {
    "code": "function [dy,x] = derivative(x,y,x_star)\n N = length(x)-1;\n    dy = zeros(size(x));\n    dy(1) = (y(2)-y(1))/(x(2)-x(1));\n    dy(N+1) = (y(N+1)-y(N))/(x(N+1)-x(N));\n    for i = 2:N\n        dy(i) = (y(i+1)-y(i-1))/(x(i+1)-x(i-1));\n    end\n    if nargin == 3\n        dy = interp1(x,dy,x_star,'linear','extrap');\n    end\n        \nend",
    "comment": "Numerical differentiation or derivative of data"
 },
 {
    "code": "d_poly = @(x,n) n*x^(n-1);",
    "comment": "polynomial derivative"
 },
 {
    "code": "d_sqrt = @(x) 0.5*x^(-0.5);",
    "comment": "square root derivative"
 },
 {
    "code": "d_power = @(x,b) (b^x)*log(b);",
    "comment": "power derivative"
 },
 {
    "code": "d_exp = @(x) exp(x);",
    "comment": "exponential derivative"
 },
 {
    "code": "d_log = @(x) 1/x; \n d_log10 = @(x) 1/(x*log(10));",
    "comment": "logarithms derivative"
 },
 {
    "code": "function [ fxx ] = chain2(fv,fvv,vx,vxx) \n [n_f,n_v]=size(fv); \n n_x=size(vx,2); \n term1=innerkron(n_f,n_v,fvv,vx,vx); \n term2=fv*reshape(vxx,n_v,n_x^2); \n fxx=term1+term2; \n end",
    "comment": "calculates the second derivatives of the composite function f(v(x)) with respect to x"
 },
 {
    "code": "function y = adiff(a,varargin) \n if isa(a,'function_handle') \n   d = cell2mat(varargin); \n   [a1,a2,p] = prepfct(ainit([]),d); \n   eval(['y = @(' a1 ') aeval(adiff(a(' a2 '),d));']) \n   return \n end \n if numel(a)>1 \n   y = a; \n   for i = 1:numel(a) \n     y(i) = adiff(a(i),varargin{:}); \n   end \n   return \n end \n if nargin == 1 \n   d = zeros(1,aord(a)); \n else \n   d = cell2mat(varargin); \n end \n y = a; \n y.k = a.k - sum(d); \n y.c = a.c(:,1:nchoosek(y.n+y.k,y.n)); \n audi([],0,adim(a),aord(a)-sum(d)); \n for i = 1:size(y.c,2) \n   y.c(:,i) = a.c(:,idx(a,sub(y,i)+d)); \n end",
    "comment": "Partial derivative of audi array or function"
 },
 {
    "code": "function Y = fgl_deriv( a, y, h ) \n n  = numel(y); \n     J  = 0:(n-1); \n     G1 = gamma( J+1 ); \n     G2 = gamma( a+1-J ); \n     s  = (-1) .^ J; \n     M  = tril( ones(n) ); \n     R  = toeplitz( y(:)' ); \n     T  = meshgrid( (gamma(a+1)/(h^a)) * s ./ (G1.*G2) ); \n     Y  = reshape(sum( R .* M .* T, 2 ), size(y)); \n      \n end",
    "comment": "Computes the fractional derivative of order alpha (a) for the function y sampled on a regular grid with spacing h, using the Grunwald-Letnikov formulation."
 },
 {
    "code": "function [ first, second, third, ymat ] = derivative ( fn, x ) \n delta = 10e-5; % full delta missing centre if odd, half for even derivatives \n xmat = [ x x-delta*0.5 x+delta*0.5 x-delta x+delta x-delta*1.5 x+delta*1.5 ];  \n ymat = fn(xmat); \n first = (ymat(:,3)-ymat(:,2))./delta; \n second = (ymat(:,3)-2*ymat(:,1)+ymat(:,2))*4/delta^2; \n third = (ymat(:,7)-3*ymat(:,3)+3*ymat(:,2)-ymat(:,6))./delta^3; \n end",
    "comment": "estimate of first, second and third derivatives to estimate for input x."
 },
 {
    "code": "function [list_,deriv_] = func_list() \n expr_ = {'cos', '-sin(#)'; \n          'exp', 'exp(#)'; \n          'ln', '1/(#)'; \n 'log', '1/(#)'; \n 'log10', '1/((#)*log(10))'; \n 'normcdf', '1/(sqrt(2*pi))*exp(-((#)^2)/(2))'; ...mu=0,sigma=1 3.141592653589793 \n 'sin', 'cos(#)'; ... \n 'sqrt', '0.5*(#)^(-0.5)'}; \n list_  = expr_(:,1); \n deriv_ = expr_(:,2); \n end",
    "comment": "Calculate the derivate"
 },
 {
    "code": "tic \n clc \n clear all \n num=[ 10 50 100 300 500 1000];%number of grid points \n for i=1:6 \n x=linspace(0,2*pi,num(i)); \n df=derivative_2nd( x,num(i) );%taking the calculated value of the 2nd order derivative \n figure(i); \n plot(x,df,'k-*'); \n hold on \n grid on \n sum=0; \n %analytical solution \n syms x1 f1 z1 \n f1= sin(x1); \n z1=diff(f1,2); \n anaval=subs(z1,x); \n plot(x,anaval,'r--o'); \n xlabel('x'); \n ylabel('df/dx'); \n title('First derivative of function sin(x)'); \n legend('Numerical','Analytical'); \n %error calculation \n Err=(anaval'-df); \n Err1(i)=max(abs(Err)); \n deltax(i)=x(2); \n end \n figure(7) \n plot(log10(deltax),log10(Err1),'-s');shg \n xlabel('log(Deltax)'); \n ylabel('log(Error)'); \n title('LogLog plot of Error vs Deltax'); \n toc",
    "comment": "Solving 2nd order derivative numerically using for loop method"
 },
 {
    "code": "clc \n clear \n %% Taking inputs from user \n sc = inputdlg('Type an expression that is a function of x & y ' );    % Taking the equation as input from the user \n s = sc{:};                                                            % Function String \n f = str2func(['@(x,y) ' s]) \n x = input ('Enter the value of x: '); \n y = input ('Enter the value of y: '); \n z = feval (f,x,y); \n x1 = x + .000001 * x; \n y1 = y + .000001 * y; \n zx = feval (f,x1,y); \n zy = feval(f,x,y1); \n del_fx = (zx-z)/(.000001*x); \n del_fy = (zy-z)/(.000001*y); \n fprintf('The partial derivative at %f & %f with respect to x is %f & that with respect to y is %f \n',x,y,del_fx,del_fy );",
    "comment": "Partial Derivative of a quadratic function"
 },
 {
    "code": "clc \n clear \n %% Taking inputs from user \n sc = inputdlg('Type an expression that is a function of x ' );    % Taking the equation as input from the user \n s = sc{:};                                                            % Function String \n f = str2func(['@(x) ' s]) \n % Compute f'(x) \n x1 = x + .000001 * x; \n f_dash_x = (feval(f,(x+x1))-(feval(f,(x-x1))))/(2*x1); \n fprintf('The first order derivative at %f is %f \n',x,f_dash_x); \n % Compute f''(x) \n f_doubledash_x = (feval(f,(x+x1))-(2*feval(f,x))+(feval(f,(x-x1))))/(x1^2); \n fprintf('The second order derivative at %f is %f \n',x,f_doubledash_x);",
    "comment": "First order & second derivative at a point of an equation"
 },
 {
    "code": "a = input ( ' Enter the coefficints of the function ' ) ; \n poly2sym(a) \n n = input ( ' Now give n [ for calculating the n-th degree ] ' ); \n for i=1:n  \n     a = polyder(a) ;  \n end \n poly2sym(a) ",
    "comment": "This function calculates the n-th Derevetive of polynomial function "
 },
 {
    "code": "function coeff_derivative=derivate(coeff_function) \n der_order=size((coeff_function),2)-1; \n coeff_derivative=0; \n for index=1:size((coeff_function),2)-1 \n     coeff_derivative(index)=der_order*coeff_function(index); \n     der_order=der_order-1; \n end",
    "comment": "This calculates the derivative of the function,"
 },
 {
    "code": "function q = integral4(f,varargin) \n % integral4(f) = integral2(integral2(f)). \n narginchk(9,inf); \n zmin = varargin{5}; \n zmax = varargin{6}; \n wmin = varargin{7}; \n wmax = varargin{8}; \n anyisinf = false; \n if ~isa(zmin,'function_handle') \n     anyisinf = anyisinf || isinf(zmin(1)); \n     zmin = @(x,y)zmin(1)*ones(size(x)); \n end \n if ~isa(zmax,'function_handle') \n     anyisinf = anyisinf || isinf(zmax(1)); \n     zmax = @(x,y)zmax(1)*ones(size(x)); \n end \n if ~isa(wmin,'function_handle') \n     anyisinf = anyisinf || isinf(wmin(1)); \n     wmin = @(x,y,z)wmin(1)*ones(size(x)); \n end \n if ~isa(wmax,'function_handle') \n     anyisinf = anyisinf || isinf(wmax(1)); \n     wmax = @(x,y,z)wmax(1)*ones(size(x)); \n end \n if anyisinf \n     method_override = {'method','iterated'}; \n else \n     method_override = {}; \n end \n inner = @(x,y)integral2( ... \n     @(z,w)f(x*ones(size(z)),y*ones(size(z)),z,w), ... \n     zmin(x,y), ... \n     zmax(x,y), ... \n     @(z)wmin(x*ones(size(z)),y*ones(size(z)),z), ... \n     @(z)wmax(x*ones(size(z)),y*ones(size(z)),z), ... \n     varargin{9:end},method_override{:}); \n q = integral2( ... \n     @(xv,yv)arrayfun(inner,xv,yv), ... \n     varargin{1:4},varargin{9:end});",
    "comment": "fourth order integral"
 },
 {
    "code": "function dy = dervis (time,y) \n w0 = 2*pi*50; \n H = 4; \n Pm = 1; \n K = 1/0.4;   % K = (E1*E2)/(x'+x)*cos(delta) \n dy = zeros(2,1);   \n delta = 1; \n omega = 2; \n D = 2*omega/w0; \n dy(omega) = w0/2/H*(Pm-K*sin(y(delta))); \n dy(delta) = y(omega)-w0; \n end",
    "comment": "irst order integral"
 },
 {
    "code": "[T1,Y1] = rgsolverGeneralized([0.5;2*pi*50],0.01,3,@dervis); \n plot(T1,Y1(:,2)) \n ",
    "comment": "generalized numerical integration"
 },
 {
    "code": "function c = abs(a) \n c = int64abs(a); \n end",
    "comment": "function to calculate absolute value of a"
 },
 {
    "code": "function g = gcd(a,b) \n if isscalar(a) \n a = a*ones(size(b),'int64'); \n elseif isscalar(b) \n b = a*ones(size(b),'int64'); \n end \n if ~isequal(size(a),size(b)) \n error('Size mismatch'); \n end \n g = zeros(size(a),'int64'); \n for k = 1:length(a) \n g(k) = a(k); \n while b(k) ~= 0 \n t    = b(k); \n b(k) = mod(g(k),b(k)); \n g(k) = t; \n end \n end \n end",
    "comment": "the greatest common divisor of A and B"
 },
 {
    "code": "function c = minus(a,b) \n checkinputs(a,b); \n c = int64minus(int64(a),int64(b)); \n end", 
	"comment": "function to subtract b from a"
 },	
 {
    "code": "function c = mod(a,b) \n checkinputs(a,b); \n if numel(b)>1 \n ind = b~=0; \n c = int64mod(int64(a(ind)),int64(b(ind))); \n c(~ind) = a(~ind); \n else \n if b == 0 \n c = a; \n else \n c = int64mod(a,b); \n end \n end \n end",
    "comment": "function to calculate mod "
 },
 {
    "code": "function c = plus(a,b) \n checkinputs(a,b); \n c = int64plus(int64(a),int64(b)); \n end",
    "comment": "function to add / plus two variables/ numbers "
 },
 {
    "code": "function s = prod(A) \n %Get first non-singleton dimension \n sz = size(A); \n d = find(size(A)~=1); \n if isempty(d) \n s = A; \n return \n end \n d=d(1); \n idx = cell(1,ndims(A)); \n for k = 1:ndims(A) \n idx{k} = ':'; \n end \n ssz = sz; \n ssz(d) = 1; \n s = ones(ssz); \n for k = 1:size(A,d) \n idx{d} = k; \n s = s * A(idx{:}); \n end \n end",
    "comment": "Get first non-singleton dimension"
 },
 {
    "code": "function Angles = FindAngles(vertices) \n N = length(vertices) ; \n if N == 3 \n disp('vertices are of Triangle') \n order = [1 2 3; 2 1 3;3 1 2] ; \n elseif N == 4    \n disp('Vertices are of Quadrilateral') \n order = [ 1 2 4; 2 1 3; 3 4 2;4 3 1] ; \n else  \n error('Wrong input') \n end \n Angles = zeros(1,N) ; \n for i = 1:N \n % Form the vectors along the vertices \n vec1 = [vertices(i,:); vertices(order(i,2),:)]; \n vec2 = [vertices(i,:); vertices(order(i,3),:)]; \n % Use dor ptodict to find the angle between vector1 and vector2 \n Angles(i) = acos((diff(vec1)*diff(vec2)')/..... \n (sqrt(sum(diff(vec1,[],1).^2,2))*sqrt(sum(diff(vec2,[],1).^2,2)))) ;     \n end \n % Convert the angles in radians to degrees \n Angles = Angles*180./pi ;%",
    "comment": "find the angles of Triangle or Quadrilateral "
 },
 {
    "code": "function Angles = QUADangles(vertices) \n Angles = zeros(1,4) ; \n order = [ 1 2 4; 2 1 3; 3 4 2;4 3 1] ; \n for i = 1:4 \n % Form the vectors along the vertices \n data1 = [vertices(i,:); vertices(order(i,2),:)]; \n data2 = [vertices(i,:); vertices(order(i,3),:)]; \n % Use dor ptodict to find the angle between vector1 and vector2 \n Angles(i) = acos((diff(data1)*diff(data2)')/..... \n (sqrt(sum(diff(data1,[],1).^2,2))*sqrt(sum(diff(data2,[],1).^2,2)))) ;     \n end \n % Convert the angles in radians to degrees \n Angles = Angles*180./pi ;",
    "comment": "find the angles of Quadrilateral when vertices are known"
 },
 {
    "code": "function Angles = TRIangles(vertices) \n Angles = zeros(1,3) ; \n order = [1 2 3; 2 1 3;3 1 2] ; \n for i = 1:3 \n % Form the vectors along the vertices \n data1 = [vertices(i,:); vertices(order(i,2),:)]; \n data2 = [vertices(i,:); vertices(order(i,3),:)]; \n % Use dor ptodict to find the angle between vector1 and vector2 \n Angles(i) = acos((diff(data1)*diff(data2)')/..... \n (sqrt(sum(diff(data1,[],1).^2,2))*sqrt(sum(diff(data2,[],1).^2,2)))) ;     \n end \n % Convert the angles in radians to degrees \n Angles = Angles*180./pi ; ",
    "comment": "find the angles of Triangle when vertices are known"
 },
 {
    "code": " [nr, nc] = size(M);                  % input vectors  nr x nc \n   if     opt(fPerm),  allPerms(fPerm); \n   elseif opt(fOdd),   allPerms(fOdd); \n   elseif opt(fEven),  allPerms(fEven); \n   elseif opt(fCycle), allCycles; \n   end",
    "comment": "compute basic permutations, result in M"
 },
 {
    "code": "function kmph = ftps2kmph(ftps) \n \n kmph = ftps*1.09728;",
    "comment": "Convert speed from feet per second to kilometers per hour"
 },
 {
    "code": "function kts = ftps2kts(ftps) \n kts = ftps*1.687810;",
    "comment": "Convert speed from feet per second to knots"
	},
 {
    "code": "function mph = ftps2mph(ftps) \n mph = ftps/1.46666666667;",
    "comment": "Convert speed from feet per second to miles per hour"
 },
 {
    "code": "function mps = ftps2mps(ftps) \n mps = ftps*0.3048;",
    "comment": "Convert speed from feet per second to kilometers per hour"
 },
 {
    "code": "function ftps = kmph2ftps(kmph) \n ftps = kmph/1.09728;",
    "comment": "Convert speed from kilometers per hour to feet per second"
 },
 {
    "code": "function kts = kmph2kts(kmph) \n kts = kmph/1.852;",
    "comment": "Convert speed from kilometers per hour to knots"
 },
 {
    "code": "function mph = kmph2mph(kmph) \n mph = kmph/1.609344;",
    "comment": "Convert speed from kilometers per hour to miles per hour"
 },
 {
    "code": "function mps = kmph2mps(kmph) \n mps = kmph/3.6;",
    "comment": "Convert speed from kilometers per hour to meters per second"
 },
 {
    "code": "function ftps = kts2ftps(kts) \nftps = kts*1.687810;",
    "comment": "Convert speed from knots to feet per second"
 },
 {
    "code": "function kmph = kts2kmph(kts) \nkmph = kts*1.852;",
    "comment": "Convert speed from knots to kilometers per hour"
 },
 {
    "code": "function mph = kts2mph(kts) \nmph = kts/0.868976;",
    "comment": "Convert speed from knots to miles per hour"
 },
 {
    "code": "function mps = kts2mps(kts) \nmps = kts*0.514444444444444;",
    "comment": "Convert speed from knots to meters per second"
 },
 {
    "code": "function ftps = mph2ftps(mph) \nftps = mph*1.46666666667;",
    "comment": "Convert speed from miles per hour to feet per second"
 },
 {
    "code": "function kmph = mph2kmph(mph) \nkmph = mph*1.609344;",
    "comment": "Convert speed from miles per hour to kilometers per hour"
 },
 {
    "code": "function kts = mph2kts(mph) \nkts = mph*0.868976;",
    "comment": "Convert speed from miles per hour to knots"
 },
 {
    "code": "function mps = mph2mps(mph) \nmps = mph*0.44704;",
    "comment": "Convert speed from miles per hour to meters per second"
 },
 {
    "code": "function ftps = mps2ftps(mps) \nftps = mps./0.3048;",
    "comment": "Convert speed from meters per second to feet per second"
 },
 {
    "code": "function kmph = mps2kmph(mps) \nkmph = mps*3.6;",
    "comment": "Convert speed from meters per second to kilometers per hour"
 },
 {
    "code": "function kts = mps2kts(mps) \nkts = mps/0.514444444444444;",
    "comment": "Convert speed from meters per second to knots"
 },
 {
    "code": "function mph = mps2mph(mps) \nmph = mps/0.44704;",
    "comment": "Convert speed from meters per second to miles per hour"
 },
 {
    "code": "rng(0) \nx1=randn(200,10); \nboxplotx(x1) \nhold on \nboxplotx(randn(100,2),'lines','g-','points','r*') \nx2={randn(50,1),randn(1,300),randn(100,1)}; \nfigure \nboxplotx(x2,[1,4,6],[0.5,2,1]) \nfigure \nboxplotx(x2,'qpct',30,'bpct',5,'lines',{'r-','b-','g-'},  ... \n    'xpos',[1,4,6],'width',[0.5,2,1],  ... \n    'labels',{'50 Points','200 Points','100 Points'})",
    "comment": "Demonstration of boxplotx"
 },
 {
    "code": "function [X,Y]=ellipse(T, ax, ay, t0); \n X=ax*cos(T);   \n Y=ay*cos(T-t0);",
    "comment": "Function Defining an Ellipse"
 },
 {
    "code": "format long \n disp('The two sides and the angle:') \n a=4.1,  b=9.1,  A=20/180*pi \n disp('Use the sine theorem to obtain sin(B), then B and C') \n sB=b*sin(A)/a,  B=asin(sB),  C=pi-A-B \n disp('Calculate the side c by the sine theorem') \n c=a*sin(C)/sin(A) \n disp('Convert the angles to degrees') \n Adg=A/pi*180,  Bdg=B/pi*180,  Cdg=C/pi*180 \n disp('Repeat to find the second solution') \n a=4.1,  b=9.1,  A=20/180*pi \n sB=b*sin(A)/a,  B=pi-asin(sB),  C=pi-A-B \n disp('Convert the angles to degrees') \n Adg=A/pi*180,  Bdg=B/pi*180,  Cdg=C/pi*180",
    "comment": "Triangle with Two Sides and One Angle Known"
 },
 {
    "code": "x0=5;  X=-x0:0.01:x0;    \n Y1=sin(X);  Y2=cos(X);  Y3=tan(X);  Y4=cot(X);  \n figure(1),  plot(X,Y1,  X,Y2,  X,Y3,  X,Y4),  grid on \n y0=3;  \n axis([-x0 x0 -y0 y0]) \n title('Trigonometric Functions'),  xlabel('x'),  ylabel('sin(x), cos(x), etc.') \n legend('sin(x)', 'cos(x)', 'tan(x)', 'cot(x)') ",
    "comment": "Plot Trigonometric Functions"
 },
 {
    "code": "x0=1;  X=-x0:0.01:x0; \n Y1=acos(X);  Y2=atan(X);   \n figure(1),  plot(X,Y1, X,Y2),  grid on \n y0=2*pi; \n axis([-x0 x0 -y0 y0]) \n title('Inverse Functions'),  xlabel('x'),  ylabel('acos(x), atan(x)') \n legend('acos(x)', 'atan(x)') ",
    "comment": "Plot Inverse Trigonometric Functions"
 },
 {
    "code": "x0=10;  X=-x0:0.01:x0; \n Y1=exp(X);  Y2=1e3*exp(X);  Y3=1e6*exp(X);       \n figure(1),  plot(X,Y1, X,Y2, X,Y3),  grid on \n title('Exponential functions'),  xlabel('x'),  ylabel('exp(x), etc.') \n legend('exp(x)', '1e3*exp(x)', '1e6*exp(x)') \n axis([-x0 x0 0 2.5e4])",
    "comment": "Plot Exponential Functions"
 },
 {
    "code": "x0=10;  X=0.01: 0.01: x0;   \n Y1=log(X);  Y2=log(1e3*X);  Y3=log(1e6*X);       \n figure(1),  plot(X,Y1, X,Y2, X,Y3),  grid on \n title('Logarithmic functions'),  xlabel('x'),  ylabel('log(x), etc.') \n legend('ln(x)', 'ln(1e3*x)', 'ln(1e6*x)')",
    "comment": "Plot  Logarithmic Functions"
 },
 {
    "code": "x0=100;  X=-x0: 0.1: x0; \n Y=exp(X);   \n figure(1),  semilogy(X,Y),  grid on \n title('Exponential function'),  xlabel('x'),  ylabel('exp(x)')",
    "comment": "Plot Exponential Functions"
 },
 {
    "code": "x0=5;  X=-x0: 0.01: x0; \n Y1=exp(-X.^2);  Y2=exp(-3*X.^2);      \n figure(1),  semilogy(X,Y1,  X,Y2),  grid on \n title('Gaussian functions'),  xlabel('x'),  ylabel('exp(-x^2), exp(-3x^2)') \n legend('exp(-x^2)',  'exp(-3x^2)')",
    "comment": "Plot Gaussian Functions"
 },
 {
    "code": "X=-3: 0.01: 3;  Y=gaussian(X,1); \n figure(1),  plot(X,Y),  grid on,  title('Gaussian')",
    "comment": "Plot Gaussian"
 },
 {
    "code": "X=-3: 0.01: 3;  Y1=gaussian(X,1);  Y2=gaussian(X,0.2); \n figure(1),  plot(X,Y1,  X,Y2),  grid on,  title('Gaussians') \n legend('a=1.0', 'a=0.2')",
    "comment": "Plot  two Gaussians"
 },
 {
    "code": "T= 0:1e-3:2*pi; \n [X1,Y1]=ellipse(T, 2, 1, 0);   \n [X2,Y2]=ellipse(T, 2, 1, pi/3);   \n [X3,Y3]=ellipse(T, 2, 1, pi/2);   \n figure(1);  plot(X1,Y1,  X2,Y2,  X3,Y3);  grid on;  axis equal; \n title('Ellipses'); \n legend('t0=0', 't0=pi/3', 't0=pi/2'),  xlabel('x'),  ylabel('y')",
    "comment": "Plot of Ellipses"
 },
 {
    "code": "f=inline('x^3- 2*x^2- x+2'); \n figure(1),  fplot(f, [-2 3]),  grid on,  zoom on \n    title('x^3-2*x^2-x+2'),  xlabel('x')",
    "comment": "Plot a Cubic Polynomial"
 },
 {
    "code": "clear all \n X=logspace(0, 100, 600); \n Y=(2*X-1) ./ sqrt(3*X.^2+X+1); \n figure(1),  semilogx(X,Y),  grid on,  xlabel('x')",
    "comment": "Limit Toward positive Infinity"
 },
 {
    "code": "clear all \n X=-logspace(1, 300, 600); \n Y=(sqrt(1-X).*(1-sqrt(3-2*X)))./(1+6*X); \n figure(1),  semilogx(X,Y),  grid on,  xlabel('x')",
    "comment": "Limit Toward Minus Infinity"
 },
 {
    "code": "clear all \n X= logspace(1, 100, 600);  Y=X./log(X.^2); \n figure(1),  semilogx(X,Y),  grid on,  xlabel('x')",
    "comment": "Limit Toward Plus Infinity"
 },
 {
    "code": "clear all \n X= logspace(-50, 0, 600);  Y= sin(X)./ X; \n figure(1),  semilogx(X,Y),  grid on,  xlabel('x')",
    "comment": "Limit Toward Zero"
 },
 {
    "code": "X=0: 0.01: 10;  Y=xcos(X); \n h=1e-4; \n Der=(xcos(X+h)- xcos(X))/ h; \n figure(1),  plot(X,Y,  X,Der),  grid on, \n legend('f=x*cos(x)', 'df/dx'),  xlabel('x') \n Dex=cos(X)-X.*sin(X); \n figure(2),  plot(X,Der,  X,Dex),  grid on,  legend('df/dx', 'exact') \n figure(3),  plot(X, Der- Dex),  grid on,  title('Error in df/dx')",
    "comment": "Plot a Function and its Derivative"
 },
 {
    "code": "X=0: 0.01: 10;  Y=xcos(X); \n h=1e-4; \n Der=(xcos(X+h)- xcos(X-h))/(2*h); \n figure(1),  plot(X,Y,  X,Der),  grid on,   \n    legend('f=x*cos(x)', 'df/dx'),  xlabel('x') \n Dex=cos(X)-X.*sin(X); \n figure(2),  plot(X,Der,  X,Dex),  grid on,  legend('df/dx', 'exact') \n figure(3),  plot(X, Der- Dex),  grid on,  title('Error in df/dx')",
    "comment": "Plot a Function and its Symmetric Derivative"
 },
 {
    "code": "X=0:0.01:10;  Y=xcos(X); \n h=1e-4; \n Der=(xcos(X+h)- xcos(X-h))/(2*h); \n Der2=(xcos(X+h)-2*xcos(X)+xcos(X-h))/h^2; \n figure(1),  plot(X,Y,  X,Der,  X,Der2),  grid on,  xlabel('x')  \n    legend('f=x*cos(x)', 'df/dx', 'd2f/dx2') \n D2ex=-sin(X)- sin(X)- X.*cos(X); \n figure(2),  plot(X,Der2,  X,D2ex),  grid on \n    legend('d2f/dx2', 'exact') \n figure(3),  plot(X,Der2-D2ex),  grid on,  title('Error in d2f/dx2')",
    "comment": "Plot Second-Order Derivative"
 },
 {
    "code": "clear all,  format long \n k=input('k= (e.g. 2) '); \n si=0; \n for i=1:20 \n    term=k^(i-1); \n si=si+term; \n si_ex=(1-k^i)/(1-k); \n sums=[si  si_ex], pause \n end",
    "comment": "Sum of a Geometric Series"
 },
 {
    "code": "x=input('x= (e.g. 1) '); \n term=x;  s=x;  i=0; \n while 1==1 \n i=i+1; \n    term=term*(-x^2)/(2*i+1)/(2*i); \n    s=s+ term; \n    if abs(term)<1e-15;  break;  end; \n end \n last_index_in_sum=i \n sum=s,  sin_ex=sin(x) \n format short e,  error=s- sin(x)",
    "comment": "Power Series for sin(x)"
 },
 {
    "code": "clear all,  syms x,  fun=inline( 'exp(x*sin(x))' ); \n taylor=... \n inline('1+1*x^2+1/3*x^4+1/120*x^6-11/560*x^8-1079/362880*x^10'); \n figure(1), fplot( fun, [0 2], 'b'),  grid on, hold on \n fplot( taylor, [0 2], 'r'), legend('fun', 'taylor'), hold off",
    "comment": "Compare Function with Taylor Expansion"
 },
 {
    "code": "rand('seed',sum(100*clock)) \n n=5000; \n X=2*(rand(1,n)-0.5);  \n figure(1),  hist(X,10);  grid on \n    title('Number of Random Values in Each Container')",
    "comment": "Histogram of symmetric random numbers"
 },
 {
    "code": "rand('seed',sum(100*clock)) \n while 1==1 \n    head=ceil(rand-0.5) \n    pause \n end",
    "comment": "Tossing Coins"
 },
 {
    "code": "m0=100; \n sdev=sqrt(m0)/2; \n for j=1:m0+1 \n    m=j-1; \n    Xm(j)=m; \n    Ybd(j)=prod(1:m0)/prod(1:m)/prod(1:(m0-m))*0.5^m0; \n    Nd(j)=1/sdev/sqrt(2*pi)* exp(-(m- m0/2)^2/2/sdev^2); \n end \n figure(1),  plot(Xm,Ybd,'g',  Xm,Nd,'k:'),  grid on,  axis([0 100 0 0.09]) \n    title('Binomial and Normal Distributions') \n    xlabel('number of heads'),  ylabel('probability') \n figure(2),  plot(Xm,Ybd-Nd),  grid on,  axis([0 100 0 3e-4]);",
    "comment": "Binomial and Normal Distributions"
 },
 {
    "code": "P=1: 1e-3: 2;  np=length(P); \n for i=1:np \n    F(i)=sdev(P(i)); \n end \n figure(1),  plot(P,F),  grid on,  xlabel('p'),  ylabel('sdev')",
    "comment": "Standard Deviation to Minimize"
 },
 {
    "code": "T=[200  250  300  350  400]; \n I=[0.1176    0.0926    0.0735    0.0711    0.0594]*1e-7; \n P=1.5e-6: 5e-9: 3.5e-6; \n n=length(P); \n for i=1:n \n    F(i)=ssq1( P(i), T, I); \n end \n figure(2),  plot(T,I,'o',  T,2.34e-6./T),  grid on,  xlabel('temperature')",
    "comment": "Minimize Standard Deviation, Plot Result"
 },
 {
    "code": "randn('seed', sum(100*clock)); \n n=10000;  Y=randn(1,n); \n ymean=sum(Y)/n \n sdev=sqrt( sum( (Y- ymean).^2) /(n-1) )",
    "comment": "Normal Distribution from Random Numbers"
 },
 {
    "code": "F=inline('-Y', 'X', 'Y'); \n X(1)=input('x1=  (e.g. 0) ');  Y(1)=input('y1=  (e.g. 3) '); \n n=400;  h=0.01; \n for i=1:n \n    dy= F( X(i), Y(i))*h; \n    X(i+1)=X(i)+h; \n    Y(i+1)=Y(i)+dy; \n end \n figure(1),  plot(X,Y, 'r'),  grid on,  axis([0 n*h 0 3])",
    "comment": "Euler's Numerical Solution for dy/dx=-y"
 },
 {
    "code": "F=inline('sin(X.*Y)', 'X', 'Y'); \n X(1)=input('x1=  (e.g. 0) ');  Y(1)=input('y1=  (e.g. 3) '); \n n=500;  h=0.01; \n for i=1:n \n    dy=F( X(i), Y(i))*h; \n    X(i+1)=X(i)+h; \n    Y(i+1)=Y(i)+dy; \n end \n figure(1),  plot(X,Y),  grid on,  axis([0 n*h 0 5]) \n    title( 'dy/dx= sin(x y)'),  xlabel('x')",
    "comment": "Euler Solution for dy/dx= sin(x y)"
 },
 {
    "code": "clear all,  echo off \n [y,z]=dsolve('Dy-y-z= 0',  'Dz-y+z= 0',  'y(0)=0,  z(1)=1', 'x') \n ezplot(y, [-4, 4], 1),  title('Solution for y'),  grid on \n ezplot(z, [-4, 4], 2),  title('Solution for z'),  grid on",
    "comment": "Solve a System of 1st-Order ODEs"
 },
 {
    "code": "function [x,y]=limits(a) \n if nargin~=1 || nargout>2 \n   error('usage: [lo,hi]=limits(a)') \n end \n if numel(a)==1 %scalar \n   result=a; \n else %matrix \n   result=[min(a(:)) max(a(:))]; \n end \n if nargout==1 \n   x=result; \n elseif nargout==2 %separate results \n   x=result(1); \n   y=result(2); \n else \n   ans=result \n end",
    "comment": "LIMITS returns min & max values of matrix"
 },
 {
    "code": "function f = fibnum(n) \n if n <= 1 \n    f = 1; \n else \n    f = fibnum(n-1) + fibnum(n-2); \n end",
    "comment": "Fibonacci number"
 },
 {
    "code": "function f = fibonacci(n) \n f = zeros(n,1); \n f(1) = 1; \n f(2) = 2; \n for k = 3:n \n    f(k) = f(k-1) + f(k-2); \n end",
    "comment": "generates the first n Fibonacci numbers."
 },
 {
    "code": "function[ans] = ilaplacetf(G) \n syms s; \n symNum = cell2mat(G.num); \n symDen = cell2mat(G.den); \n num   = poly2sym(symNum, s); \n den   = poly2sym(symDen, s); \n symTF = num/den; \n ans = ilaplace(symTF); \n end",
    "comment": "Inverse Laplace Transform Calculator"
 },
 {
    "code": "function [deg] = Poly_DEG (poly) \n if isempty (poly) \n     error ( 'Input poly to function Poly_DEG (poly) is empty !' ) ; \n end \n deg = length (poly) - 1 ; ",
    "comment": "function to get the degree of a Normal Polynomial"
 },
 {
    "code": "function [d] = bernoulli_power_series(c) \n K = length(c)-1; \n d = zeros(1,K+1); \n for v = 0:K \n     d(1) = d(1) + c(v+1)/(v+1); \n end \n for k=1:K \n     for v=k:K \n     d(k+1) = d(k+1)+c(v+1)*factorial(v)/factorial(v-k+1); \n     end \n end \n d = d./factorial(0:K); \n end",
    "comment": "function to convert simple serie into bernoulli power series"
 },
 {
    "code": "function [c] = inverse_bernoulli_power_series(d) \n K = length(d)-1; \n d(2:K+1) = -d(2:K+1).*factorial(1:K); d=d'; \n %% Calculate coefficient map \n Delta = zeros(K+1,K+1);  \n for k=1:K \n     for l=1:k \n         Delta(k+1,l+1) = -factorial(k)/factorial(k-l+1); \n     end \n end \n Delta(:,1) = 1./((0:K)+1); Delta = transpose(Delta); \n c = (Deltad)'; \n end",
    "comment": "function to convert bernoulli serie into inverse bernoulli power series"
 },
 {
    "code": "function pol = polysqrt(p) \n     deg_p = length(p) - 1; \n     if( mod(deg_p,2) ) \n         pol = []; \n         return \n     end \n      \n     n_var = deg_p/2 + 1; \n     pol = zeros(1,n_var); \n      \n     pol(1) = sqrt(p(1)); \n     \n     for pos=2:n_var \n         indep_term = p(pos) - calc_delta(pol(2:pos-1)); \n         pol(pos) = indep_term/(2*pol(1)); \n     end \n      \n     test_pol = conv(pol,pol); \n     res = max(abs(p-test_pol)); \n     if(res > 1e-6) \n         pol = []; \n     end \n end \n      \n function res = calc_delta(t)    \n k = length(t); \n res = 0; \n for i=1:k \n res = res + t(i)*t(k-i+1); \n end \n end",
    "comment": "Find a square root of a polynomial"
 },
 {
    "code": "function str = num2string(coef,cformat) \n validateattributes(coef, {'numeric'}, {'scalar'}); \n if nargin >= 2 \n     validateattributes(cformat, {'char'}, {'vector'}); \n else \n     cformat = get(0,'format'); \n end \n cformat = lower(cformat); \n % get the window format \n switch cformat \n     case 'short' \n         str = sprintf('%6f', coef); \n     case 'shorte' \n         str = sprintf('%.4e', coef); \n     case 'shortg' \n         str = sprintf('%.5g', coef); \n     case 'long' \n         str = sprintf('%16f', coef); \n     case 'longe' \n         str = sprintf('%.14e', coef); \n     case 'longg' \n         str = sprintf('%.15g', coef); \n     case {'rat','rational'} \n         str = rats(coef,15); \n         str = strtrim(str); \n     otherwise \n         str = num2str(coef); \n end",
    "comment": "Convert a numeric value to a string in the specified format"
 },
 {
    "code": "function m = gslope(ignored) \n [x,y]=ginput(2); \n if nargin > 0 \n   line(x,y,'linesty','none','marker','x','linestyle','--','color','k') \n end \n if strcmp(get(gca,'xsc'),'log'), x = log10(x); end \n if strcmp(get(gca,'ysc'),'log'), y = log10(y); end \n m = diff(y)/diff(x);",
    "comment": "Estimate a slope from two mouse clicks"
 },
 {
    "code": "function [A,B] = jacobians(xdot,x,u,x0,u0) \n A = sym(zeros(numel(x),numel(x))); \n B = sym(zeros(numel(x),numel(u))); \n for i = 1:numel(x) \n     for j = 1:numel(x) \n         A(i,j) = diff(xdot(i),x(j)); \n     end \n end \n for i = 1:numel(x) \n     for j = 1:numel(u) \n         B(i,j) = diff(xdot(i),u(j)); \n     end \n end \n if nargin > 3 \n     A = subs(A,[x;u],[x0;u0]); \n     B = subs(B,[x;u],[x0;u0]); \n end",
    "comment": "Linear approximation matrices of a non-linear dynamic model"
 },
 {
    "code": "function X = inv2(A, B, varargin) \n if size(A,1) ~= 2 || size(A,2) ~= 2 \n     error('A must be [2x2xn] array'); \n end \n A = reshape(A, 4, []).'; \n X = [A(:,4) -A(:,2) -A(:,3) A(:,1)]; \n       \n D = A(:,1).*A(:,4) - A(:,2).*A(:,3); \n X =  bsxfun(@times, X, 1./D); \n X = reshape(X.', 2, 2, []); \n if nargin>=2 \n     X = mtimesx(X,B,'speed'); \n end \n end",
    "comment": "matrix-inverse or inversion of 2x2 matrix"
 },
 {
    "code": "D = A(:,1).*A(:,4) - A(:,2).*A(:,3); \n X =  bsxfun(@times, X, 1./D); \n X = reshape(X.', 2, 2, []); \n if nargin>=2 \n     X = mtimesx(X,B,'speed'); \n end",
    "comment": "calculate Determinant of a matrix"
 },
 {
    "code": "clc \n clear  \n close all \n t=0.00001:0.01:10; \n f=randn(1,numel(t)); \n plot(t,f); \n s=0:0.01:2; \n for i=1:numel(s) \n    L(i)=trapz(t,f.*exp(-s(i)*t));  \n end \n figure \n plot(s,L)",
    "comment": "Numerical solution of Laplace transform for random functions"
 },
 {
    "code": "function [mx,idx,col]=maxn(A) \n if ~isnumeric(A) \n    error('Numeric Input Expected.') \n end \n mx=max(A(:)); \n if nargout==2 \n    idx=find(A==mx); \n     \n elseif nargout==3 && ndims(A)==2 \n    [idx,col]=find(A==mx); \n     \n elseif nargout==3 \n    error('Three Output Arguments Requires 2-D Input.') \n end",
    "comment": "returns the maximum value found in the array A."
 },
 {
    "code": "function [mn,idx,col]=minn(A) \n if ~isnumeric(A) \n    error('Numeric Input Expected.') \n end \n mn=min(A(:)); \n if nargout==2 \n    idx=find(A==mn); \n     \n elseif nargout==3 && ndims(A)==2 \n    [idx,col]=find(A==mn); \n     \n elseif nargout==3 \n    error('Three Output Arguments Requires 2-D Input.') \n end",
    "comment": "returns the minimum value found in the array A."
 },
 {
    "code": "function op=loacal_maximums(s) \n s1=s(1:end-2); \n s2=s(2:end-1); \n s3=s(3:end); \n % maximums: \n op=1+find((s1<=s2)&(s2>=s3));",
    "comment": "function to find the local maximum "
 },
 {
    "code": "function op=loacal_minimums(s) \n s1=s(1:end-2); \n s2=s(2:end-1); \n s3=s(3:end); \n % minimums: \n op=1+find((s1>=s2)&(s2<=s3));",
    "comment": "function to find the local minimum"
 },
 {
    "code": "function Ic = adjacency2incidence(A) \n [i,j,s] = find(sparse(A)); \n I = find(i<=j); \n i = i(I); \n j = j(I); \n n = length(i); \n nverts = size(A,1); \n s = [ones(n,1); -ones(n,1)]; \n is = [(1:n)'; (1:n)']; \n js = [i(:); j(:)]; \n Ic = sparse(is,js,s,n,nverts); \n Ic = Ic'; \n a = find(i==j); \n if not(isempty(a)) \n     for t=a' \n         Ic(i(t),t) = 1; \n     end \n end",
    "comment": "convert an adjacency matrix to an incidence matrix"
 },
 {
    "code": "function adj_list = adjmatrix2list(A) \n n = size(A,1); \n for i=1:n \n     I = find( and( A(i,:)>0,  A(i,:)~=Inf) ); \n     adj_list{i} = I; \n end",
    "comment": "convert from matrix adjacency to list adjacency."
 },
 {
    "code": "function y = adiff(a,varargin) \n if isa(a,'function_handle') \n   d = cell2mat(varargin); \n   [a1,a2,p] = prepfct(ainit([]),d); \n   eval(['y = @(' a1 ') aeval(adiff(a(' a2 '),d));']) \n   return \n end \n if numel(a)>1 \n   y = a; \n   for i = 1:numel(a) \n     y(i) = adiff(a(i),varargin{:}); \n   end \n   return \n end \n if nargin == 1 \n   d = zeros(1,aord(a)); \n else \n   d = cell2mat(varargin); \n end \n y = a; \n y.k = a.k - sum(d); \n y.c = a.c(:,1:nchoosek(y.n+y.k,y.n)); \n audi([],0,adim(a),aord(a)-sum(d)); \n for i = 1:size(y.c,2) \n   y.c(:,i) = a.c(:,idx(a,sub(y,i)+d)); \n end",
    "comment": "Partial derivative of audi array or function."
 },
 {
    "code": "function out = all_comb(varargin) \n nitem = numel(varargin); \n if nitem == 2 \n elseif nitem == 5 \n i1 = varargin{1}; n1 = numel(i1); \n i2 = varargin{2}; n2 = numel(i2); \n i3 = varargin{3}; n3 = numel(i3); \n i4 = varargin{4}; n4 = numel(i4); \n i5 = varargin{5}; n5 = numel(i5); \n nposs = n1*n2*n3*n4*n5; \n labels = nan(nposs,nitem); % matrix for later use (ANOVA etc) \n combs  = nan(nposs,nitem); \n ctr = 1; \n for p = 1:n1 \n for q = 1:n2 \n for r = 1:n3 \n for s = 1:n4 \n for t = 1:n5 \n labels(ctr,:) = [p q r s t]; \n combs(ctr,:) = [i1(p) i2(q) i3(r) i4(s) i5(t)]; \n ctr = ctr + 1; \n end \n end \n end \n end \n end \n end \n out.levels = labels; \n out.combs  = combs;",
    "comment": "enumerate all combinations of the data"
 },
 {
    "code": "function post = bayes_post(A_suc,A_tot,B_suc,B_tot) \n prob_B           = B_tot / (A_tot + B_tot); \n prob_suc_given_B = B_suc / B_tot; \n prob_suc         = (A_suc + B_suc) / (A_tot + B_tot); \n post = (prob_B * prob_suc_given_B) / prob_suc;",
    "comment": "calculate posterior probability p(B|suc) given:"
 },
 {
    "code": "function [Der, DerC] = CDerivative(type, X, Y) \n     switch type \n         case 'splitTanh' \n             DR = 1 - real(Y).^2; \n             DI = 1 - imag(Y).^2; \n             Der = 0.5*(DR + DI); \n             DerC = 0.5*(DR - DI); \n         case 'splitSigm' \n             DR = real(Y).*(1 - real(Y)); \n             DI = imag(Y).*(1 - imag(Y)); \n             Der = 0.5*(DR + DI); \n             DerC = 0.5*(DR - DI); \n         case 'linear' \n             Der = ones(size(X)); \n             DerC = zeros(size(X)); \n         case 'sech' \n             Der = -tanh(X).*Y; \n             DerC = zeros(size(X)); \n         case 'tanh' \n             Der = sech(X).^2; \n             DerC = zeros(size(X)); \n         case 'sinh' \n             Der = cosh(X); \n             DerC = zeros(size(X)); \n         case 'tan' \n             Der = sec(X).^2; \n             DerC = zeros(size(X)); \n         case 'sin' \n             Der = cos(X); \n             DerC = zeros(size(X)); \n         case 'atan' \n             Der = 1./(1 + X.^2); \n             DerC = zeros(size(X)); \n         case 'asin' \n             Der = 1./sqrt(1 - X.^2); \n             DerC = zeros(size(X)); \n         case 'acos' \n             Der = -1./sqrt(1 - X.^2); \n             DerC = zeros(size(X)); \n         case 'George' \n             Denom = (1 + X.*conj(X)).^2; \n             Der = 1./Denom; \n             DerC = (-X.^2)./Denom; \n         case 'atanh' \n             Der = 1./(1 - X.^2); \n             DerC = zeros(size(X)); \n         case 'asinh' \n             Der = 1./sqrt((1 + X.^2)); \n             DerC = zeros(size(X)); \n         otherwise \n             error('Unknnown Activation Function'); \n     end \n end",
    "comment": "Derivatives of different values"
 },
 {
    "code": "function [u,l,D] = Del0(x,n,epsilon) \n     d = pdist2(x',x'); \n     if (nargin<3) \n         k=1+ceil(log(n)); \n         epsilon = mink(d,k); \n         epsilon = mean(epsilon(k,:)) \n     end \n     d = exp(-d.^2/epsilon^2/4); \n     d = (d+d')/2; \n     D = diag(1./sum(d,2)); \n     d = D*d*D; \n     D = diag(sum(d,2)); \n     d = (d + d')/2; \n     [u,l] = eigs(d,D,n,'LM'); \n     l=diag(l); \n     [l,sinds]=sort(real(l),'descend'); \n     l=-log(l)/epsilon^2; \n     u=u(:,sinds);",
    "comment": "Construction of the 0-Laplacian using the Diffusion Maps algorithm"
 },
 {
    "code": "function [U,L,D1,G,H,cijk] = Del1AS(u,l,D,n) \n     n0=size(u,2); \n     if (nargin<3)  \n         n = n0;  \n     end \n     cijk = repmat(u(:,1:n),[1 1 n n0]); \n     cijk = squeeze(sum(cijk.*permute(cijk,[1 3 2 4]).*permute(repmat(D*u,[1 1 n n]),[1 3 4 2]))); \n     l1 = repmat(l,[1 n n n n]); \n     l2 = repmat(l(1:n),[1 n n0 n n]); \n     h0 = repmat(cijk,[1 1 1 n n]); \n     h0 = squeeze(sum(permute(h0,[4 1 3 5 2]).*permute(h0,[1 4 3 2 5]).*(permute(l2,[2 1 3 4 5]) + permute(l2,[4 2 3 5 1]) - permute(l1,[3 2 1 5 4])),3)); \n     H = h0 - permute(h0,[2 1 3 4]); \n     G = h0 + permute(h0,[2 1 4 3]) - permute(h0,[1 2 4 3]) - permute(h0,[2 1 3 4]); \n     clear h0; \n     D1 = repmat(cijk,[1 1 1 n n]);    \n     lambdas1 = permute(l1,[2 3 1 4 5]).^2 - permute(l1,[2 3 1 4 5]).*(l2 + permute(l2,[2 1 3 4 5])+permute(l2,[2 4 3 1 5])+permute(l2,[2 4 3 5 1])); \n     D1 = 2*squeeze(sum((permute(D1,[2 5 3 1 4]).*permute(D1,[5 2 3 4 1])-permute(D1,[5 2 3 1 4]).*permute(D1,[2 5 3 4 1])).*lambdas1,3)); \n     D1 = reshape(D1,n^2,n^2); \n     G = reshape(G,n^2,n^2); \n     H = reshape(H,n^2,n^2); \n     D1 = (D1+D1')/2; \n     G = (G+G')/2; \n     [Ut,St,~]=svd(D1+G); \n     St = diag(St); \n      NN = find(St/St(1,1) < 1e-3,1); \n      D1proj = Ut(:,1:NN)'*D1*Ut(:,1:NN); \n     D1proj = (D1proj+D1proj')/2; \n     Gproj = Ut(:,1:NN)'*G*Ut(:,1:NN); \n     Gproj = (Gproj+Gproj')/2; \n     [U,L] = eig(D1proj,Gproj); \n     [L,sinds]=sort(abs(diag(L))); \n     U = real(U(:,sinds)); \n     U = Ut(:,1:NN)*U;",
    "comment": " Construction of the 1-Laplacian"
 },
 {
    "code": "function C = comm(n,m) \n if (n*m)*(n*m) > 100 \n     C = reshape(kron(vec(speye(n)), speye(m)), n*m, n*m); \n else \n     C = reshape(kron(vec(eye(n)), eye(m)), n*m, n*m); \n end \n end",
    "comment": "Returns the commutator matrix C_{n,m} that turns vec(A) into vec(A')"
 },
 {
    "code": "function D = dupl(n) \n A = tril(ones(n)); \n A(logical(A)) = 1:(n*(n+1)/2); \n A = A + tril(A,-1)'; \n D = sparse(1:(n*n), A(:), ones(n*n,1), n*n, n*(n+1)/2); \n end",
    "comment": "Returns the duplication matrix D_n such that vec(S) = D_n*vech(S)."
 },
 {
    "code": "function E = elim(n) \n E = sparse(1:(n*(n+1)/2), vech(reshape(1:(n*n),n,n)), ones(n*(n+1)/2,1), n*(n+1)/2, n*n); \n end",
    "comment": "Returns the elimination matrix E_n such that vech(S) = E_n*vec(S)."
 },
 {
    "code": "function v = vec(A) \n v = A(:); \n end",
    "comment": "returns a vector of the columns from the matrix A"
 },
 {
    "code": "syms x \n y=3*x^5-x^3+2*x-5; \n subs(y,x,4)",
    "comment": "If f(x) = 3x^5-x^3+2x-5, then Write a MATLAB code to find the value of f(4)."
 },
 {
    "code": "syms x roots([1 -1 -6])",
    "comment": "Write a MATLAB code to find the solution of x^2-x-6=0"
 },
 {
    "code": "cos(pi/3)",
    "comment": "Write a MATLAB code to find cos(pi/3)"
 },
 {
    "code": "sqrt(37)",
    "comment": "Write a MATLAB code to find  root(37)"
 },
 {
    "code": "atan(1)",
    "comment": "Write a MATLAB code to find atan(1)"
 },
 {
    "code": "log10(2)",
    "comment": "Write a MATLAB code to find log10(2)"
 },
 {
    "code": "exp(3) ",
    "comment": "Write a MATLAB code to find exp(3)"
 },
 {
    "code": "syms x \n y=6*x^3-5*x^2+8*x+4; \n diff(y,x,1)",
    "comment": "If f(x) = 6x^3 - 5x^2 +8x +4 then find f'(x)"
 },
 {
    "code": "syms x \n y=6*x^3-5*x^2+8*x+4; \n diff(y,x,1)",
    "comment": "If f(x) = 6x^3 - 5x^2 +8x +4 then find first derivate of x"
 },
  {
    "code": "syms x \n y=6*x^3-5*x^2+8*x+4; \n diff(y,x,2)",
    "comment": "If f(x) = 6x^3 - 5x^2 +8x +4 then find f''(x)"
 },
 {
    "code": "syms x \n y=6*x^3-5*x^2+8*x+4; \n diff(y,x,2)",
    "comment": "If f(x) = 6x^3 - 5x^2 +8x +4 then find second derivate of x"
 },
 {
    "code": "clc \n clear all \n syms x \n f=input('Enter the function f(x):'); \n fx=diff(f,x); \n ax=solve(fx) \n fxx=diff(fx,x); \n D=fxx; \n figure \n ezplot(f,[min(double(ax))-.5, max(double(ax))+.5]); \n for i=1:1:size(ax) \n     E1=subs(D,x,ax(i)); \n     E2=subs(f,x,ax(i)); \n      \n if(double(E1)==0) \n     sprintf('The point %d needs further investigation',double(ax(i))) \n      \n elseif(double(E1)<0) \n     sprintf('The maximum value of the function is %d at the point %d',double(E2),double(ax(i))) \n     st='y.'; \n else \n     sprintf('The minimum value of the function is %d at the point %d',double(E2),double(ax(i))) \n     st='k*'; \n end \n hold on \n plot(double(ax(i)),double(E2),st,'markersize',25) \n end",
    "comment": "Write a MATLAB code to find the extreme values of the function f(x) = x^3/3 - x^2 +2 . Also visualize it."
 },
 {
    "code": "clc \n clear all \n syms x \n f=input('Enter the function f(x):'); \n fx=diff(f,x); \n ax=solve(fx) \n fxx=diff(fx,x); \n D=fxx; \n figure \n ezplot(f,[min(double(ax))-.5, max(double(ax))+.5]); \n for i=1:1:size(ax) \n     E1=subs(D,x,ax(i)); \n     E2=subs(f,x,ax(i)); \n      \n if(double(E1)==0) \n     sprintf('The point %d needs further investigation',double(ax(i))) \n      \n elseif(double(E1)<0) \n     sprintf('The maximum value of the function is %d at the point %d',double(E2),double(ax(i))) \n     st='y.'; \n else \n     sprintf('The minimum value of the function is %d at the point %d',double(E2),double(ax(i))) \n     st='k*'; \n end \n hold on \n plot(double(ax(i)),double(E2),st,'markersize',25) \n end",
    "comment": "Write a MATLAB code to find the extreme values of the function f(x)=x^4-x^2+2. Also visualize it."
 },
 {
    "code": "syms x \n f=input('Enter f(x):'); \n g=input('Enter g(x):'); \n L=input('Enter the limits of x[a b]:'); \n a=L(1); \n b=L(2); \n Area=int(f-g,x,a,b) \n x1=linspace(a,b,100); \n y1=subs(f,x,x1); \n x2=x1; \n y2=subs(g,x,x1); \n plot(x1,y1) \n hold on \n plot(x2,y2) \n title('Area under the curves')",
    "comment": "Write a MATLAB code to find the area of the region bounded by the curves y = x^2 and y = 2x+3 Also visualize it."
 },
 {
    "code": "syms x y \n f = input(' enter the function f(x,   y):') \n I=input('enter the point [a b] around which taylor series is sought:')  \n a=I(1)  \n b=I(2) \n n=input('enter the order of the series:') \n taylor(f,  [x    y],  [a b],'order',n)",
    "comment": "Write a MATLAB code to find the Taylor series expansion of f(x,y) = cos(xy) in power of x-1 and y-(pi/2) up to four terms and."
 },
 {
    "code": "syms x y z \n int(int((x+y), y, 0, (4-x^2)),x,1,2) \n viewSolid(z, 0+0*x+0*y, (x+y), y, 0*y, (4-x^2), x,1,2)",
    "comment": "Write a MATLAB code for graphing the surface of the function e^x+e^y"
 },
 {
    "code": "x = linspace(0, 1, 300); \n h = humps(x); \n dx = x(2) - x(1); \n dhdx = gradient(h,dx); \n subplot(2, 1, 1) \n     plot(x, h) \n     xlabel('x'); \n     ylabel('$$h(x)$$', 'Interpreter', 'latex'); \n     title('humps(x)'); \n     grid on; \n subplot(2, 1, 2); \n     plot(x, dhdx); \n     title('Derivative of humps using gradient'); \n     xlabel('x'); \n     ylabel('$$\frac{dh(x)}{dx}$$', 'Interpreter', 'latex'); \n     grid on;",
    "comment": "Demonstrate gradient of tabulated values"
 },
 {
    "code": "sinc = @(x) sin(x)./x; \n x = linspace(0, 4*pi, 300); \n plot(x, sinc(x)); \n grid on \n xmin = 0;  \n xmax = 4*pi; \n I = integral(sinc, xmin, xmax); \n disp(['Integral is: ', num2str(I)]); \n width = 1; \n g = @(x) gauss(x, 0, width); \n I = integral(g, -width, width); \n disp(['Integral of Gaussian: ', num2str(I)]);",
    "comment": "Show integration using anonymous function"
 },
 {
    "code": "f = @(x) (1-x.^(4/3)).^(3/4); \n x = 0:0.01:1; \n px = [0 x]; \n py = [0 f(x)]; \n fill(px, py, [0.9, 0.9, 0.95], 'linestyle', ':') \n grid on \n xlim([-0.25 1.5]) \n ylim([-0.25 1.5]) \n g = @(x) x .* f(x); \n fprintf('V = %.4f\n', 2*pi*quad(g, 0, 1)) \n ",
    "comment": "volume of the solid generated by revolving the region"
 },
 {
    "code": "h = 25; \n x = 0:h:200; \n depth = [20, 19, 19, 17, 15, 14, 10, 6, 0]; \n y = x .* depth; \n M = length(x); \n V = y(1) + 4*sum(y(2:2:M)) + 2 * sum(y(3:2:M-1)) + y(M); \n V = 2 * pi * h * V / 3; \n fprintf('(a) Simpson's Rule: %.4f cubic feet\n', V); \n p = polyfit(x, depth, 2); \n fprintf('(b) Quadratic regression: depth = %.6f x^2 + %.4f x + %.4f\n', ... \n   p(1), p(2), p(3)); \n x1 = 0:200; \n plot(x1, polyval(p, x1), 'b') \n hold on \n plot(x, depth, 'r*') \n hold off \n grid on \n title('(b) Quadratic Regression') \n ylabel('Depth (feet)') \n xlabel('Distance from center (feet)') \n f = @(x) x .* ( p(1) * x.^2 + p(2) * x + p(3)); \n Vc = 2 * pi * quad(f, 0, 200); \n fprintf('(c) %.4f cubic feet\n', Vc); \n fprintf('(d) %.4f gallons\n', Vc * 7.48) \n ",
    "comment": "volume of the water in a circular pond"
 },
 {
    "code": "x = 0:50:400; \n y = [540, 390, 390, 430, 425, 360, 275, 125, 0]; \n fprintf('(a) Polynomial fit \n'); \n p = polyfit(x, y, 4) \n p_int = polyint(p); \n area = polyval(p_int, 400); \n fprintf('(b) Area = %.4f square feet (%.4f acres)\n', area,  area * 2.29568e-5); \n pd = polyder(p); \n s = quad(@(x) (1 + polyval(pd,x).^2).^0.5, 0, 400); \n fprintf('(c) Length of the stream = %.4f feet\n', s); \n ",
    "comment": "Modeling Data"
 },
 {
    "code": "x = 0:0.01:5; \n y = @(x) 10 * x .* (125 -x.^3).^0.5; \n fill(x, y(x), [0.95 0.9 0.9], 'linestyle', ':') \n A = quad(y, 0, 5); \n M_x = quad(@(x) 0.5 * (y(x)).^2, 0, 5); \n M_y = quad(@(x) x .* y(x), 0, 5); \n x_bar = M_y/A; \n y_bar = M_x/A; \n hold on \n plot(x_bar, y_bar, 'k*') \n hold off \n grid on \n xlim([-1 6]) \n ylim([-50 400]) \n fprintf('Centroid = (%.4f, %.4f)\n', x_bar, y_bar); \n ",
    "comment": "centroid"
 },
 {
    "code": "a = 90 * cos(pi/6); \n b = 90 * sin(pi/6); \n t_end = b/16; \n t = 0:0.01:t_end; \n x = a * t; \n y = b * t - 16 * t.^2; \n plot(x, y) \n title('(a)') \n grid on \n fprintf('(b) %.4f\n', a * t_end) \n f = @(x) (a^2 + (b - 32 * x).^2).^0.5; \n fprintf('(c) %.4f\n', quad(f, 0, t_end)) \n theta = [30:0.1:60]; \n d2r = pi/180; \n N = length(theta); \n L = zeros(N,1); \n for i=1:N, \n   ang = theta(i) * d2r; \n   a = 90 * cos(ang); \n   b = 90 * sin(ang); \n   te = b/16; \n   g = @(x) (a^2 + (b - 32 * x).^2).^0.5; \n   L(i) = quad(g, 0, te); \n end \n [max_L, max_i] = max(L); \n fprintf('Max trajectory length %.1f feet when theta = %.1f\n', max_L, theta(max_i))",
    "comment": " Path of a Projectile"
 },
 {
    "code": "function [p_vec,fp_vec] = bisect(f,a,b,Nmax) \n for i=1:Nmax \n     p=(a+b)/2; \n     f(p); \n     if f(p)*f(a)>0 \n         a=p; \n     else \n         b=p; \n     end \n     p_vec(i,1)=p; \n     fp_vec(i,1)=f(p); \n end",
    "comment": "function to find the root of f in interval [a,b] by bisection method"
 },
 {
    "code": "function [p_vec] = fpiter(g,p0,Nmax) \n for i=1:Nmax \n     p=g(p0); \n     p0=p; \n     p_vec(i,1)=p; \n end",
    "comment": "function to find the root of f by fixed- point iteration"
 },
 {
    "code": "function [p_vec] = newton(f,df,p0,Nmax,tol) \n for i=1:Nmax \n     p=p0-f(p0)/df(p0); \n     p_vec(i,1)=p; \n     if abs(p-p0)<tol \n         break; \n     else \n         p0=p; \n     end \n end",
    "comment": "function to find the root of f by Newton's method with df being f'"
 },
 {
    "code": "function x = backSub(A) \n n = size(A,1); \n for i = n:-1:1 \n     sum=0; \n     for j = n:-1:i+1 \n         sum = sum+x(j,1)*A(i,j); \n     end \n     x(i,1) = (A(i,n+1)-sum)/A(i,i); \n end",
    "comment": "backward substitution step of Gaussian elimination"
 },
 {
    "code": "A1 = [... \n      1    -1     2    -1    -8 \n      1     1     1     0    -2 \n      2    -2     3    -3   -20 \n      1    -1     4     3     4 \n     ]; \n B1 = forwElim(A1) \n x = backSub(B1)",
    "comment": "The code computes the echelon form and the solution in case the system of linear equations"
 },
 {
    "code": "clc \n  \n A2 = [... \n      0    -1     2    -1    -1 \n      1    -1     1     0    -8 \n      2    -2     3    -3   -20 \n      1    -1     4     3     4  \n     ]; \n B2 = forwElimPP(A2) \n x = backSub(B2)",
    "comment": "The code computes the echelon form with row interchanges by partial pivoting and the solution in case the system of linear equations"
 },
 {
    "code": "A3 = [... \n     26   -34    31   -48    25   -18    13   -32   -28    13     29 \n      0     0    25    42   -27    31   -14    23   -13   -48     67 \n     24    39   -38    15   -44    29     0   -13   -41    41   -152 \n    -39     2     3    43    27     0   -28    34    14     0    362 \n     18    20   -17   -34    17     1    15    23   -32    25    292 \n     -4   -35     5    42    22    14    10     7   -45    31    281 \n      0    45   -10    29    14    45   -11   -32    22   -12    421 \n    -40     4    -8     8    -8    -6   -36    46   -15    12    -65 \n     32    18   -32    -6   -11   -44     0     0     0     0   -337 \n    -32   -46   -24   -24    32    37    -8    42     0     3    124 \n    ]; \n  \n [B1,P] = forwElimPPperm(A3); \n P % permutation matrix \n A = P*A3; \n B = forwElim(A) % resulting echelon form",
    "comment": " The code computes the permutation matrix P of A3 and the resulting echelon form B by applying forwElim.m to A (= P*A3)"
 },
 {
    "code": "A = [23 42 37 15 52]; \n M = min(A)",
    "comment": "Create a vector and compute its smallest element."
 },
 {
    "code": "A = [-2+2i 4+i -1-3i]; \n min(A)",
    "comment": "Create a complex vector and compute its smallest element, that is, the element with the smallest magnitude."
 },
 {
    "code": "A = [2 8 4; 7 3 9] \n M = min(A)",
    "comment": "Create a matrix and compute the smallest element in each column."
 },
 {
    "code": "A = [1.7 1.2 1.5; 1.3 1.6 1.99] \n M = min(A,[],2)",
    "comment": "Create a matrix and compute the smallest element in each row."
 },
 {
    "code": "A(:,:,1) = [2 4; -2 1]; \n A(:,:,2) = [9 13; -5 7]; \n A(:,:,3) = [4 4; 8 -3]; \n M1 = min(A,[],[1 2]) \n M2 = min(A,[],[1 2 3]) \n Mall = min(A,[],\"all\")",
    "comment": "Create a 3-D array and compute the minimum over each page of data (rows and columns)."
 },
 {
    "code": "A = [1.77 -0.005 3.98 -2.95; NaN 0.34 NaN 0.19] \n  M = min(A,[],'includemissing')",
    "comment": "Create a matrix containing NaN values."
 },
 {
    "code": "A = [1 9 -2; 8 4 -5] \n  [M,I] = min(A)",
    "comment": "Create a matrix A and compute the smallest elements in each column as well as the row indices of A in which they appear."
 },
 {
    "code": "A = [1 2 3; 4 5 6] [M,I] = min(A,[],2,\"linear\") \n  minvals = A(I)",
    "comment": "Create a matrix A and return the minimum value of each row in the matrix M. Use the \"linear\" option to also return the linear indices I such that M = A(I)."
 },
 {
    "code": "A = [1 7 3; 6 2 9] \n  B = 5; \n C = min(A,B)",
    "comment": "Create a matrix and return the smallest value between each of its elements compared to a scalar."
 },
 {
    "code": "A = 1:10; \n B = mink(A,3)",
    "comment": "Compute the smallest 3 elements of a vector."
 },
 {
    "code": "A = magic(5) \n  B = mink(A,3,2)",
    "comment": "Compute the smallest 3 elements of each row of a matrix."
 },
 {
    "code": "A = [2-2i 5+i -7-3i -1+i] \n  [B,I] = mink(A,2,'ComparisonMethod','abs')",
    "comment": "Compute the 2 smallest elements of a complex vector according to their magnitude, and return the indices where they are located in the input vector."
 },
 {
    "code": "A = [23 42 37 18 52]; \n M = max(A)",
    "comment": "Create a vector and compute its largest element."
 },
 {
    "code": "A = [-2+2i 4+i -1-3i]; \n max(A)",
    "comment": "Create a complex vector and compute its largest element, that is, the element with the largest magnitude."
 },
 {
    "code": "A = [2 8 4; 7 3 9] \n  M = max(A)",
    "comment": "Create a matrix and compute the largest element in each column."
 },
 {
    "code": "A = [1.7 1.2 1.5; 1.3 1.6 1.99] \n  M = max(A,[],2)",
    "comment": "Create a matrix and compute the largest element in each row."
 },
 {
    "code": "A(:,:,1) = [2 4; -2 1]; \n A(:,:,2) = [9 13; -5 7]; \n A(:,:,3) = [4 4; 8 -3]; \n M1 = max(A,[],[1 2]) \n M2 = max(A,[],[1 2 3]) \n Mall = max(A,[],\"all\")",
    "comment": "Create a 3-D array and compute the maximum over each page of data (rows and columns)."
 },
 {
    "code": "A = [1.77 -0.005 NaN -2.95; NaN 0.34 NaN 0.19] \n  M = max(A,[],\"includemissing\")",
    "comment": "Create a matrix containing NaN values."
 },
 {
    "code": "A = [1 9 -2; 8 4 -5] \n  [M,I] = max(A)",
    "comment": "Create a matrix A and compute the largest elements in each column, as well as the row indices of A in which they appear."
 },
 {
    "code": "A = [1 2 3; 4 5 6] \n  [M,I] = max(A,[],2,\"linear\") \n  maxvals = A(I)",
    "comment": "Create a matrix A and return the maximum value of each row in the matrix M. Use the \"linear\" option to also return the linear indices I such that M = A(I)."
 },
 {
    "code": "A = [1 7 3; 6 2 9] \n  B = 5; \n C = max(A,B)",
    "comment": "Create a matrix and return the largest value between each of its elements compared to a scalar."
 },
 {
    "code": "A = 1:10; \n B = maxk(A,3)",
    "comment": "Compute the largest 3 elements of a vector."
 },
 {
    "code": "A = magic(5) \n  B = maxk(A,3,2)",
    "comment": "Compute the largest 3 elements of each row of a matrix."
 },
 {
    "code": "A = [2-2i 5+i -7-3i -1+i] \n  [B,I] = maxk(A,2,'ComparisonMethod','abs')",
    "comment": "Compute the 2 largest elements of a complex vector according to their magnitude, and return the indices where they are located in the input vector."
 },
 {
    "code": "A = [2 4 -1 10 6 3 0 -16]; \n [minA,maxA] = bounds(A)",
    "comment": "Simultaneously compute the minimum and maximum values of a vector."
 },
 {
    "code": "A = magic(4) \n  [minA,maxA] = bounds(A,2)",
    "comment": "Compute the minimum and maximum values in each row of a matrix."
 },
 {
    "code": "A(:,:,1) = [2 4; -2 1]; \n A(:,:,2) = [9 13; -5 7]; \n A(:,:,3) = [4 4; 8 -3]; \n [minA1,maxA1] = bounds(A,[1 2]); \n minA1 \n maxA1 \n [minA2,maxA2] = bounds(A,[1 2 3]) \n [minAall,maxAall] = bounds(A,\"all\")",
    "comment": "Create a 3-D array and compute the minimum and maximum values in each page of data (rows and columns)."
 },
 {
    "code": "A = [2 NaN 6 -5; 0 3 NaN 9] \n  [minA,maxA] = bounds(A,\"includenan\")",
    "comment": "Create a matrix containing NaN values."
 },
 {
    "code": "rng default \n X = randi(10,20,5);",
    "comment": "Create a 20-by-5 matrix of random integers between 1 and 10."
 },
 {
    "code": "rng default \n X = randi(10,20,5); \n TA = topkrows(X,4) \n TB = topkrows(X,5,3) \n TC = topkrows(X,5,[3 4])",
    "comment": "Sort the rows of a matrix using different sorting orders and view the top rows."
 },
 {
    "code": "rng default \n X = randi(10,100,5);",
    "comment": "Create a 100-by-5 matrix of random integers between 1 and 10."
 },
 {
    "code": "valRange = [-10 10]; \n X = randi(valRange,100,2) + 1i*randi(valRange,100,2); \n TA = topkrows(X,10) \n TB = topkrows(X,10,'ComparisonMethod','real')",
    "comment": "Sort a matrix of complex numbers by absolute value and then by real part."
 },
 {
    "code": "A = [0 1 1; 2 3 2; 1 3 2; 4 2 2] \n  M = mean(A)",
    "comment": "Create a matrix and compute the mean of each column."
 },
 {
    "code": "A = [0 1 1; 2 3 2; 3 0 1; 1 2 3] \n  M = mean(A,2)",
    "comment": "Create a matrix and compute the mean of each row."
 },
 {
    "code": "A = [0 1 1; 2 3 2; 3 0 1; 1 2 3]",
    "comment": "Declaration of Matrix A with 4 rows and 3 columns"
 },
 {
    "code": "rng('default') \n A = randi(10,[4,2,3]); \n M = mean(A,2) \n ",
    "comment": "Create a 4-by-2-by-3 array of integers between 1 and 10 and compute the mean values along the second dimension."
 },
 {
    "code": "A(:,:,1) = [2 4; -2 1]; \n A(:,:,2) = [9 13; -5 7]; \n A(:,:,3) = [4 4; 8 -3]; \n M1 = mean(A,[1 2]) \n M2 = mean(A,[1 2 3]) \n Mall = mean(A,\"all\")",
    "comment": "Create a 3-D array and compute the mean over each page of data (rows and columns)."
 },
 {
    "code": "A = single(ones(10,1)); \n M = mean(A,\"native\") \n class(M)",
    "comment": "Create a single-precision vector of ones and compute its single-precision mean."
 },
 {
    "code": "A = [1.77 -0.005 NaN -2.95; NaN 0.34 NaN 0.19]",
    "comment": "Create a matrix containing NaN values."
 },
 {
    "code": "A = [0 1 1; 2 3 2; 1 3 2; 4 2 2]",
    "comment": "Define a 4-by-3 matrix."
 },
 {
    "code": "M = median(A)",
    "comment": "Find the median value of each column."
 },
 {
    "code": "A = [0 1 1; 2 3 2]",
    "comment": "Define a 2-by-3 matrix."
 },
 {
    "code": "M = median(A,2)",
    "comment": "Find the median value of each row."
 },
 {
    "code": "rng('default') \n A = randi(10,[1,3,4])",
    "comment": "Create a 1-by-3-by-4 array of integers between 1 and 10."
 },
 {
    "code": "M = mode(A)",
    "comment": "Find the most frequent value of each column from matrix A."
 },
 {
    "code": "M = mode(A,2)",
    "comment": "Find the most frequent value of each row."
 },
 {
    "code": "M = mode(A)",
    "comment": "Find the most frequent values of this 3-D array along the second dimension."
 },
 {
    "code": "M = mode(A,1); \n isequal(A,M)",
    "comment": "Compute the mode along the first dimension of A"
 },
 {
    "code": "M = mode(A,1); \n isequal(A,M)",
    "comment": "This returns the same array as A because the size of the first dimension is 1."
 },
 {
    "code": "A = [4 -5 1; 2 3 5; -9 1 7]; \n S = std(A)",
    "comment": "Create a matrix and compute the standard deviation of each column."
 },
 {
    "code": "A(:,:,1) = [2 4; -2 1]; \n A(:,:,2) = [9 13; -5 7]; \n A(:,:,3) = [4 4; 8 -3]; \n S = std(A)",
    "comment": "Create a 3-D array and compute the standard deviation along the first dimension."
 },
 {
    "code": "A = [1 5; 3 7; -9 2]; \n w = [1 1 0.5]; \n S = std(A,w)",
    "comment": "Create a matrix and compute the standard deviation of each column according to a weight vector w."
 },
 {
    "code": "A = [6 4 23 -3; 9 -10 4 11; 2 8 -5 1]; \n S = std(A,0,2)",
    "comment": "Create a matrix and compute the standard deviation along each row."
 },
 {
    "code": "A(:,:,1) = [2 4; -2 1]; \n A(:,:,2) = [9 13; -5 7]; \n A(:,:,3) = [4 4; 8 -3]; \n S = std(A,0,[1 2])",
    "comment": "Create a 3-D array and compute the standard deviation over each page of data (rows and columns)."
 },
 {
    "code": "A = [1.77 -0.005 NaN -2.95; NaN 0.34 NaN 0.19]",
    "comment": "Create a matrix containing NaN values."
 },
 {
    "code": "A = [4 -5 1; 2 3 5; -9 1 7]; \n [S,M] = std(A)",
    "comment": "Create a matrix and compute the standard deviation and mean of each column."
 },
 {
    "code": "A = [4 -7 3; 1 4 -2; 10 7 9]; \n var(A)",
    "comment": "Create a matrix and compute its variance."
 },
 {
    "code": "A(:,:,1) = [1 3; 8 4]; \n A(:,:,2) = [3 -4; 1 2]; \n var(A)",
    "comment": "Create a 3-D array and compute its variance"
 },
 {
    "code": "A = [5 -4 6; 2 3 9; -1 1 2]; \n w = [0.5 0.25 0.25]; \n var(A,w)",
    "comment": "Create a matrix and compute its variance according to a weight vector w."
 },
 {
    "code": "A(:,:,1) = [2 4; -2 1]; \n A(:,:,2) = [9 13; -5 7]; \n A(:,:,3) = [4 4; 8 -3]; \n V = var(A,0,[1 2])",
    "comment": "Create a 3-D array and compute the variance over each page of data (rows and columns)."
 },
 {
    "code": "t = 0:0.001:1-0.001; \n x = cos(2*pi*100*t); \n y = rms(x)",
    "comment": "Compute the root mean squrae / RMS value of a sinusoid."
 },
 {
    "code": "x = [4 -5 1; 2 3 5; -9 1 7]; \n y = rms(x)",
    "comment": "Create a matrix and compute the root mean squrae / RMS value of each column."
 },
 {
    "code": "x = [6 4 23 -3; 9 -10 4 11; 2 8 -5 1]; \n y = rms(x,2)",
    "comment": "Create a matrix and compute the RMS value of each row by specifying the dimension as 2."
 },
 {
    "code": "x(:,:,1) = [2 4; -2 1]; \n x(:,:,2) = [9 13; -5 7]; \n x(:,:,3) = [4 4; 8 -3]; \n y = rms(x,[1 2])",
    "comment": "Create a 3-D array and compute the RMS value over each page of data (rows and columns)."
 },
 {
    "code": "rng default % for reproducibility \n A = randn(1,7) \n P = prctile(A,42)",
    "comment": "Generate a data set of size 7 and Calculate the percentile of a data set for a given percentage."
 },
 {
    "code": "rng default % for reproducibility \n A = randn(3,5,2) \n P = prctile(A,[40 60],\"all\")",
    "comment": "Create a 3-by-5-by-2 array. and Find the percentiles of all the values in an array."
 },
 {
    "code": "P = prctile(A,[25 50 75],1) \n  P = prctile(A,[25 50 75],2)",
    "comment": "Calculate the percentiles along the columns and rows of a data matrix for specified percentages"
 },
 {
    "code": "Ppage = prctile(A,[40 60],[1 2])",
    "comment": "Find the percentiles of a multidimensional array along multiple dimensions."
 },
 {
    "code": "Q = quantile(A,0.3) \n  Q = quantile(A,[0.025 0.25 0.5 0.75 0.975])",
    "comment": "Calculate the quantiles of a data set for specified probabilities."
 },
 {
    "code": "Q = quantile(A,4)",
    "comment": "Calculate the quantiles of a data set for a given number of probabilities"
 },
 {
    "code": "Q = quantile(A,4)",
    "comment": "Calculate four evenly spaced quantiles of the elements of A."
 },
 {
    "code": "Q = quantile(A,0.3,1)",
    "comment": "Calculate the 0.3 quantile for each column of A."
 },
 {
    "code": "Q = quantile(A,3,1)",
    "comment": "Calculate the quantiles for each column of A for three evenly spaced cumulative probabilities."
 },
 {
    "code": "p = [0.25 0.75]; \n  Qall = quantile(A,p,\"all\")",
    "comment": "Calculate the 0.25 and 0.75 quantiles of all the elements of A."
 },
 {
    "code": "Q = quantile(A,0.5)",
    "comment": "Calculate the median of the elements of A."
 },
 {
    "code": "Q = quantile(A,[0.25, 0.5, 0.75])",
    "comment": "Calculate the quartiles of the elements of A."
 },
 {
    "code": "r = iqr(A)",
    "comment": "Compute the interquartile range for each column of data."
 },
 {
    "code": "rall = iqr(A,\"all\")",
    "comment": "Compute the interquartile range of all the values in A"
 },
 {
    "code": "A = [5 0 3 7; 1 -5 7 3; 4 9 8 10]; \n C = cov(A)",
    "comment": "Create a 3-by-4 matrix and compute its covariance."
 },
 {
    "code": "A = [3 6 4]; \n B = [7 12 -9]; \n cov(A,B)",
    "comment": "Create two vectors and compute their 2-by-2 covariance matrix."
 },
 {
    "code": "A = [2 0 -9; 3 4 1]; \n B = [5 2 6; -4 4 9]; \n cov(A,B)",
    "comment": "Create two matrices of the same size and compute their 2-by-2 covariance."
 },
 {
    "code": "A = randn(10,1); \n B = randn(10,1); \n R = corrcoef(A,B)",
    "comment": "Compute the correlation coefficient matrix between two normally distributed, random vectors of 10 observations each"
 },
 {
    "code": "rng default \n x = rand(20,1); \n [c,lags] = xcov(x); \n stem(lags,c)",
    "comment": "Create a 20-by-1 random vector, then compute and plot the estimated autocovariance. The largest spike occurs at zero lag, where the vector is exactly equal to itself."
 },
 {
    "code": "rng default \n x = randn(1000,1); \n maxlag = 10; \n [c,lags] = xcov(x,maxlag,'normalized'); \n stem(lags,c)",
    "comment": "Compute and plot the estimated autocovariance of white Gaussian noise, c(m), for 10m10. Normalize the sequence so that it is unity at zero lag."
 },
 {
    "code": "rng default \n shft = 50; \n s1 = rand(150,1); \n s2 = circshift(s1,[shft 0]); \n x = [s1 s2];",
    "comment": "Create a signal made up of two signals that are circularly shifted from each other by 50 samples."
 },
 {
    "code": "n = 0:15; \n x = 0.84.^n; \n y = circshift(x,5); \n [c,lags] = xcorr(x,y); \n stem(lags,c)",
    "comment": "Create a vector x and a vector y that is equal to x shifted by 5 elements to the right. Compute and plot the estimated cross-correlation of x and y. The largest spike occurs at the lag value when the elements of x and y match exactly (-5)."
 },
 {
    "code": "n = 0:15; \n x = 0.84.^n; \n [c,lags] = xcorr(x); \n stem(lags,c)",
    "comment": "Compute and plot the estimated autocorrelation of a vector x. The largest spike occurs at zero lag, when x matches itself exactly."
 },
 {
    "code": "n = 0:15; \n x = 0.84.^n; \n y = circshift(x,5); \n [c,lags] = xcorr(x,y,10,'normalized'); \n stem(lags,c)",
    "comment": "Compute and plot the normalized cross-correlation of vectors x and y with unity peak, and specify a maximum lag of 10."
 },
 {
    "code": "v = randi(10,1,10) \n  M = cummax(v)",
    "comment": "Find the cumulative maxima of a 1-by-10 vector of random integers."
 },
 {
    "code": "A = [3 5 2; 1 6 3; 7 8 1] \n  M = cummax(A)",
    "comment": "Find the cumulative maxima of the columns of a 3-by-3 matrix."
 },
 {
    "code": "A = cat(3,[1 2; 3 4],[9 10; 11 12],[5 6; 7 8])A = cat(3,[1 2; 3 4],[9 10; 11 12],[5 6; 7 8])",
    "comment": "Calculate the cumulative maxima in the third dimension of a 2-by-2-by-3 array. Specify direction as \"reverse\" to work from the end of the third dimension to the beginning."
 },
 {
    "code": "v = randi([0,10],1,10) \n  M = cummin(v)",
    "comment": "Find the cumulative minima of a 1-by-10 vector of random integers."
 },
 {
    "code": "A = [3 5 2; 1 6 3; 7 8 1] \n  M = cummin(A)",
    "comment": "Find the cumulative minima of the columns of a 3-by-3 matrix."
 },
 {
    "code": "A = [4 8 6 -1 -2 -3 -1 3 4 5]; \n M = movmin(A,3)",
    "comment": "Compute the three-point centered moving minimum of a row vector. When there are fewer than three elements in the window at the endpoints, take the minimum over the elements that are available."
 },
 {
    "code": "A = [4 8 6 -1 -2 -3 -1 3 4 5]; \n M = movmin(A,[2 0])",
    "comment": "Compute the three-point trailing moving minimum of a row vector. When there are fewer than three elements in the window at the endpoints, take the minimum over the elements that are available."
 },
 {
    "code": "A = [4 8 6 -1 -2 -3 -1 3 4 5]; \n M = movmax(A,3)",
    "comment": "Compute the three-point centered moving maximum of a row vector. When there are fewer than three elements in the window at the endpoints, take the maximum over the elements that are available."
 },
 {
    "code": "A = [4 8 6 -1 -2 -3 -1 3 4 5]; \n M = movmax(A,[2 0])",
    "comment": "Compute the three-point trailing moving maximum of a row vector. When there are fewer than three elements in the window at the endpoints, movmax takes the maximum over the number of elements that are available."
 },
 {
    "code": "A = [4 8 6 -1 -2 -3 -1 3 4 5]; \n M = movmean(A,3)",
    "comment": "Compute the three-point centered moving average of a row vector. When there are fewer than three elements in the window at the endpoints, take the average over the elements that are available."
 },
 {
    "code": "vpa(catalan)",
    "comment": "Find a floating-point approximation of the Catalan constant with the default number of digits and with the 10-digit precision."
 },
 {
    "code": "old = digits(10); \n vpa(catalan)",
    "comment": "Set the number of digits to 10 and approximate the Catalan constant:"
 },
 {
    "code": "eulergamma",
    "comment": "Represent the Euler-Mascheroni constant using eulergamma, which returns the symbolic form eulergamma."
 },
 {
    "code": "a = eulergamma; \n g = a^2 + log(a) \n gVpa = vpa(g)",
    "comment": "Use eulergamma in symbolic calculations. Numerically approximate your result with vpa."
 },
 {
    "code": "-psi(sym(1))",
    "comment": "Show that =(1)."
 },
 {
    "code": "syms x \n -subs(diff(gamma(x)),x,1)",
    "comment": "Show that =(x)x=1"
 },
 {
    "code": "syms x \n M = x*hilb(2); \n log(M)",
    "comment": "Compute the natural logarithm of each entry of this symbolic matrix:"
 },
 {
    "code": "syms x \n diff(log(x^3), x)",
    "comment": "Differentiate this symbolic expression"
 },
 {
    "code": "log10(20)",
    "comment": "Compute the log base 10 of numeric input."
 },
 {
    "code": "syms x \n f = x^2; \n fLog10 = log10(f)",
    "comment": "Compute the log base 10 of symbolic input. The result is in terms of log."
 },
 {
    "code": "fLog10 = subs(fLog10,x,5);        % x is 5 \n fLog10 = double(fLog10)",
    "comment": "Convert symbolic output to double by substituting for x with a number using subs, and then using double"
 },
 {
    "code": "y = log2(4^(1/3))",
    "comment": "Compute the base-2 logarithm of a numeric input."
 },
 {
    "code": "syms x \n ySym = log2(x^(1/3))",
    "comment": "Compute the base-2 logarithm of a symbolic input. The result is in terms of the natural logarithm log function."
 },
 {
    "code": "A = dilog([-1, 0, 1/4, 1/2, 1, 2])",
    "comment": "Compute the dilogarithm function for these numbers. Because these numbers are not symbolic objects, dilog returns floating-point results."
 },
 {
    "code": "syms x \n fplot(dilog(x),[0 10]) \n grid on",
    "comment": "Plot the dilogarithm function on the interval from 0 to 10."
 },
 {
    "code": "syms x \n diff(dilog(x), x) \n diff(dilog(x), x, x)",
    "comment": "Find the first and second derivatives of the dilogarithm function:"
 },
 {
    "code": "int(dilog(x), x)",
    "comment": "Find the indefinite integral of the dilogarithm function"
 },
 {
    "code": "limit(dilog(x)/x, Inf)",
    "comment": "Find the limit of this expression involving dilog:"
 },
 {
    "code": "Z = hurwitzZeta(0,1",
    "comment": "Evaluate the Hurwitz zeta function with numeric input arguments."
 },
 {
    "code": "symZ = hurwitzZeta(sym([0 2]),1)",
    "comment": "Compute the symbolic output of hurwitzZeta by converting the inputs to symbolic numbers using sym."
 },
 {
    "code": "A = sin([-2, -pi, pi/6, 5*pi/7, 11])",
    "comment": "Compute the sine function for these numbers. Because these numbers are not symbolic objects, sin returns floating-point results."
 },
 {
    "code": "syms x \n fplot(sin(x),[-4*pi 4*pi]) \n grid on",
    "comment": "Plot the sine function on the interval from 4 to 4."
 },
 {
    "code": "syms x \n diff(sin(x), x) \n diff(sin(x), x, x)",
    "comment": "Find the first and second derivatives of the sine function:"
 },
 {
    "code": "int(sin(x), x)",
    "comment": "Find the indefinite integral of the sine function:"
 },
 {
    "code": "taylor(sin(x), x)",
    "comment": "Find the Taylor series expansion of sin(x):"
 },
 {
    "code": "rewrite(sin(x), 'exp')",
    "comment": "Rewrite the sine function in terms of the exponential function:"
 },
 {
    "code": "u = symunit; \n syms x \n f = [x*u.degree 2*u.radian]; \n sinf = sin(f)",
    "comment": "Show this behavior by finding the sine of x degrees and 2 radians."
 },
 {
    "code": "syms x \n sinc(x)",
    "comment": "Create a sinc function of a symbolic variable x."
 },
 {
    "code": "V = sym([-1 0 1 3/2]); \n S = sinc(V)",
    "comment": "Show that sinc returns 1 at 0, 0 at other integer inputs, and exact symbolic values for other inputs."
 },
 {
    "code": "vpa(S)",
    "comment": "Convert the exact symbolic output to high-precision floating point by using vpa."
 },
 {
    "code": "syms x \n fourier(rectangularPulse(x))",
    "comment": "Show that fourier transforms a pulse in terms of sin and cos."
 },
 {
    "code": "syms x \n fplot(sinc(x))",
    "comment": "Plot the sinc function by using fplot."
 },
 {
    "code": "syms x \n rewrite(sinc(x),'exp')",
    "comment": "Rewrite the sinc function to the exponential function exp by using rewrite."
 },
 {
    "code": "syms x \n diff(sinc(x))",
    "comment": "Differentiate sinc."
 },
 {
    "code": "int(sinc(x),[-Inf Inf])",
    "comment": "Integrate sinc from -Inf to Inf."
 },
 {
    "code": "int(sinc(x),-Inf,x)",
    "comment": "Integrate sinc from -Inf to x."
 },
 {
    "code": "taylor(sinc(x))",
    "comment": "Find the Taylor expansion of sinc."
 },
 {
    "code": "A = cos([-2, -pi, pi/6, 5*pi/7, 11])",
    "comment": "Compute the cosine function for these numbers. Because these numbers are not symbolic objects, cos returns floating-point results."
 },
 {
    "code": "syms x \n fplot(cos(x),[-4*pi 4*pi]) \n grid on",
    "comment": "Plot the cosine function on the interval from 4 to 4."
 },
 {
    "code": "syms x \n diff(cos(x), x) \n diff(cos(x), x, x)",
    "comment": "Find the first and second derivatives of the cosine function:"
 },
 {
    "code": "int(cos(x), x)",
    "comment": "Find the indefinite integral of the cosine function:"
 },
 {
    "code": "taylor(cos(x), x)",
    "comment": "Find the Taylor series expansion of cos(x):"
 },
 {
    "code": "u = symunit; \n syms x \n f = [x*u.degree 2*u.radian]; \n cosinf = cos(f)",
    "comment": "Show this behavior by finding the cosine of x degrees and 2 radians."
 },
 {
    "code": "A = tan([-2, -pi, pi/6, 5*pi/7, 11])",
    "comment": "Compute the tangent function for these numbers. Because these numbers are not symbolic objects, tan returns floating-point results."
 },
 {
    "code": "syms x \n fplot(tan(x),[-pi pi]) \n grid on",
    "comment": "Plot the tangent function on the interval from  to ."
 },
 {
    "code": "syms x \n diff(tan(x), x) \n diff(tan(x), x, x)",
    "comment": "Find the first and second derivatives of the tangent function:"
 },
 {
    "code": "A = cot([-2, -pi/2, pi/6, 5*pi/7, 11])",
    "comment": "Compute the cotangent function for these numbers. Because these numbers are not symbolic objects, cot returns floating-point results."
 },
 {
    "code": "syms x \n fplot(cot(x),[-pi pi]) \n grid on",
    "comment": "Plot the cotangent function on the interval from  to ."
 },
 {
    "code": "syms x \n diff(cot(x), x) \n diff(cot(x), x, x)",
    "comment": "Find the first and second derivatives of the cotangent function:"
 },
 {
    "code": "syms x \n fplot(sec(x),[-4*pi 4*pi]) \n grid on",
    "comment": "Plot the secant function on the interval from 4 to 4."
 },
 {
    "code": "syms x \n diff(sec(x), x) \n diff(sec(x), x, x)",
    "comment": "Find the first and second derivatives of the secant function:"
 },
 {
    "code": "syms x \n fplot(csc(x),[-4*pi 4*pi]) \n grid on",
    "comment": "Plot the cosecant function on the interval from 4 to 4."
 },
 {
    "code": "syms x \n diff(csc(x), x) \n diff(csc(x), x, x)",
    "comment": "Find the first and second derivatives of the cosecant function:"
 },
 {
    "code": "A = asin([-1, -1/3, -1/2, 1/4, 1/2, sqrt(3)/2, 1])",
    "comment": "Compute the inverse sine function for these numbers. Because these numbers are not symbolic objects, asin returns floating-point results."
 },
 {
    "code": "syms x \n fplot(asin(x),[-1 1]) \n grid on",
    "comment": "Plot the inverse sine function on the interval from -1 to 1."
 },
 {
    "code": "syms x \n diff(asin(x), x) \n diff(asin(x), x, x)",
    "comment": "Find the first and second derivatives of the inverse sine function:"
 },
 {
    "code": "int(asin(x), x)",
    "comment": "Find the indefinite integral of the inverse sine function:"
 },
 {
    "code": "taylor(asin(x), x)",
    "comment": "Find the Taylor series expansion of asin(x):"
 },
 {
    "code": "[abs(sym(1/2)), abs(sym(0)), abs(sym(pi) - 4)]",
    "comment": "Compute Absolute Values of Symbolic Numbers"
 },
 {
    "code": "syms x \n simplify(abs(x)^2)",
    "comment": "Compute abs(x)^2 and simplify the result. Because symbolic variables are assumed to be complex by default, the result does not simplify to x^2."
 },
 {
    "code": "assume(x,'real') \n simplify(abs(x)^2)",
    "comment": "Assume x is real, and repeat the calculation. Now, the result is simplified to x^2."
 },
 {
    "code": "A = sym([1/2+i  -25; \n           i     pi/2]); \n abs(A)",
    "comment": "Compute the absolute values of each element of matrix A."
 },
 {
    "code": "syms x \n assume(x < 0) \n abs(5*x^3)",
    "comment": "Compute the absolute value of this expression assuming that the value of x is negative."
 },
 {
    "code": "[angle(1 + i), angle(4 + pi*i), angle(Inf + Inf*i)]",
    "comment": "Compute the polar angles of these complex numbers. Because these numbers are not symbolic objects, you get floating-point results."
 },
 {
    "code": "[angle(sym(1) + i), angle(sym(4) + sym(pi)*i), angle(Inf + sym(Inf)*i)]",
    "comment": "Compute the polar angles of these complex numbers which are converted to symbolic objects:"
 },
 {
    "code": "syms x \n limit(angle(x + x^2*i/(1 + x)), x, -Inf) \n limit(angle(x + x^2*i/(1 + x)), x, Inf)",
    "comment": "Compute the limits of these symbolic expressions:"
 },
 {
    "code": "Z = sym([sqrt(3) + 3*i, 3 + sqrt(3)*i; 1 + i, i]); \n angle(Z)",
    "comment": "Compute the polar angles of the elements of matrix Z:"
 },
 {
    "code": "P = atan2(Y,X)",
    "comment": "computes the four-quadrant inverse tangent (arctangent) of Y and X."
 },
 {
    "code": "P = [atan2(sym(1),1), atan2(sym(pi),sym(4)), atan2(Inf,sym(Inf))]",
    "comment": "Compute the arctangents of these parameters which are converted to symbolic objects."
 },
 {
    "code": "syms x \n P_minusinf = limit(atan2(x^2/(1 + x),x),x,-Inf)",
    "comment": "Compute the limits of this symbolic expression"
 },
 {
    "code": "Y = sym([3 sqrt(3); 1 1]); \n X = sym([sqrt(3) 3; 1 0]); \n P = atan2(Y,X)",
    "comment": "Compute the arctangents of the elements of matrices Y and X."
 },
 {
    "code": "conj(1+3i)",
    "comment": "Compute the conjugate of numeric input."
 },
 {
    "code": "syms x \n f = x^2; \n fConj = conj(f)",
    "comment": "Compute the conjugate of symbolic input."
 },
 {
    "code": "syms x \n assume(x,'real') \n conj(x)",
    "comment": "If the input is real, conj returns the input instead of an unresolved call. Assume x is real and find its conjugate. conj returns x instead of conj(x), as expected"
 },
 {
    "code": "imag(z)",
    "comment": "returns the imaginary part of z. If z is a matrix, imag acts elementwise on z."
 },
 {
    "code": "imag(2*exp(1 + sym(i)))",
    "comment": "Compute the imaginary part of this symbolic expression:"
 },
 {
    "code": "syms a x y \n imag(a + 2) \n imag(x + y*i)",
    "comment": "n general, imag cannot extract the entire imaginary parts from symbolic expressions containing variables. However, imag can rewrite and sometimes simplify the input expression:"
 },
 {
    "code": "syms a \n  a = 5 + 3*i; \n imag(a + 2)",
    "comment": "If you assign numeric values to these variables or if you specify that these variables are real, imag can extract the imaginary part of the expression:"
 },
 {
    "code": "syms x \n A = [-1 + sym(i), sinh(x); exp(10 + sym(7)*i), exp(sym(pi)*i)]; \n imag(A)",
    "comment": "Find the imaginary parts of the elements of matrix A:"
 },
 {
    "code": "x = sym(-27); \n n = -3; \n y = nthroot(x,n)",
    "comment": "Calculate the nth root of a negative number."
 },
 {
    "code": "x = sym(1 + 1i); \n y = nthroot(x,4)",
    "comment": "Calculate the nth root of a complex number."
 },
 {
    "code": "x = sym([-27,-8,-4 \n     27,64,-12])",
    "comment": "Calculate the nth roots of an array."
 },
 {
    "code": "[real(2 + 3/2*i), real(sin(5*i)), real(2*exp(1 + i))]",
    "comment": "Find the real parts of these numbers. Because these numbers are not symbolic objects, you get floating-point results."
 },
 {
    "code": "[real(sym(2) + 3/2*i), real(4/(sym(1) + 3*i)),  real(sin(sym(5)*i))]",
    "comment": "Compute the real parts of the numbers converted to symbolic objects:"
 },
 {
    "code": "real(2*exp(1 + sym(i)))",
    "comment": "Compute the real part of this symbolic expression:"
 },
 {
    "code": "syms x \n A = [-1 + sym(i), sinh(x); exp(10 + sym(7)*i), exp(sym(pi)*i)]; \n real(A)",
    "comment": "Find the real parts of the elements of matrix A:"
 },
 {
    "code": "A = sym([(1/2 + i), -25; i*(i + 1), pi/6 - i*pi/2]); \n sign(A)",
    "comment": "Find the signs of the real and complex elements of matrix A:"
 },
 {
    "code": "syms x \n assume(x < 0) \n sign(5*x^3)",
    "comment": "Find the sign of this expression assuming that the value x is negative:"
 },
 {
    "code": "beta(x,y)",
    "comment": "returns the beta function of x and y."
 },
 {
    "code": "[beta(sym(1), 5), beta(3, sym(2)), beta(sym(4), sym(4))]",
    "comment": "Compute the beta function for the numbers converted to symbolic objects:"
 },
 {
    "code": "[beta(sym(-3), 2), beta(sym(-1/3), 2), beta(sym(-3), 4),  beta(sym(-3), -2)]",
    "comment": "Compute the beta function for negative parameters. If one or both arguments are negative numbers, convert these numbers to symbolic objects:"
 },
 {
    "code": "A = sym([1 2; 3 4]); \n beta(A,1)",
    "comment": "Call beta for the matrix A and the value 1. The result is a matrix of the beta functions beta(A(i,j),1):"
 },
 {
    "code": "syms t \n u = diff(beta(t^2 + 1, t)) \n vpa(subs(u, t, 2/3), 10)",
    "comment": "Differentiate the beta function, then substitute the variable t with the value 2/3 and approximate the result using vpa:"
 },
 {
    "code": "syms x y \n expand(beta(x, y)) \n expand(beta(x + 1, y - 1))",
    "comment": "Expand these beta functions:"
 },
 {
    "code": "f = factorial(n)",
    "comment": "returns the factorial of n. If n is an array, factorial acts element-wise on n."
 },
 {
    "code": "f = factorial(sym(20))",
    "comment": "Compute the factorial for a symbolic number."
 },
 {
    "code": "syms n \n expr = n^2 + 1; \n f = factorial(expr)",
    "comment": "Compute the factorial function for a symbolic expression. factorial returns exact symbolic output as the function call."
 },
 {
    "code": "fVal = subs(f,n,3)",
    "comment": "Calculate the factorial for a value of n = 3. Substitute the value of n by using subs."
 },
 {
    "code": "syms n \n f = factorial(n^2 + n + 1)",
    "comment": "Differentiate an expression containing the factorial function (n^2+n+1)!"
 },
 {
    "code": "syms n \n f = factorial(n^2 + n + 1); \n f1 = expand(f)",
    "comment": "Expand an expression containing the factorial function."
 },
 {
    "code": "syms n \n f = factorial(n)/exp(n); \n fLim = limit(f,n,Inf)",
    "comment": "Compute the limit at infinity for an expression containing the factorial function."
 },
 {
    "code": "A = sym([1 3; 4 5]); \n f = factorial(A)",
    "comment": "Compute factorial for array input. factorial acts element-wise on array input."
 },
 {
    "code": "gamma(X)",
    "comment": "returns the gamma function of a symbolic variable or symbolic expression X."
 },
 {
    "code": "A = gamma([-11/3, -7/5, -1/2, 1/3, 1, 4])",
    "comment": "Compute the gamma function for these numbers. Because these numbers are not symbolic objects, you get floating-point results."
 },
 {
    "code": "vpa(symA)",
    "comment": "Use vpa to approximate symbolic results with floating-point numbers:"
 },
 {
    "code": "syms x \n fplot(gamma(x)) \n grid on",
    "comment": "Plot the gamma function and add grid lines."
 },
 {
    "code": "syms t \n u = diff(gamma(t^3 + 1)) \n u1 = subs(u, t, 1)",
    "comment": "Differentiate the gamma function, and then substitute the variable t with the value 1:"
 },
 {
    "code": "syms x \n limit(x/gamma(x), x, inf)",
    "comment": "Compute the limit of the following expression that involves the gamma function:"
 },
 {
    "code": "gammaln(X)",
    "comment": " returns the logarithmic gamma function for each element of X."
 },
 {
    "code": "A = gammaln([1/5, 1/2, 2/3, 8/7, 3])",
    "comment": "Compute the logarithmic gamma function for these numbers. Because these numbers are not symbolic objects, you get floating-point results."
 },
 {
    "code": "pos = gammaln(sym([1/4, 1/3, 1, 5, Inf]))",
    "comment": "Compute the logarithmic gamma function for positive integer arguments. For such arguments, the logarithmic gamma function is defined as the natural logarithm of the gamma function, gammaln(x) = log(gamma(x))."
 },
 {
    "code": "nonposint = gammaln(sym([0, -1, -2, -5, -10]))",
    "comment": "Compute the logarithmic gamma function for nonpositive integer arguments. For nonpositive integers, gammaln returns Inf."
 },
 {
    "code": "gammaln(sym(-Inf))",
    "comment": "Compute the logarithmic gamma function of negative infinity:"
 },
 {
    "code": "syms x \n fplot(gammaln(x),[0 10]) \n grid on",
    "comment": "Plot the logarithmic gamma function on the interval from 0 to 10."
 },
 {
    "code": "fplot(gammaln(x),[1 2]) \n grid on",
    "comment": "To see the negative values better, plot the same function on the interval from 1 to 2."
 },
 {
    "code": "syms x \n diff(gammaln(x), x)",
    "comment": "Differentiate the logarithmic gamma function:"
 },
 {
    "code": "syms x \n limit(1/gammaln(x), x, Inf) \n limit(gammaln(x - 1) - gammaln(x - 2), x, 0)",
    "comment": "Compute the limits of these expressions containing the logarithmic gamma function:"
 },
 {
    "code": "igamma(nu,z)",
    "comment": "returns the incomplete gamma function."
 },
 {
    "code": "A = [igamma(0, 1), igamma(3, sqrt(2)), igamma(pi, exp(1)), igamma(3, Inf)]",
    "comment": "Compute the incomplete gamma function for these numbers. Because these numbers are not symbolic objects, you get floating-point results."
 },
 {
    "code": "symA = [igamma(sym(0), 1), igamma(3, sqrt(sym(2))),... \n igamma(sym(pi), exp(sym(1))), igamma(3, sym(Inf))]",
    "comment": "Compute the incomplete gamma function for the numbers converted to symbolic objects:"
 },
 {
    "code": "A = [-5/3, -1/2, 0, 1/3]; \n gammainc(A, 1/3)",
    "comment": "Compute the lower incomplete gamma function for these arguments using the MATLAB gammainc function:"
 },
 {
    "code": "b = nchoosek(n,k)",
    "comment": "returns the binomial coefficient of n and k, defined as n!/(k!(n - k)!). This is the number of combinations of n items taken k at a time."
 },
 {
    "code": "C = nchoosek(v,k)",
    "comment": " returns a matrix containing all possible combinations of the elements of vector v taken k at a time. Matrix C has k columns and n!/(k!(n - k)!) rows, where n is length(v). In this syntax, k must be a nonnegative integer."
 },
 {
    "code": "syms n \n [nchoosek(n, n), nchoosek(n, n + 1), nchoosek(n, n - 1)]",
    "comment": "Compute the binomial coefficients for these expressions."
 },
 {
    "code": "syms n k \n diff(nchoosek(n, 2))",
    "comment": "Differentiate the binomial coefficient."
 },
 {
    "code": "m = 5; \n for n = 0:m \n     C = sym([]); \n   for k = 0:n \n     C = horzcat(C, nchoosek(n, k)); \n   end \n   disp(C) \n end",
    "comment": "Use nchoosek to build the Pascal triangle."
 },
 {
    "code": "C = nchoosek(v, 3)",
    "comment": "Find all combinations of the elements of v taken three at a time."
 },
 {
    "code": "pochhammer(x,n)",
    "comment": "returns the Pochhammer Symbol (x)n."
 },
 {
    "code": "pochhammer(3,2)",
    "comment": "Find the Pochhammer symbol for the numeric inputs x = 3 at n = 2."
 },
 {
    "code": "syms x \n P = pochhammer(x, 3) \n P = expand(P)",
    "comment": "Find the Pochhammer symbol for the symbolic input x at n = 3. The pochhammer function does not automatically return the expanded form of the expression. Use expand to force pochhammer to return the form of the expanded expression."
 },
 {
    "code": "syms n x \n assume(x>0) \n assume(n>0) \n P = pochhammer(x, n); \n P = expand(P)",
    "comment": "If conditions are satisfied, expand rewrites the solution using gamma."
 },
 {
    "code": "syms n x \n diff(pochhammer(x,n),x)",
    "comment": "Differentiate pochhammer once with respect to x."
 },
 {
    "code": "syms x \n fplot(pochhammer(x,0:4)) \n axis([-4 4 -4 4]) \n  \n grid on \n legend('n = 0','n = 1','n = 2','n = 3','n = 4','Location','Best') \n title('Pochhammer symbol (x)_n for n=0 to n=4')",
    "comment": "Plot the Pochhammer symbol from n = 0 to n = 4 for x. Use axis to display the region of interest."
 },
 {
    "code": "dawson(X)",
    "comment": "represents the Dawson integral."
 },
 {
    "code": "syms x \n fplot(dawson(x),[-10 10]) \n grid on",
    "comment": "Plot the Dawson integral on the interval from -10 to 10."
 },
 {
    "code": "syms x \n diff(dawson(x), x) \n diff(dawson(x), x, x)",
    "comment": "Find the first and second derivatives of the Dawson integral:"
 },
 {
    "code": "fresnelc(z)",
    "comment": "returns the Fresnel cosine integral of z."
 },
 {
    "code": "fresnelc([0 Inf -Inf i*Inf -i*Inf])",
    "comment": "Find the Fresnel cosine integral function for special values:"
 },
 {
    "code": "syms x \n V = [sin(x) 2i -7]; \n M = [0 2; i exp(x)]; \n fresnelc(V) \n fresnelc(M)",
    "comment": "Find the Fresnel cosine integral for elements of vector V and matrix M:"
 },
 {
    "code": "syms x \n fplot(fresnelc(x),[-5 5]) \n grid on",
    "comment": "Plot the Fresnel cosine integral function from x = -5 to x = 5."
 },
 {
    "code": "fresnels(z)",
    "comment": "returns the Fresnel sine integral of z."
 },
 {
    "code": "syms x \n f = symfun(exp(x)+2*x,x); \n fresnels(f)",
    "comment": "Find the Fresnel sine integral for the function exp(x) + 2*x:"
 },
 {
    "code": "syms x \n V = [sin(x) 2i -7]; \n M = [0 2; i exp(x)]; \n fresnels(V) \n fresnels(M)",
    "comment": "Find the Fresnel sine integral for elements of vector V and matrix M:"
 },
 {
    "code": "syms x \n fplot(fresnels(x),[-5 5]) \n grid on",
    "comment": "Plot the Fresnel sine integral function from x = -5 to x = 5."
 },
 {
    "code": "syms x \n diff(fresnels(x),x,4)",
    "comment": "Find the fourth derivative of the Fresnel sine integral function:"
 },
 {
    "code": "coshint(X)",
    "comment": "returns the hyperbolic cosine integral function of X."
 },
 {
    "code": "syms x \n fplot(coshint(x),[0 2*pi]) \n grid on",
    "comment": "Plot the hyperbolic cosine integral function on the interval from 0 to 2*pi."
 },
 {
    "code": "syms x \n diff(coshint(x), x) \n diff(coshint(x), x, x)",
    "comment": "Find the first and second derivatives of the hyperbolic cosine integral function:"
 },
 {
    "code": "cosint(X)",
    "comment": "returns the cosine integral function of X."
 },
 {
    "code": "syms x \n fplot(cosint(x),[0 4*pi]) \n grid on",
    "comment": "Plot the cosine integral function on the interval from 0 to 4*pi."
 },
 {
    "code": "A = logint(x)",
    "comment": "evaluates the logarithmic integral function (integral logarithm)."
 },
 {
    "code": "A = logint([-1, 0, 1/4, 1/2, 1, 2, 10])",
    "comment": "Compute integral logarithms for these numbers. Because these numbers are not symbolic objects, logint returns floating-point results."
 },
 {
    "code": "syms x \n fplot(logint(x),[0 10]) \n grid on",
    "comment": "Plot the integral logarithm function on the interval from 0 to 10"
 },
 {
    "code": "sinhint(X)",
    "comment": " returns the hyperbolic sine integral function of X."
 },
 {
    "code": "syms x \n fplot(sinhint(x),[-2*pi 2*pi]) \n grid on",
    "comment": "Plot the hyperbolic sine integral function on the interval from -2*pi to 2*pi."
 },
 {
    "code": "C = A + B",
    "comment": "adds arrays A and B by adding corresponding elements. If one input is a string array, then plus appends the corresponding elements as strings."
 },
 {
    "code": "C = plus(A,B)",
    "comment": "an alternate way to execute A + B, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [0 1; 1 0]; \n C = A + 2",
    "comment": "Create an array, A, and add a scalar value to it."
 },
 {
    "code": "s1 = [\"Red\" \"Blue\" \"Green\"] \n  s2 = [\"Truck\" \"Sky\" \"Tree\"] \n  s = s1 + s2",
    "comment": "Create two 1-by-3 string arrays, then append similarly located strings in the arrays."
 },
 {
    "code": "A = [1 0; 2 4]; \n B = [5 9; 2 1]; \n C = A + B",
    "comment": "Create two arrays, A and B, and add them together."
 },
 {
    "code": "a = 1:2; \n b = (1:3)'; \n a + b",
    "comment": "Create a 1-by-2 row vector and 3-by-1 column vector and add them."
 },
 {
    "code": "A = [1 2 3; 4 5 6] \n  b = [10; 100] \n  A + b",
    "comment": "Create an array, A, and add a column vector to it. The vector is treated as though it is a matrix of the same size as A, so that each element in the vector is added to a row in A."
 },
 {
    "code": "A = table([1;2],[3;4],VariableNames=[\"V1\",\"V2\"],RowNames=[\"R1\",\"R2\"]) \n  B = table([4;2],[3;1],VariableNames=[\"V2\",\"V1\"],RowNames=[\"R2\",\"R1\"]) \n  C = A + B \n  ",
    "comment": "Create two tables and add them. The row names (if present in both) and variable names must be the same, but do not need to be in the same orders. Rows and variables of the output are in the same orders as the first input."
 },
 {
    "code": "S = sum(A)",
    "comment": "returns the sum of the elements of A along the first array dimension whose size is greater than 1."
 },
 {
    "code": "S = sum(A,\"all\")",
    "comment": "returns the sum of all elements of A."
 },
 {
    "code": "S = sum(A,dim)",
    "comment": " returns the sum along dimension dim. For example, if A is a matrix, then sum(A,2) returns a column vector containing the sum of each row."
 },
 {
    "code": "S = sum(A,vecdim)",
    "comment": "sums the elements of A based on the dimensions specified in the vector vecdim. For example, if A is a matrix, then sum(A,[1 2]) returns the sum of all elements in A because every element of a matrix is contained in the array slice defined by dimensions 1 and 2."
 },
 {
    "code": "S = sum(___,outtype)",
    "comment": "returns the sum with the specified data type, using any of the input arguments in the previous syntaxes. outtype can be \"default\", \"double\", or \"native\"."
 },
 {
    "code": "S = sum(___,nanflag)",
    "comment": "specifies whether to include or omit NaN values in A. For example, sum(A,\"omitnan\") ignores NaN values when computing the sum. By default, sum includes NaN values"
 },
 {
    "code": "A = 1:10; \n S = sum(A)",
    "comment": "Create a vector and compute the sum of its elements."
 },
 {
    "code": "A = [1 3 2; 4 2 5; 6 1 4] \n  S = sum(A)",
    "comment": "Create a matrix and compute the sum of the elements in each column."
 },
 {
    "code": "A = [1 3 2; 4 2 5; 6 1 4] \n  S = sum(A,2)",
    "comment": "Create a matrix and compute the sum of the elements in each row."
 },
 {
    "code": "A = ones(4,3,2); \n  S1 = sum(A,[1 2]) \n  S2 = sum(A,[2 3]) \n  S3 = sum(A,[1 3]) \n  S4 = sum(A,[1 2 3]) \n  Sall = sum(A,\"all\")",
    "comment": "Use a vector dimension argument to operate on specific slices of an array."
 },
 {
    "code": "A = ones(4,2,3); \n S = sum(A,3)",
    "comment": "Create a 4-by-2-by-3 array of ones and compute the sum along the third dimension."
 },
 {
    "code": "A = int32(1:10); \n S = sum(A,\"native\")",
    "comment": "Create a vector of 32-bit integers and compute the int32 sum of its elements by specifying the output type as native."
 },
 {
    "code": "B = cumsum(A)",
    "comment": "returns the cumulative sum of A starting at the beginning of the first array dimension in A whose size is greater than 1."
 },
 {
    "code": "B = cumsum(A,dim)",
    "comment": "returns the cumulative sum of the elements along dimension dim. For example, if A is a matrix, then cumsum(A,2) returns the cumulative sum along the rows of A."
 },
 {
    "code": "B = cumsum(___,direction)",
    "comment": "specifies the direction for any of the previous syntaxes. For example, cumsum(A,2,\"reverse\") returns the cumulative sum within the rows of A by working from end to beginning of the second dimension."
 },
 {
    "code": "B = cumsum(___,nanflag)",
    "comment": "specifies whether to include or omit NaN values in A. For example, cumsum(A,\"omitnan\") ignores NaN values when computing each sum. By default, cumsum includes NaN values."
 },
 {
    "code": "A = 1:5; \n B = cumsum(A)",
    "comment": "Find the cumulative sum of the integers from 1 to 5. The element B(2) is the sum of A(1) and A(2), while B(5) is the sum of elements A(1) through A(5)."
 },
 {
    "code": "A = [1 4 7; 2 5 8; 3 6 9] \n  B = cumsum(A)",
    "comment": "Create a 3-by-3 matrix whose elements correspond to their linear indices."
 },
 {
    "code": "A = [1 3 5; 2 4 6] \n  B = cumsum(A,2)",
    "comment": "Define a 2-by-3 matrix whose elements correspond to their linear indices."
 },
 {
    "code": "A = [true false true; true true false]",
    "comment": "Create an array of logical values."
 },
 {
    "code": "B = cumsum(A,2)",
    "comment": "Find the cumulative sum of the rows of A."
 },
 {
    "code": "rng default; \n A = randi([1,10],3)",
    "comment": "Create a 3-by-3 matrix of random integers between 1 and 10."
 },
 {
    "code": "B = cumsum(A,2,\"reverse\")",
    "comment": "Calculate the cumulative sum along the rows. Specify the \"reverse\" option to work from right to left in each row. The result is the same size as A."
 },
 {
    "code": "C = A - B",
    "comment": " subtracts array B from array A by subtracting corresponding elements. The sizes of A and B must be the same or be compatible."
 },
 {
    "code": "C = minus(A,B)",
    "comment": "an alternate way to execute A - B, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [2 1; 3 5]; \n C = A - 2",
    "comment": "Create an array, A, and subtract a scalar value from it."
 },
 {
    "code": "A = [1 0; 2 4]; \n B = [5 9; 2 1]; \n C = A - B",
    "comment": "Create two arrays, A and B, and subtract the second, B, from the first, A."
 },
 {
    "code": "a = 1:2; \n b = (1:3)'; \n a - b",
    "comment": "Create a 1-by-2 row vector and 3-by-1 column vector and subtract them."
 },
 {
    "code": "A = [1 9 3; 2 7 8] \n  A - mean(A)",
    "comment": "Create a matrix, A. Scale the elements in each column by subtracting the mean."
 },
 {
    "code": "Y = diff(X)",
    "comment": "calculates differences between adjacent elements of X along the first array dimension whose size does not equal 1:"
 },
 {
    "code": "Y = diff(X,n)",
    "comment": " calculates the nth difference by applying the diff(X) operator recursively n times. In practice, this means diff(X,2) is the same as diff(diff(X))."
 },
 {
    "code": "Y = diff(X,n,dim)",
    "comment": " the nth difference calculated along the dimension specified by dim. The dim input is a positive integer scalar."
 },
 {
    "code": "X = [1 1 2 3 5 8 13 21]; \n Y = diff(X)",
    "comment": "Create a vector, then compute the differences between the elements."
 },
 {
    "code": "X = [1 1 1; 5 5 5; 25 25 25]; \n Y = diff(X)",
    "comment": "Create a 3-by-3 matrix, then compute the first difference between the rows."
 },
 {
    "code": "X = [0 5 15 30 50 75 105]; \n Y = diff(X,2)",
    "comment": "Create a vector and compute the second-order difference between the elements."
 },
 {
    "code": "X = [1 3 5;7 11 13;17 19 23]; \n Y = diff(X,1,2)",
    "comment": "Create a 3-by-3 matrix, then compute the first-order difference between the columns."
 },
 {
    "code": "h = 0.001; \n X = -pi:h:pi; \n f = sin(X); \n Y = diff(f)/h; \n Z = diff(Y)/h; \n plot(X(:,1:length(Y)),Y,'r',X,f,'b', X(:,1:length(Z)),Z,'k')",
    "comment": "Use the diff function to approximate partial derivatives with the syntax Y = diff(f)/h, where f is a vector of function values evaluated over some domain, X, and h is an appropriate step size."
 },
 {
    "code": "t1 = datetime('now'); \n t2 = t1 + minutes(5); \n t = t1:minutes(1.5):t2 \n dt = diff(t)",
    "comment": "Create a sequence of equally-spaced datetime values, and find the time differences between them."
 },
 {
    "code": "C = A.*B",
    "comment": "multiplies arrays A and B by multiplying corresponding elements. The sizes of A and B must be the same or be compatible."
 },
 {
    "code": "C = times(A,B)",
    "comment": "an alternate way to execute A.*B, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [1 0 3]; \n B = [2 3 7]; \n C = A.*B",
    "comment": "Create two vectors, A and B, and multiply them element by element."
 },
 {
    "code": "A = [1 0 3; 5 3 8; 2 4 6]; \n B = [2 3 7; 9 1 5; 8 8 3]; \n C = A.*B",
    "comment": "Create two 3-by-3 arrays, A and B, and multiply them element by element."
 },
 {
    "code": "a = 1:3; \n b = (1:4)'; \n a.*b",
    "comment": "Create a row vector a and a column vector b, then multiply them. The 1-by-3 row vector and 4-by-1 column vector combine to produce a 4-by-3 matrix."
 },
 {
    "code": "A = table([1;2],[3;4],VariableNames=[\"V1\",\"V2\"],RowNames=[\"R1\",\"R2\"]) \n  B = table([4;2],[3;1],VariableNames=[\"V2\",\"V1\"],RowNames=[\"R2\",\"R1\"]) \n  C = A .* B",
    "comment": "Create two tables and multiply them. The row names (if present in both) and variable names must be the same, but do not need to be in the same orders. Rows and variables of the output are in the same orders as the first input."
 },
 {
    "code": "C = A*B ",
    "comment": "matrix product of A and B. If A is an m-by-p and B is a p-by-n matrix, then C is an m-by-n matrix"
 },
 {
    "code": "C = mtimes(A,B)",
    "comment": "an alternative way to execute A*B, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [1 1 0 0]; \n B = [1; 2; 3; 4]; \n C = A*B",
    "comment": "Create a 1-by-4 row vector, A, and a 4-by-1 column vector, B. and multiply A times B"
 },
 {
    "code": "A = [1 1 0 0]; \n B = [1; 2; 3; 4]; \n C = B*A",
    "comment": "Create a 1-by-4 row vector, A, and a 4-by-1 column vector, B. and multiply B times A"
 },
 {
    "code": "A(2,:)*B(:,3)",
    "comment": "Calculate the inner product of the second row of A and the third column of B."
 },
 {
    "code": "B = prod(A)",
    "comment": "returns the product of the array elements of A."
 },
 {
    "code": "B = prod(A,\"all\") ",
    "comment": "returns the product of all elements of A."
 },
 {
    "code": "B = prod(A,dim)",
    "comment": "returns the product along dimension dim. For example, if A is a matrix, prod(A,2) is a column vector containing the products of each row."
 },
 {
    "code": "B = prod(A,vecdim)",
    "comment": "returns the product based on the dimensions specified in the vector vecdim."
 },
 {
    "code": "A=[1:3:7;2:3:8;3:3:9] \n  B = prod(A)",
    "comment": "Create a 3-by-3 array whose elements correspond to their linear indices."
 },
 {
    "code": "A = [true false; true true] ",
    "comment": "Create an array of logical values."
 },
 {
    "code": "B = prod(A)",
    "comment": "Find the product of the elements in each column."
 },
 {
    "code": "A=[1:3:7;2:3:8;3:3:9]",
    "comment": "Create a 3-by-3 array whose elements correspond to their linear indices."
 },
 {
    "code": "dim = 2; \n B = prod(A,dim)",
    "comment": "Find the product of the elements in each row and reduce the length of the second dimension to 1. The length of the first dimension matches size(A,1), and the length of the second dimension is 1."
 },
 {
    "code": "A(:,:,1) = [2 4; -2 1]; \n A(:,:,2) = [1 2; -5 3]; \n A(:,:,3) = [4 4; 1 -3]; \n B1 = prod(A,[1 2])",
    "comment": "Create a 3-D array and compute the product over each page of data (rows and columns)."
 },
 {
    "code": "B = cumprod(A)",
    "comment": "returns the cumulative product of A starting at the beginning of the first array dimension in A whose size is greater than 1."
 },
 {
    "code": "B = cumprod(A,dim)",
    "comment": "returns the cumulative product of the elements along dimension dim"
 },
 {
    "code": "B = cumprod(___,direction)",
    "comment": "specifies the direction for any of the previous syntaxes."
 },
 {
    "code": "A = 1:5; \n B = cumprod(A)",
    "comment": "Find the cumulative product of the integers from 1 to 5. The element B(2) is the product of A(1) and A(2), while B(5) is the product of elements A(1) through A(5)."
 },
 {
    "code": "A = [1 4 7; 2 5 8; 3 6 9]",
    "comment": "Create a 3-by-3 matrix whose elements correspond to their linear indices."
 },
 {
    "code": "B = cumprod(A)",
    "comment": "Find the cumulative product of the columns of A. The element B(5) is the product of A(4) and A(5), while B(9) is the product of A(7), A(8), and A(9)."
 },
 {
    "code": "A = [1 3 5; 2 4 6] \n  B = cumprod(A,2)",
    "comment": "Find the cumulative product of the rows of A. The element B(3) is the product of A(1) and A(3), while B(5) is the product of A(1), A(3), and A(5)."
 },
 {
    "code": "A = [true false true; true true false] \n  B = cumprod(A,2)",
    "comment": "Create an array of logical values. Find the cumulative product of the rows of A."
 },
 {
    "code": "x = A./B ",
    "comment": "divides each element of A by the corresponding element of B. The sizes of A and B must be the same or be compatible."
 },
 {
    "code": "x = rdivide(A,B)",
    "comment": "an alternative way to divide A by B, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [2 4 6 8; 3 5 7 9]; \n B = 10*ones(2,4); \n x = A./B",
    "comment": "Create two numeric arrays, A and B, and divide the second array, B, into the first, A."
 },
 {
    "code": "a = int16(10); \n b = int16([3 4 6]); \n x = a./b",
    "comment": "Divide an int16 scalar value by each element of an int16 vector."
 },
 {
    "code": "C = 5; \n D = magic(3); \n x = C./D",
    "comment": "Create an array and divide it into a scalar."
 },
 {
    "code": "a = 1:2; \n b = (1:3)'; \n a ./ b",
    "comment": "Create a 1-by-2 row vector and 3-by-1 column vector and divide them."
 },
 {
    "code": "x = B.\\ A",
    "comment": "divides each element of A by the corresponding element of B. The sizes of A and B must be the same or be compatible."
 },
 {
    "code": "x = ldivide(B,A)",
    "comment": "an alternative way to divide A by B, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = ones(2,3); \n B = [1 2 3; 4 5 6]; \n x = B.\\A",
    "comment": "Create two numeric arrays, A and B, and divide the second array, B, into the first, A."
 },
 {
    "code": "c = 2; \n D = [1 2 3; 4 5 6]; \n x = D.\\c",
    "comment": "Create a scalar, c, and divide it by a numeric array. The result is the same size as the array."
 },
 {
    "code": "a = 1:2; \n b = (1:3)'; \n b .\\ a",
    "comment": "Create a 1-by-2 row vector and 3-by-1 column vector and divide them."
 },
 {
    "code": "B = table([1;2],[3;4],VariableNames=[\"V1\",\"V2\"],RowNames=[\"R1\",\"R2\"]) \n  A = table([4;2],[3;1],VariableNames=[\"V2\",\"V1\"],RowNames=[\"R2\",\"R1\"]) \n  x = B .\\ A",
    "comment": "Create two tables and divide the second table into the first. The row names (if present in both) and variable names must be the same, but do not need to be in the same orders. Rows and variables of the output are in the same orders as the first input."
 },
 {
    "code": "x = B/A",
    "comment": "solves the system of linear equations x*A = B for x. The matrices A and B must contain the same number of columns."
 },
 {
    "code": "x = mrdivide(B,A)",
    "comment": "is an alternative way to execute x = B/A, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [1 1 3; 2 0 4; -1 6 -1]; \n B = [2 19 8]; \n x = B/A",
    "comment": "Solve a system of equations that has a unique solution, x*A = B."
 },
 {
    "code": "C = [1 0; 2 0; 1 0]; \n D = [1 2]; \n x = D/C \n x*C-D",
    "comment": "Solve an underdetermined system, x*C = D."
 },
 {
    "code": "x = A\\B",
    "comment": "solves the system of linear equations A*x = B. The matrices A and B must have the same number of rows. "
 },
 {
    "code": "x = mldivide(A,B)",
    "comment": "is an alternative way to execute x = A\\B, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = magic(3); \n B = [15; 15; 15]; \n x = A\\B",
    "comment": "Solve a simple system of linear equations, A*x = B."
 },
 {
    "code": "A = magic(4); \n b = [34; 34; 34; 34]; \n x = A\b",
    "comment": "Solve a linear system of equations A*x = b involving a singular matrix, A."
 },
 {
    "code": "A = [1 2 0; 0 4 3]; \n b = [8; 18]; \n x = A\b",
    "comment": "Solve a system of linear equations, A*x = b."
 },
 {
    "code": "X = pagemldivide(A,B) ",
    "comment": "it computes the left matrix divide of each page of N-D array A into each page of N-D array B. Each page of the output array X is given by X(:,:,i) = A(:,:,i) \\ B(:,:,i). The pages of A and B must be valid inputs to mldivide (\\)."
 },
 {
    "code": "X = pagemldivide(A,transpA,B)",
    "comment": "it optionally applies a transposition to each page of A. The value of transpA can be \"transpose\", \"ctranspose\", or \"none\". For example, pagemldivide(A,\"transpose\",B) computes X(:,:,i) = A(:,:,i).' \\ B(:,:,i)."
 },
 {
    "code": "p1 = magic(3); \n p2 = hilb(3); \n A = cat(3,p1,p2) \n B = ones(3,1,2) \n X = pagemldivide(A,B)",
    "comment": "Create a 3-by-3-by-2 array A that has 3-by-3 matrices on each of two pages. Also create a 3-by-1-by-2 array B."
 },
 {
    "code": "p1 = diag([ones(9,1);0]); \n p2 = pascal(10); \n A = cat(3,p1,p2) \n B = 3*ones(10,1,2)",
    "comment": "Create a 10-by-10-by-2 array A that has 10-by-10 matrices on each of two pages. Also create a 10-by-1-by-2 array B."
 },
 {
    "code": "C = A.^B",
    "comment": "raises each element of A to the corresponding powers in B. The sizes of A and B must be the same or be compatible."
 },
 {
    "code": "A = 1:5; \n C = A.^2",
    "comment": "Create a vector, A, and square each element."
 },
 {
    "code": "A = [1 2 3; 4 5 6; 7 8 9]; \n C = A.^-1",
    "comment": "Create a matrix, A, and take the inverse of each element."
 },
 {
    "code": "a = [2 3]; \n b = (1:3)'; \n a.^b",
    "comment": "Create a 1-by-2 row vector and a 3-by-1 column vector and raise the row vector to the power of the column vector."
 },
 {
    "code": "A = -1; \n B = 1/3; \n C = A.^B",
    "comment": "Calculate the roots of -1 to the 1/3 power."
 },
 {
    "code": "C = A^B",
    "comment": "computes A to the B power and returns the result in C."
 },
 {
    "code": "C = mpower(A,B)",
    "comment": "is an alternate way to execute A^B, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [1 2; 3 4]; \n C = A^2",
    "comment": "Create a 2-by-2 matrix and square it."
 },
 {
    "code": "B = [0 1; 1 0]; \n C = 2^B",
    "comment": "Create a 2-by-2 matrix and use it as the exponent for a scalar."
 },
 {
    "code": "[V,D] = eig(B)",
    "comment": "Compute C by first finding the eigenvalues D and eigenvectors V of the matrix B."
 },
 {
    "code": "C = V*2^D/V",
    "comment": "use the formula 2^B = V*2^D/V to compute the power."
 },
 {
    "code": "B = A.' ",
    "comment": "returns the nonconjugate transpose of A, that is, interchanges the row and column index for each element. If A contains complex elements, then A.' does not affect the sign of the imaginary parts. For example, if A(3,2) is 1+2i and B = A.', then the element B(2,3) is also 1+2i."
 },
 {
    "code": "B = transpose(A)",
    "comment": "is an alternate way to execute A.' and enables operator overloading for classes."
 },
 {
    "code": "A = magic(4) \n  B = A.'",
    "comment": "Create a matrix of real numbers and compute its transpose. B has the same elements as A, but the rows of B are the columns of A and the columns of B are the rows of A."
 },
 {
    "code": "B = A'",
    "comment": "computes the complex conjugate transpose of A."
 },
 {
    "code": "B = ctranspose(A)",
    "comment": "is an alternate way to execute A', but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "B = A'",
    "comment": "Find the conjugate transpose of A."
 },
 {
    "code": "r = repelem(1:3,3,1); \n A = cat(3,r,2*r,3*r) \n B = pagetranspose(A)",
    "comment": "Create a 3-D array A, and then use pagetranspose to transpose each page of the array."
 },
 {
    "code": "Y = pagetranspose(X)",
    "comment": "it applies the nonconjugate transpose to each page of N-D array X. Each page of the output Y(:,:,i) is found by transposing the corresponding page in X, as in X(:,:,i).'."
 },
 {
    "code": "C = -A",
    "comment": "negates the elements of A and stores the result in C."
 },
 {
    "code": "C = uminus(A)",
    "comment": "is an alternative way to execute -A, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [1 -3; -2 4] \n  C = -A",
    "comment": "Create a 2-by-2 matrix, A and Negate the elements of A."
 },
 {
    "code": "C = +A ",
    "comment": "returns array A and stores it in C."
 },
 {
    "code": "C = uplus(A)",
    "comment": "is an alternate way to execute +A, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [1 -3; -2 4] \n  C = +A",
    "comment": "Create a 2-by-2 matrix, A and compute unary plus on A."
 },
 {
    "code": "b = mod(a,m)",
    "comment": "returns the remainder after division of a by m, where a is the dividend and m is the divisor. This function is often called the modulo operation, which can be expressed as b = a - m.*floor(a./m). The mod function follows the convention that mod(a,0) returns a."
 },
 {
    "code": "b = mod(23,5)",
    "comment": "Compute 23 modulo 5."
 },
 {
    "code": "a = 1:5; \n m = 3; \n b = mod(a,m)",
    "comment": "Find the remainder after division for a vector of integers and the divisor 3."
 },
 {
    "code": "a = [-4 -1 7 9]; \n m = 3; \n b = mod(a,m)",
    "comment": "Find the remainder after division for a set of integers including both positive and negative values. Note that nonzero results are always positive if the divisor is positive."
 },
 {
    "code": "a = [-4 -1 7 9]; \n m = -3; \n b = mod(a,m)",
    "comment": "Find the remainder after division by a negative divisor for a set of integers including both positive and negative values. Note that nonzero results are always negative if the divisor is negative."
 },
 {
    "code": "theta = [0.0 3.5 5.9 6.2 9.0 4*pi]; \n m = 2*pi; \n b = mod(theta,m)",
    "comment": "Find the remainder after division for several angles using a modulus of 2*pi. Note that mod attempts to compensate for floating-point round-off effects to produce exact integer results when possible."
 },
 {
    "code": "r = rem(a,b)",
    "comment": "returns the remainder after division of a by b, where a is the dividend and b is the divisor. This function is often called the remainder operation, which can be expressed as r = a - b.*fix(a./b). The rem function follows the convention that rem(a,0) is NaN."
 },
 {
    "code": "a = 23; \n b = 5; \n r = rem(a,b)",
    "comment": "Compute the remainder after dividing 5 into 23."
 },
 {
    "code": "a = 1:5; \n b = 3; \n r = rem(a,b)",
    "comment": "Find the remainder after division for a vector of integers and the divisor 3."
 },
 {
    "code": "a = [-4 -1 7 9]; \n b = 3; \n r = rem(a,b)",
    "comment": "Find the remainder after division for a set of integers including both positive and negative values. Note that nonzero results have the same sign as the dividend."
 },
 {
    "code": "theta = [0.0 3.5 5.9 6.2 9.0 4*pi]; \n b = 2*pi; \n r = rem(theta,b)",
    "comment": "Find the remainder after division for several angles using a divisor of 2*pi. When possible, rem attempts to produce exact integer results by compensating for floating-point round-off effects."
 },
 {
    "code": "C = idivide(A,B)",
    "comment": "divides each element of A by the corresponding element of B, rounded to the nearest integers toward zero. A and B must contain real numbers and at least one of them must belong to an integer class."
 },
 {
    "code": "C = idivide(A,B,opt)",
    "comment": "specifies an alternative rounding option: 'fix', 'floor', 'ceil', or 'round'. For example, idivide(A,B,'ceil') rounds the quotients to the nearest integers toward positive infinity. The default rounding option is 'fix'."
 },
 {
    "code": "A = int16([-7 -4 7 11]); \n B = int16(10); \n C = idivide(A,B)",
    "comment": "Create an integer array A and an integer scalar B. Divide each element of A by B, rounded to the nearest integers toward zero."
 },
 {
    "code": "A = int64([-2 3]); \n B = int64([3 5]); \n C = idivide(A,B)",
    "comment": "Create two integer arrays, A and B. Divide each element of A by the corresponding element of B, rounded to the nearest integers toward zero."
 },
 {
    "code": "A = 2.0; \n B = int32([-3 3 4]); \n C = idivide(A,B) \n C = idivide(A,B,'floor') \n C = idivide(A,B,'ceil') \n C = idivide(A,B,'round')",
    "comment": "Create a scalar double A and an integer array B. Divide A by each element of B with the default rounding option 'fix'. Compare the results with other rounding options."
 },
 {
    "code": "Y = ceil(X)",
    "comment": "rounds each element of X to the nearest integer greater than or equal to that element."
 },
 {
    "code": "Y = ceil(t)",
    "comment": "rounds each element of the duration array t to the nearest number of seconds greater than or equal to that element."
 },
 {
    "code": "Y = ceil(t,unit)",
    "comment": "rounds each element of t to the nearest number of the specified unit of time greater than or equal to that element."
 },
 {
    "code": "Y = floor(X)",
    "comment": "rounds each element of X to the nearest integer less than or equal to that element."
 },
 {
    "code": "Y = floor(t)",
    "comment": "rounds each element of the duration array t to the nearest number of seconds less than or equal to that element."
 },
 {
    "code": "Y = floor(t,unit)",
    "comment": "rounds each element of t to the nearest number of the specified unit of time less than or equal to that element."
 },
 {
    "code": "Y = round(X)",
    "comment": "rounds each element of X to the nearest integer. In the case of a tie, where an element has a fractional part of 0.5 (within roundoff error) in decimal, the round function rounds away from zero to the nearest integer with larger magnitude."
 },
 {
    "code": "Y = round(X,N,type)",
    "comment": "specifies the type of rounding. Specify \"significant\" to round to N significant digits (counted from the leftmost digit). In this case, N must be a positive integer."
 },
 {
    "code": "Y = round(___,TieBreaker=direction) ",
    "comment": "rounds ties as specified by direction. Use this argument after any of the input argument combinations in the previous syntaxes."
 },
 {
    "code": "Y = round(t)",
    "comment": "rounds each element of the duration array t to the nearest number of seconds."
 },
 {
    "code": "Y = round(t,unit)",
    "comment": "rounds each element of t to the nearest number of the specified unit of time."
 },
 {
    "code": "X = [2.11 3.5; -3.5 0.78]; \n Y = round(X)",
    "comment": "Round the elements of a 2-by-2 matrix to the nearest integer."
 },
 {
    "code": "Y = round(pi,3)",
    "comment": "Round pi to the nearest 3 decimal digits."
 },
 {
    "code": "round(863178137,-2)",
    "comment": "Round the number 863178137 to the nearest multiple of 100."
 },
 {
    "code": "X = [1253 1.345 120.44] \n Y = round(X,2,\"significant\")",
    "comment": "Round the elements of a vector to retain 2 significant digits."
 },
 {
    "code": "C = bsxfun(fun,A,B)",
    "comment": "applies the element-wise binary operation specified by the function handle fun to arrays A and B."
 },
 {
    "code": "A = [8; 17; 20; 24] \n  B = [0 10 21] \n  C = bsxfun(@gt,A,B)",
    "comment": "Compare the elements in a column vector and a row vector. The result is a matrix containing the comparison of each combination of elements from the vectors. An equivalent way to execute this operation is with A > B."
 },
 {
    "code": "x = A\\B ",
    "comment": "solves the system of linear equations A*x = B. The matrices A and B must have the same number of rows. "
 },
 {
    "code": "x = mldivide(A,B)",
    "comment": "it is an alternative way to execute x = A\\B, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = magic(3); \n B = [15; 15; 15]; \n x = A\\B",
    "comment": "Solve a simple system of linear equations, A*x = B."
 },
 {
    "code": "A = magic(4); \n b = [34; 34; 34; 34]; \n x = A\b",
    "comment": "Solve a linear system of equations A*x = b involving a singular matrix, A."
 },
 {
    "code": "A = [1 2 0; 0 4 3]; \n b = [8; 18]; \n x = A\b",
    "comment": "Solve a system of linear equations, A*x = b."
 },
 {
    "code": "A = sparse([0 2 0 1 0; 4 -1 -1 0 0; 0 0 0 3 -6; -2 0 0 0 2; 0 0 4 2 0]); \n B = sparse([8; -1; -18; 8; 20]); \n x = A\\B",
    "comment": "Solve a simple system of linear equations using sparse matrices.Consider the matrix equation A*x = B."
 },
 {
    "code": "x = B/A",
    "comment": "solves the system of linear equations x*A = B for x. The matrices A and B must contain the same number of columns. "
 },
 {
    "code": "x = mrdivide(B,A)",
    "comment": "it is an alternative way to execute x = B/A, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [1 1 3; 2 0 4; -1 6 -1]; \n B = [2 19 8]; \n x = B/A",
    "comment": "Solve a system of equations that has a unique solution, x*A = B."
 },
 {
    "code": "C = [1 0; 2 0; 1 0]; \n D = [1 2]; \n x = D/C",
    "comment": "Solve an underdetermined system, x*C = D."
 },
 {
    "code": "dA = decomposition(A) ",
    "comment": "it returns a decomposition of matrix A that you can use to solve linear systems more efficiently. The decomposition type is automatically chosen based on the properties of the input matrix."
 },
 {
    "code": "dA = decomposition(A,type)",
    "comment": "it specifies the type of decomposition to perform. type can be 'qr', 'cod', 'lu', 'ldl', 'chol', 'triangular', 'permutedTriangular', 'banded', 'hessenberg', or 'diagonal'"
 },
 {
    "code": "dA = decomposition(A,type,triangularFlag)",
    "comment": "it specifies that only the upper or lower triangular portion of A is to be used in the decomposition. triangularFlag can be 'upper' or 'lower'. With this syntax, the decomposition type must be 'ldl', 'chol', or 'triangular'."
 },
 {
    "code": "dA = decomposition(___,Name,Value)",
    "comment": "it specifies additional options using one or more Name,Value pair arguments using any of the previous syntaxes. For example, dA = decomposition(A,'CheckCondition',false) specifies not to throw a warning based on the condition of A while solving dA\b."
 },
 {
    "code": "X = lsqminnorm(A,B)",
    "comment": "it returns an array X that solves the linear equation AX = B and minimizes the value of norm(A*X-B). If several solutions exist to this problem, then lsqminnorm returns the solution that minimizes norm(X). If B has multiple columns, then the previous statements are true for each column of X and B, respectively."
 },
 {
    "code": "X = lsqminnorm(A,B,tol)",
    "comment": "it additionally specifies the tolerance that lsqminnorm uses to determine the rank of A."
 },
 {
    "code": "X = lsqminnorm(___,rankWarn)",
    "comment": "it specifies an optional flag to display a warning if A has low rank. You can use any of the input argument combinations in previous syntaxes. rankWarn can be 'nowarn' (default) or 'warn'."
 },
 {
    "code": "X = linsolve(A,B)",
    "comment": "it solves the linear system AX = B "
 },
 {
    "code": "X = linsolve(A,B,opts)",
    "comment": "it uses an appropriate solver as determined by the options structure opts. The fields in opts are logical values describing properties of the matrix A."
 },
 {
    "code": "[X,r] = linsolve(___)",
    "comment": "it also returns r, which is the reciprocal of the condition number of A (for square matrices) or the rank of A (for rectangular matrices)."
 },
 {
    "code": "A = hilb(20); \n  b = ones(20,1); \n x = linsolve(A,b); \n [x,r] = linsolve(A,b)",
    "comment": "Solve a linear system using linsolve with two outputs to suppress matrix conditioning warnings.Create a 20-by-20 Hilbert test matrix. This matrix is nearly singular, with the largest singular value being about 2e18 larger than the smallest."
 },
 {
    "code": "Y = inv(X)",
    "comment": "it computes the inverse of square matrix X."
 },
 {
    "code": "X = [1 0 2; -1 5 0; 0 3 -9] \n  Y = inv(X)",
    "comment": "Compute the inverse of a 3-by-3 matrix."
 },
 {
    "code": "n = 500;  \n Q = orth(randn(n,n)); \n d = logspace(0,-10,n); \n A = Q*diag(d)*Q'; \n x = randn(n,1); \n b = A*x; \n tic \n y = inv(A)*b;  \n t = toc \n err_inv = norm(y-x) \n res_inv = norm(A*y-b) \n tic \n z = A\b; \n t1 = toc \n err_bs = norm(z-x) \n res_bs = norm(A*z-b) \n ",
    "comment": "Create a random matrix A of order 500 that is constructed so that its condition number, cond(A), is 1e10, and its norm, norm(A), is 1. The exact solution x is a random vector of length 500, and the right side is b = A*x. Thus the system of linear equations is badly conditioned, but consistent. Solve the linear system A*x = b by inverting the coefficient matrix A. Use tic and toc to get timing information. Find the absolute and residual error of the calculation. also solve the same linear system using the backslash operator \\."
 },
 {
    "code": "Y = pageinv(X)",
    "comment": "it computes the inverse of each page of N-D array X. Each page of the output array Y is given by Y(:,:,i) = inv(X(:,:,i))."
 },
 {
    "code": "[Y,RC] = pageinv(X)",
    "comment": "it also returns the reciprocal condition number of each page of X. The value of RC(1,1,i) is the reciprocal of the condition number of X(:,:,i). If RC(1,1,i) < eps, then the call inv(X(:,:,i)) returns a warning that X(:,:,i) is ill conditioned. However, pageinv does not issue a warning for ill-conditioned inputs."
 },
 {
    "code": "X = cat(3,magic(3),hilb(3),pascal(3))",
    "comment": "Create a 3-by-3-by-3 array by concatenating several 3-by-3 matrices."
 },
 {
    "code": "Y = pageinv(X)",
    "comment": "Calculate the matrix inverse of each array page."
 },
 {
    "code": "X = cat(3,magic(10),hilb(10))",
    "comment": "Create a 10-by-10-by-2 array with a magic square matrix on the first page and a Hilbert matrix on the second page."
 },
 {
    "code": "[Y,RC] = pageinv(X); \n RC",
    "comment": "Calculate the matrix inverse of each array page. Specify two outputs to also return the reciprocal condition number of each matrix that is being inverted."
 },
 {
    "code": "RC < eps",
    "comment": "Compare the reciprocal condition numbers to eps. The results indicate that the magic square matrix is ill conditioned, so the results of the inversion operation for that page are not reliable."
 },
 {
    "code": "B = pinv(A)",
    "comment": "it returns the Moore-Penrose Pseudoinverse of matrix A."
 },
 {
    "code": "B = pinv(A,tol)",
    "comment": "it specifies a value for the tolerance. pinv treats singular values of A that are smaller than the tolerance as zero."
 },
 {
    "code": "A = magic(8);  \n A = A(:,1:6) ",
    "comment": "Create an 8-by-6 matrix that has rank(A) = 3."
 },
 {
    "code": "b = 260*ones(8,1)",
    "comment": "Create a vector for the right-hand side of the system of equations."
 },
 {
    "code": "X = sylvester(A,B,C)",
    "comment": "it returns the solution, X, to the Sylvester equation."
 },
 {
    "code": "A = [1 -1 1; 1 1 -1; 1 1 1]; \n B = magic(3); \n C = eye(3); \n X = sylvester(A,B,C)",
    "comment": "Create the coefficient matrices A and B.Define C as the 3-by-3 identity matrix.Use the sylvester function to solve the Sylvester equation for these values of A, B, and C."
 },
 {
    "code": "A = [1 0 2 3; 4 1 0 2; 0 5 5 6; 1 7 9 0]; \n B = [0 -1; 1 0]; \n C = [1 0; 2 0; 0 3; 1 1] \n X = sylvester(A,B,C)",
    "comment": "Create a 4-by-4 coefficient matrix, A, and 2-by-2 coefficient matrix, B.Define C as a 4-by-2 matrix to match the corresponding sizes of A and B.Use the sylvester function to solve the Sylvester equation for these values of A, B, and C."
 },
 {
    "code": "e = eig(A)",
    "comment": "it returns a column vector containing the eigenvalues of square matrix A."
 },
 {
    "code": "[V,D] = eig(A)",
    "comment": "it returns diagonal matrix D of eigenvalues and matrix V whose columns are the corresponding right eigenvectors, so that A*V = V*D."
 },
 {
    "code": "[V,D,W] = eig(A)",
    "comment": "it also returns full matrix W whose columns are the corresponding left eigenvectors, so that W'*A = D*W'."
 },
 {
    "code": "e = eig(A,B)",
    "comment": "it returns a column vector containing the generalized eigenvalues of square matrices A and B."
 },
 {
    "code": "[V,D] = eig(A,B)",
    "comment": "it returns diagonal matrix D of generalized eigenvalues and full matrix V whose columns are the corresponding right eigenvectors, so that A*V = B*V*D."
 },
 {
    "code": "[V,D,W] = eig(A,B)",
    "comment": "it also returns full matrix W whose columns are the corresponding left eigenvectors, so that W'*A = D*W'*B."
 },
 {
    "code": "[___] = eig(A,balanceOption)",
    "comment": "where balanceOption is 'nobalance', disables the preliminary balancing step in the algorithm. The default for balanceOption is 'balance', which enables balancing. The eig function can return any of the output arguments in previous syntaxes."
 },
 {
    "code": "[___] = eig(A,B,algorithm)",
    "comment": "where algorithm is 'chol', uses the Cholesky factorization of B to compute the generalized eigenvalues. The default for algorithm depends on the properties of A and B, but is generally 'qz', which uses the QZ algorithm."
 },
 {
    "code": "[___] = eig(___,outputForm)",
    "comment": "it returns the eigenvalues in the form specified by outputForm using any of the input or output arguments in previous syntaxes. Specify outputForm as 'vector' to return the eigenvalues in a column vector or as 'matrix' to return the eigenvalues in a diagonal matrix."
 },
 {
    "code": "A = gallery('lehmer',4) \n  e = eig(A) \n  D = eig(A,'matrix')",
    "comment": "Use gallery to create a symmetric positive definite matrix.Calculate the eigenvalues of A. The result is a column vector.Alternatively, use outputForm to return the eigenvalues in a diagonal matrix."
 },
 {
    "code": "A = gallery('circul',3) \n  [V,D] = eig(A) \n  A*V - V*D",
    "comment": "Use gallery to create a circulant matrix.Calculate the eigenvalues and right eigenvectors of A.Verify that the results satisfy A*V = V*D."
 },
 {
    "code": "A = magic(5) \n  [V,D] = eig(A)",
    "comment": "Calculate the eigenvalues and eigenvectors of a 5-by-5 magic square matrix."
 },
 {
    "code": "A = [1 7 3; 2 9 12; 5 22 7]; \n  [V,D,W] = eig(A) \n  W'*A - D*W'",
    "comment": "Create a 3-by-3 matrix.Calculate the right eigenvectors, V, the eigenvalues, D, and the left eigenvectors, W.Verify that the results satisfy W'*A = D*W'."
 },
 {
    "code": "A = [3 1 0; 0 3 1; 0 0 3]; \n  [V,D] = eig(A) \n  A*V - V*D",
    "comment": "Create a 3-by-3 matrix.Calculate the eigenvalues and right eigenvectors of A.Verify that V and D satisfy the equation, A*V = V*D, even though A is defective."
 },
 {
    "code": "A = [1/sqrt(2) 0; 0 1]; \n B = [0 1; -1/sqrt(2) 0]; \n [V,D]=eig(A,B) \n A*V = B*V*D",
    "comment": "Create two matrices, A and B, then solve the generalized eigenvalue problem for the eigenvalues and right eigenvectors of the pair (A,B).Verify that the results satisfy A*V = B*V*D."
 },
 {
    "code": "format long e \n A = diag([10^-16, 10^-15]) \n [V1,D1] = eig(A,A) \n [V2,D2] = eig(A,A,'qz') \n format short \n A*V1 - A*V1*D1 \n A*V2 - A*V2*D2",
    "comment": "Create a badly conditioned symmetric matrix containing values close to machine precision.Calculate the generalized eigenvalues and a set of right eigenvectors using the default algorithm. In this case, the default algorithm is 'chol'. also calculate the generalized eigenvalues and a set of right eigenvectors using the 'qz' algorithm. Check how well the 'chol' result satisfies A*V1 = A*V1*D1. also check how well the 'qz' result satisfies A*V2 = A*V2*D2."
 },
 {
    "code": "D = pageeig(X)",
    "comment": "it returns the eigenvalues of each page of a multidimensional array. Each page of the output D(:,:,i) is a column vector containing the eigenvalues of X(:,:,i). Each page of X must be a square matrix."
 },
 {
    "code": "[V,D] = pageeig(X",
    "comment": "it computes the eigenvalue decomposition of each page of a multidimensional array. "
 },
 {
    "code": "[V,D,W] = pageeig(X)",
    "comment": "it also computes the left eigenvectors of each page of a multidimensional array. The pages in W satisfy the equation: W(:,:,i)' * X(:,:,i) = D(:,:,i) * W(:,:,i)'."
 },
 {
    "code": "[___] = pageeig(X,balanceOption)",
    "comment": "where balanceOption is \"nobalance\", disables the preliminary balancing step in the algorithm. The default for balanceOption is \"balance\", which enables balancing. The pageeig function can return any of the output arguments in previous syntaxes."
 },
 {
    "code": "[___] = pageeig(___,outputForm)",
    "comment": "it returns the eigenvalues in the form specified by outputForm using any of the input or output arguments in previous syntaxes. Specify outputForm as \"vector\" to return the eigenvalues as pages of column vectors or as \"matrix\" to return the eigenvalues as pages of diagonal matrices."
 },
 {
    "code": "A = magic(6); \n B = hilb(6); \n X = cat(3,A,B); \n D = pageeig(X) \n D = pageeig(X,\"matrix\")",
    "comment": "Create two 6-by-6 matrices. Use the cat function to concatenate them along the third dimension into a 6-by-6-by-2 array.Calculate the eigenvalues of each array page.Specify the \"matrix\" option to instead return the eigenvalues as pages of diagonal matrices."
 },
 {
    "code": "A = magic(5); \n B = hilb(5); \n X = cat(3,A,B); \n [V,D] = pageeig(X) \n err = pagenorm(pagemtimes(X,V) - pagemtimes(V,D),\"fro\")",
    "comment": "Create two 5-by-5 matrices. Use the cat function to concatenate them along the third dimension into a 5-by-5-by-2 array.Calculate the eigenvalue decomposition of each array page.Verify the relation XV=VD for each array page, within machine precision."
 },
 {
    "code": "A = magic(6); \n B = hilb(6); \n X = cat(3,A,B); \n [V,D,W] = pageeig(X) \n err = pagenorm(pagemtimes(W,\"ctranspose\",X,\"none\") - pagemtimes(D,\"none\",W,\"ctranspose\"))",
    "comment": "Create two 6-by-6 matrices. Use the cat function to concatenate them along the third dimension into a 6-by-6-by-2 array.Calculate the eigenvalue decomposition of each array page, specifying three outputs to calculate the left eigenvectors W.Verify the relation W*X = DW* for each array page, within machine precision"
 },
 {
    "code": "d = eigs(A)",
    "comment": "it returns a vector of the six largest magnitude eigenvalues of matrix A. This is most useful when computing all of the eigenvalues with eig is computationally expensive, such as with large sparse matrices."
 },
 {
    "code": "d = eigs(A,k)",
    "comment": "it returns the k largest magnitude eigenvalues."
 },
 {
    "code": "d = eigs(A,k,sigma)",
    "comment": "it returns k eigenvalues based on the value of sigma. For example, eigs(A,k,'smallestabs') returns the k smallest magnitude eigenvalues."
 },
 {
    "code": "d = eigs(A,k,sigma,Name,Value)",
    "comment": "it specifies additional options with one or more name-value pair arguments. For example, eigs(A,k,sigma,'Tolerance',1e-3) adjusts the convergence tolerance for the algorithm."
 },
 {
    "code": "d = eigs(A,k,sigma,opts)",
    "comment": "it specifies options using a structure."
 },
 {
    "code": "d = eigs(A,B,___)",
    "comment": "it solves the generalized eigenvalue problem A*V = B*V*D. You can optionally specify k, sigma, opts, or name-value pairs as additional input arguments."
 },
 {
    "code": "d = eigs(Afun,n,___)",
    "comment": "it specifies a function handle Afun instead of a matrix. The second input n gives the size of matrix A used in Afun. You can optionally specify B, k, sigma, opts, or name-value pairs as additional input arguments."
 },
 {
    "code": "[V,D] = eigs(___)",
    "comment": "it returns diagonal matrix D containing the eigenvalues on the main diagonal, and matrix V whose columns are the corresponding eigenvectors. You can use any of the input argument combinations in previous syntaxes."
 },
 {
    "code": "[V,D,flag] = eigs(___)",
    "comment": "it also returns a convergence flag. If flag is 0, then all the eigenvalues converged."
 },
 {
    "code": "A = delsq(numgrid('C',15)); \n d = eigs(A) \n d = eigs(A,3)",
    "comment": "The matrix A = delsq(numgrid('C',15)) is a symmetric positive definite matrix with eigenvalues reasonably well-distributed in the interval (0 8). Compute the six largest magnitude eigenvalues.Specify a second input to compute a specific number of the largest eigenvalues."
 },
 {
    "code": "A = delsq(numgrid('C',15));   \n d = eigs(A,5,'smallestabs')",
    "comment": "The matrix A = delsq(numgrid('C',15)) is a symmetric positive definite matrix with eigenvalues reasonably well-distributed in the interval (0 8). Compute the five smallest eigenvalues."
 },
 {
    "code": "n = 1500; \n A = sprand(n,n,0.25); \n [L,U,p] = lu(A,'vector'); \n Afun = @(x) U\\(L\\(x(p))); \n d = eigs(Afun,1500,6,'smallestabs')",
    "comment": "Create a 1500-by-1500 random sparse matrix with a 25% approximate density of nonzero elements.Find the LU factorization of the matrix, returning a permutation vector p that satisfies A(p,:) = L*U.Create a function handle Afun that accepts a vector input x and uses the results of the LU decomposition to, in effect, return A\\x.Calculate the six smallest magnitude eigenvalues using eigs with the function handle Afun. The second input is the size of A."
 },
 {
    "code": "A = delsq(numgrid('C', 150)); \n  tic \n d = eigs(A, 6, 'smallestreal') \n toc \n tic \n dsm = eigs(A, 6, 'smallestabs') \n ",
    "comment": "Create a symmetric positive definite sparse matrix.Compute the six smallest real eigenvalues using 'smallestreal', which employs a Krylov method using A.Compute the same eigenvalues using 'smallestabs', which employs a Krylov method using the inverse of A."
 },
 {
    "code": "A = delsq(numgrid('C',30));  \n sigma = 4 - 1e-6; \n d = eig(A); \n D = sort(eigs(A,20,sigma)); \n plot(d(307:326),'ks') \n hold on \n plot(D,'k+') \n hold off \n legend('eig(A)','eigs(A,20,sigma)')  \n title('18 Repeated Eigenvalues of A') \n ",
    "comment": "Compute all of the eigenvalues using eig, and the 20 eigenvalues closest to 4 - 1e-6 using eigs to compare results. Plot the eigenvalues calculated with each method."
 },
 {
    "code": "B = sprandn(1e3,1e3,0.001) + speye(1e3);  \n B = B'*B;  \n A = sprandn(1e3,1e3,0.005);  \n A = A+A'; \n [R,p,s] = chol(B,'vector'); \n p \n [V,D,flag] = eigs(A,R,6,'largestabs','IsCholesky',true,'CholeskyPermutation',s); \n flag",
    "comment": "Create sparse random matrices A and B that both have low densities of nonzero elements.Find the Cholesky decomposition of matrix B, using three outputs to return the permutation vector s and test value p.Since p is zero, B is a symmetric positive definite matrix that satisfies B(s,s) = R'*R."
 },
 {
    "code": "S = svd(A)",
    "comment": "it returns the singular values of matrix A in descending order."
 },
 {
    "code": "[U,S,V] = svd(A)",
    "comment": "it performs a singular value decomposition of matrix A, such that A = U*S*V'."
 },
 {
    "code": "[___] = svd(A,\"econ\")",
    "comment": "it produces an economy-size decomposition of A using either of the previous output argument combinations."
 },
 {
    "code": "[___] = svd(___,outputForm)",
    "comment": "it optionally specifies the output format for the singular values. You can use this option with any of the previous input or output argument combinations. Specify \"vector\" to return the singular values as a column vector, or \"matrix\" to return the singular values in a diagonal matrix."
 },
 {
    "code": "A = [1 0 1; -1 -2 0; 0 1 -1] \n  s = svd(A)",
    "comment": "Compute the singular values of a full rank matrix."
 },
 {
    "code": "A = [1 2; 3 4; 5 6; 7 8] \n  [U,S,V] = svd(A) \n  U*S*V'",
    "comment": "Find the singular value decomposition of a rectangular matrix A. and Confirm the relation A = U*S*V', within machine precision."
 },
 {
    "code": "A = [1 2; 3 4; 5 6; 7 8] \n  [U,S,V] = svd(A) \n  [U,S,V] = svd(A,\"econ\") \n  ",
    "comment": "Calculate the complete and economy-size decompositions of a rectangular matrix."
 },
 {
    "code": "A = magic(6); \n [U,S,V] = svd(A) \n [U,S,V] = svd(A,\"vector\")",
    "comment": "Create a 6-by-6 magic square matrix and calculate the SVD. By default, svd returns the singular values in a diagonal matrix when you specify multiple outputs.Specify the \"vector\" option to return the singular values in a column vector."
 },
 {
    "code": "A = [2 0 2; 0 1 0; 0 0 0] \n  [U,S,V] = svd(A) \n  s = diag(S); \n rank_A = nnz(s) \n column_basis = U(:,logical(s)) \n null_basis = V(:,~s)",
    "comment": "Use the results of the singular value decomposition to determine the rank, column space, and null space of a matrix.Calculate the rank using the number of nonzero singular values.Compute an orthonormal basis for the column space of A using the columns of U that correspond to nonzero singular values.Compute an orthonormal basis for the null space of A using the columns of V that correspond to singular values equal to zero."
 },
 {
    "code": "S = pagesvd(X)",
    "comment": "it returns the singular values of each page of a multidimensional array. Each page of the output S(:,:,i) is a column vector containing the singular values of X(:,:,i) in decreasing order. If each page of X is an m-by-n matrix, then the number of singular values returned on each page of S is min(m,n)."
 },
 {
    "code": "[U,S,V] = pagesvd(X)",
    "comment": "it computes the singular value decomposition of each page of a multidimensional array. "
 },
 {
    "code": "A = magic(6); \n B = hilb(6); \n X = cat(3,A,B); \n S = pagesvd(X)",
    "comment": "Create two 6-by-6 matrices. Use the cat function to concatenate them along the third dimension into a 6-by-6-by-2 array.Calculate the singular values of each page by calling pagesvd with one output."
 },
 {
    "code": "A = magic(5); \n B = hilb(5); \n X = cat(3,A,B); \n s = pagesvd(X) \n [U,S,V] = pagesvd(X) \n e1 = norm(X(:,:,1) - U(:,:,1)*S(:,:,1)*V(:,:,1)',\"fro\") \n e2 = norm(X(:,:,2) - U(:,:,2)*S(:,:,2)*V(:,:,2)',\"fro\") \n US = pagemtimes(U,S); \n USV = pagemtimes(US,\"none\",V,\"ctranspose\"); \n e = max(abs(X - USV),[],\"all\")",
    "comment": "Create two 5-by-5 matrices. Use the cat function to concatenate them along the third dimension into a 5-by-5-by-2 array.Calculate the singular values of each array page.Perform a complete singular value decomposition on each array page.Verify the relation X=USV^H for each array page, within machine precision . Alternatively, you can use pagemtimes to check the relation for both pages simultaneously."
 },
 {
    "code": "A = magic(6); \n B = hilb(6); \n X = cat(3,A,B); \n [U,S,V] = pagesvd(X) \n [U,S,V] = pagesvd(X,\"vector\")",
    "comment": "Create two 6-by-6 matrices. Use the cat function to concatenate them along the third dimension into a 6-by-6-by-2 array.Calculate the SVD of each array page. By default, pagesvd returns each page of singular values as a diagonal matrix when you specify multiple outputs.Specify the \"vector\" option to return each page of singular values as a column vector."
 },
 {
    "code": "X = randi([0 3],10,3); \n  [U,S,V] = pagesvd(X) \n  [Ue,Se,Ve] = pagesvd(X,\"econ\") ",
    "comment": "Create a 10-by-3 matrix with random integer elements.Perform both a complete decomposition and an economy-size decomposition on the matrix."
 },
 {
    "code": "s = svds(A)",
    "comment": "it returns a vector of the six largest singular values of matrix A. This is useful when computing all of the singular values with svd is computationally expensive, such as with large sparse matrices."
 },
 {
    "code": "s = svds(A,k)",
    "comment": "it returns the k largest singular values."
 },
 {
    "code": "s = svds(A,k,sigma)",
    "comment": "it returns k singular values based on the value of sigma. For example, svds(A,k,'smallest') returns the k smallest singular values."
 },
 {
    "code": "s = svds(A,k,sigma,Name,Value)",
    "comment": "it specifies additional options with one or more name-value pair arguments. For example, svds(A,k,sigma,'Tolerance',1e-3) adjusts the convergence tolerance for the algorithm."
 },
 {
    "code": "s = svds(A,k,sigma,opts)",
    "comment": "it specifies options using a structure."
 },
 {
    "code": "s = svds(Afun,n,___)",
    "comment": "it specifies a function handle Afun instead of a matrix. The second input n gives the size of matrix A used in Afun. You can optionally specify k, sigma, opts, or name-value pairs as additional input arguments."
 },
 {
    "code": "[U,S,V] = svds(___)",
    "comment": "it returns the left singular vectors U, diagonal matrix S of singular values, and right singular vectors V. You can use any of the input argument combinations in previous syntaxes."
 },
 {
    "code": "[U,S,V,flag] = svds(___)",
    "comment": "it also returns a convergence flag. If flag is 0, then all the singular values converged."
 },
 {
    "code": "A = delsq(numgrid('C',15)); \n s = svds(A) \n s = svds(A,3)",
    "comment": "The matrix A = delsq(numgrid('C',15)) is a symmetric positive definite matrix with singular values reasonably well-distributed in the interval (0 8). Compute the six largest singular values.Specify a second input to compute a specific number of the largest singular values."
 },
 {
    "code": "A = delsq(numgrid('C',15)); \n s = svds(A,5,'smallest')",
    "comment": "The matrix A = delsq(numgrid('C',15)) is a symmetric positive definite matrix with singular values reasonably well-distributed in the interval (0 8). Compute the five smallest singular values."
 },
 {
    "code": "C = gallery('neumann',100); \n  ss = svds(C,10,'smallest') \n  snz = svds(C,10,'smallestnz')",
    "comment": "Create a sparse 100-by-100 Neumann matrix.Compute the ten smallest singular values.Compute the 10 smallest nonzero singular values. Since the matrix has a singular value that is equal to zero, the 'smallestnz' option omits it."
 },
 {
    "code": "n = 500; \n B = rand(500); \n C = rand(500); \n s = svds(@(x,tflag) Afun(x,tflag,B,C,n),[1000 1000],10) \n A = [zeros(n) B; C zeros(n)]; \n s = svds(A,10)",
    "comment": "Create two matrices representing the upper-right and lower-left nonzero blocks in a sparse matrix.Use Afun to calculate the 10 largest singular values of A. Pass B, C, and n as additional inputs to Afun.Directly compute the 10 largest singular values of A to compare the results."
 },
 {
    "code": "rng default \n format shortg \n B = spdiags([repelem([1; 1e-7], [198, 2]) ones(200, 1)], [0 1], 200, 200); \n s1 = svds(B,10,'smallest') \n s = svd(full(B)); \n s = s(end-9:end) \n [Q,R,p] = qr(B,0); \n rownormR = sqrt(diag(R*R')); \n semilogy(rownormR) \n hold on; \n semilogy(size(R, 1), rownormR(end), 'ro') \n R(end,:) = 0; \n sr = svds(R,10,'smallest') \n [U,S,V] = svds(R,20,'s'); \n U = Q*U; \n V(p,:) = V;",
    "comment": "Compute the 10 smallest singular values of a nearly singular matrix.For comparison, compute the exact singular values using svd.In order to reproduce this calculation with svds, do a QR decomposition of B. The singular values of the triangular matrix R are the same as for B.Plot the norm of each row of R.Prevent this entry from corrupting the good parts of the solution by setting the last row of R to be exactly zero.Use svds to find the 10 smallest singular values of R. The results are comparable to those obtained by svd.To compute the singular vectors of B using this method, transform the left and right singular vectors using Q and the permutation vector p."
 },
 {
    "code": "[U,S,V] = svdsketch(A)",
    "comment": "it returns the singular value decomposition (SVD) of a low-rank matrix sketch of input matrix A. The matrix sketch is a low-rank approximation that only reflects the most important features of A (up to a tolerance), which enables faster calculation of a partial SVD of large matrices compared to using svds."
 },
 {
    "code": "[U,S,V] = svdsketch(A,tol)",
    "comment": "it specifies a tolerance for the matrix sketch. svdsketch uses tol to adaptively determine the rank of the matrix sketch approximation. As the tolerance gets larger, fewer features of A are used in the matrix sketch."
 },
 {
    "code": "[U,S,V] = svdsketch(A,tol,Name,Value)",
    "comment": "it specifies additional options with one or more Name,Value pair arguments. For example, you can specify 'MaxIterations' and a scalar to adjust the number of iterations used to form the matrix sketch."
 },
 {
    "code": "A = gallery('randsvd',200); \n  [U,S,V] = svdsketch(A); \n  size(S)",
    "comment": "Use gallery to create a 200-by-200 random matrix with geometrically distributed singular values.Use svdsketch to calculate the SVD of a low-rank approximation of A.Check the size of the outputs."
 },
 {
    "code": "A = gallery('randsvd',200); \n  tol = 1e-2; \n [U,S,V] = svdsketch(A,tol); \n size(S) \n norm(U*S*V' - A,'fro')/norm(A,'fro')",
    "comment": "Use gallery to create a 200-by-200 random matrix with geometrically distributed singular values.Use svdsketch to calculate the SVD of a low-rank approximation of A. Specify a tolerance of 1e-2, and find the size of the output S to determine the rank svdsketch uses for the matrix sketch.Examine how well the matrix sketch approximates A by comparing A to U*S*V'."
 },
 {
    "code": "A = randn(5000); \n semilogy(svd(A),'-o') \n tol = 1e-5; \n [U1,S1,V1,apxError1] = svdsketch(A,tol); \n size(S1) \n apxError1(end)",
    "comment": "Create a 5000-by-5000 matrix with values drawn from the standard normal distribution. View the distribution of matrix singular values.Use svdsketch on the matrix with a tolerance of 1e-5. Specify four outputs to return the SVD factors as well as the relative approximation error in each iteration.Check the approximation error of the outputs. Since svdsketch preserves everything in A, the computed answer is accurate, but the calculation was just an expensive way to calculate svd(X)."
 },
 {
    "code": "A = reshape(1:15,5,3) \n  B = magic(3) \n  [U,V,X,C,S] = gsvd(A,B)",
    "comment": "Create a 5-by-3 matrix A and a 3-by-3 matrix B.Perform a generalized singular value decomposition on A and B. The outputs include orthogonal U and V, a nonsingular X, and diagonal matrices C and S. Because A is rank deficient, the first diagonal element of C is zero."
 },
 {
    "code": "A = reshape(1:15,3,5) \n  B = magic(5) \n  [U,V,X,C,S] = gsvd(A,B) \n  sigma = gsvd(A,B) \n  sigma2 = gsvd(B,A)",
    "comment": "Create a 3-by-5 matrix A and a 5-by-5 matrix B.Perform a generalized singular value decomposition on A and B. The outputs include orthogonal U and V, a nonsingular X, and diagonal matrices C and S. In this situation, the nonzero diagonal of C is diag(C,2).Find the generalized singular values, which include zeros.Reversing the roles of A and B inverts these values, producing Inf values."
 },
 {
    "code": "[L,U] = lu(A)",
    "comment": "it factorizes the full or sparse matrix A into an upper triangular matrix U and a permuted lower triangular matrix L such that A = L*U."
 },
 {
    "code": "[L,U,P] = lu(A)",
    "comment": "it also returns a permutation matrix P such that A = P'*L*U. With this syntax, L is unit lower triangular and U is upper triangular."
 },
 {
    "code": "[L,U,P] = lu(A,outputForm)",
    "comment": "it returns P in the form specified by outputForm. Specify outputForm as 'vector' to return P as a permutation vector such that A(P,:) = L*U."
 },
 {
    "code": "[L,U,P,Q] = lu(S)",
    "comment": "it factorizes sparse matrix S into a unit lower triangular matrix L, an upper triangular matrix U, a row permutation matrix P, and a column permutation matrix Q, such that P*S*Q = L*U."
 },
 {
    "code": "[L,U,P,Q,D] = lu(S)",
    "comment": "it also returns a diagonal scaling matrix D such that P*(D\\S)*Q = L*U. Typically, the row-scaling leads to a sparser and more stable factorization."
 },
 {
    "code": "[___] = lu(S,thresh)",
    "comment": "it specifies thresholds for the pivoting strategy employed by lu using any of the previous output argument combinations. Depending on the number of output arguments specified, the default value and requirements for the thresh input are different. See the thresh argument description for details."
 },
 {
    "code": "[___] = lu(___,outputForm)",
    "comment": "it returns P and Q in the form specified by outputForm. Specify outputForm as 'vector' to return P and Q as permutation vectors. You can use any of the input argument combinations in previous syntaxes."
 },
 {
    "code": "A = [10 -7 0 \n      -3  2 6 \n       5 -1 5]; \n    [L,U] = lu(A) \n    L*U \n    [L,U,P] = lu(A) \n    P'*L*U \n    ",
    "comment": "Compute the LU factorization of a matrix and examine the resulting factors. LU factorization is a way of decomposing a matrix A into an upper triangular matrix U, a lower triangular matrix L, and a permutation matrix P such that PA=LU. These matrices describe the steps needed to perform Gaussian elimination on the matrix until it is in reduced row echelon form. The L matrix contains all of the multipliers, and the permutation matrix P accounts for row interchanges."
 },
 {
    "code": "A = [10 -7 0 \n      -3  2 6 \n       5 -1 5]; \n    [L,U] = lu(A) \n    L*U \n    [L,U,P] = lu(A) \n    P'*L*U",
    "comment": "Create a 3-by-3 matrix and calculate the LU factors.Multiply the factors to recreate A. With the two-input syntax, lu incorporates the permutation matrix P directly into the L factor, such that the L being returned is really P'*L and thus A = L*U. You can specify three outputs to separate the permutation matrix from the multipliers in L."
 },
 {
    "code": "S = bucky; \n  [L,U,P,Q] = lu(S); \n  e = P*S*Q - L*U; \n norm(e,1) \n ",
    "comment": "Compute the LU factorization of a sparse matrix and verify the identity L*U = P*S*Q.Create a 60-by-60 sparse adjacency matrix of the connectivity graph of the Buckminster-Fuller geodesic dome.Compute the LU factorization of S using the sparse matrix syntax with four outputs to return the row and column permutation matrices.Permute the rows and columns of S with P*S*Q and compare the result with multiplying the triangular factors L*U. The 1-norm of their difference is within roundoff error, indicating that L*U = P*S*Q."
 },
 {
    "code": "load west0479 \n A = west0479; \n [L,U,P] = lu(A); \n subplot(1,2,1) \n spy(L) \n title('L factor') \n subplot(1,2,2) \n spy(U) \n title('U factor') \n [L,U,P,Q] = lu(A); \n subplot(1,2,1) \n spy(L) \n title('L factor') \n subplot(1,2,2) \n spy(U) \n title('U factor')",
    "comment": "Compare the results of computing the LU factorization of a sparse matrix with and without column permutations.Load the west0479 matrix, which is a real-valued 479-by-479 sparse matrix.Calculate the LU factorization of A by calling lu with three outputs. Generate spy plots of the L and U factors.Now, calculate the LU factorization of A using lu with four outputs, which permutes the columns of A to reduce the number of nonzeros in the factors. The resulting factors are much sparser than if column permutations are not used."
 },
 {
    "code": "R = chol(A)",
    "comment": "it factorizes symmetric positive definite matrix A into an upper triangular R that satisfies A = R'*R. If A is nonsymmetric, then chol treats the matrix as symmetric and uses only the diagonal and upper triangle of A."
 },
 {
    "code": "R = chol(A,triangle)",
    "comment": "it specifies which triangular factor of A to use in computing the factorization. For example, if triangle is 'lower', then chol uses only the diagonal and lower triangular portion of A to produce a lower triangular matrix R that satisfies A = R*R'. The default value of triangle is 'upper'."
 },
 {
    "code": "[R,flag,P] = chol(S)",
    "comment": "it additionally returns a permutation matrix P, which is a preordering of sparse matrix S obtained by amd. If flag = 0, then S is symmetric positive definite and R is an upper triangular matrix satisfying R'*R = P'*S*P."
 },
 {
    "code": "[R,flag,P] = chol(___,outputForm)",
    "comment": "it specifies whether to return the permutation information P as a matrix or vector, using any of the input argument combinations in previous syntaxes. This option is only available for sparse matrix inputs. For example, if outputForm is 'vector' and flag = 0, then S(p,p) = R'*R. The default value of outputForm is 'matrix' such that R'*R = P'*S*P."
 },
 {
    "code": "A = [1 0 1; 0 2 0; 1 0 3] \n  R = chol(A) \n  b = sum(A,2); \n  x = R\\(R'\\b)",
    "comment": "Use chol to factorize a symmetric coefficient matrix, and then solve a linear system using the Cholesky factor."
 },
 {
    "code": "A = [1 0 1; 0 2 0; 1 0 3] \n  R = chol(A) \n  b = sum(A,2); \n  x = R\\(R'\\b)",
    "comment": "Create a symmetric matrix with positive values on the diagonal. Calculate the Cholesky factor of the matrix.Create a vector for the right-hand side of the equation Ax=b.Since A=RR^T with the Cholesky decomposition, the linear equation becomes RR^Tx= b . Solve for x using the backslash operator."
 },
 {
    "code": "A = gallery('lehmer',6); \n  R = chol(A) \n  norm(R'*R - A) \n  L = chol(A,'lower') \n  norm(L*L' - A)",
    "comment": "Calculate the upper and lower Cholesky factorizations of a matrix and verify the results."
 },
 {
    "code": "A = pascal(5); \n A(end) = A(end) - 1 \n [R,flag] = chol(A) \n q = flag-1; \n R'*R \n A(1:q,1:q)",
    "comment": "Use chol with two outputs to suppress errors when the input matrix is not symmetric positive definite."
 },
 {
    "code": "load west0479 \n A = west0479; \n S = A'*A; \n [R,flag] = chol(S); \n [RP,flagP,P] = chol(S); \n if ~flag && ~flagP \n     disp('Factorizations successful.') \n else \n     disp('Factorizations failed.') \n end \n subplot(1,2,1) \n spy(R) \n title('Nonzeros in chol(S)') \n subplot(1,2,2) \n spy(RP) \n title('Nonzeros in chol(P''*S*P)') \n ",
    "comment": "Calculate the Cholesky factor of a sparse matrix, and use the permutation output to create a Cholesky factor with fewer nonzeros."
 },
 {
    "code": "S = gallery('wathen',10,10); \n spy(S) \n [R,flag,p] = chol(S,'vector'); \n if ~flag \n     disp('Factorization successful.') \n else \n     disp('Factorization failed.') \n end \n norm(S(p,p) - R'*R,'fro')",
    "comment": "Use the 'vector' option of chol to return the permutation information as a vector rather than a matrix."
 },
 {
    "code": "S = gallery('wathen',10,10); \n spy(S) \n [R,flag,p] = chol(S,'vector'); \n if ~flag \n     disp('Factorization successful.') \n else \n     disp('Factorization failed.') \n end \n norm(S(p,p) - R'*R,'fro')",
    "comment": "Create a sparse finite element matrix. Calculate the Cholesky factor for the matrix, and specify the 'vector' option to return a permutation vector p.Verify that flag = 0, indicating the calculation is successful.Verify that S(p,p) = R'*R, within roundoff error."
 },
 {
    "code": "R = qr(A)",
    "comment": "it returns the upper-triangular R factor of the QR decomposition A = Q*R."
 },
 {
    "code": "[Q,R] = qr(A)",
    "comment": "it performs a QR decomposition on m-by-n matrix A such that A = Q*R. The factor R is an m-by-n upper-triangular matrix, and the factor Q is an m-by-m orthogonal matrix."
 },
 {
    "code": "[Q,R,P] = qr(A)",
    "comment": "it additionally returns a permutation matrix P such that A*P = Q*R. If A is full, the permutation matrix is chosen so that abs(diag(R)) is decreasing."
 },
 {
    "code": "[Q,R,P] = qr(A,outputForm)",
    "comment": "it specifies whether to return the permutation information P as a matrix or a vector. For example, if outputForm is \"vector\", then A(:,P) = Q*R. The default value of outputForm is \"matrix\" such that A*P = Q*R."
 },
 {
    "code": "[___] = qr(A,0)",
    "comment": "it is equivalent to qr(A,\"econ\",\"vector\"). The use of this syntax is not recommended. Use the \"econ\" option instead."
 },
 {
    "code": "[C,R] = qr(S,B)",
    "comment": "it computes C = Q'*B and the upper-triangular factor R. You can use C and R to compute a least-squares solution to the sparse linear system S*X = B with X = R\\C."
 },
 {
    "code": "[___] = qr(S,B,0)",
    "comment": "it is equivalent to qr(S,B,\"econ\",\"vector\"). The use of this syntax is not recommended. Use the \"econ\" option instead."
 },
 {
    "code": "A = magic(5); \n R = qr(A)",
    "comment": "Find the QR decomposition of the 5-by-5 magic square matrix. Specify one output argument to return just the upper-triangular factor."
 },
 {
    "code": "A = magic(5); \n [Q,R] = qr(A) \n norm(A-Q*R)",
    "comment": "Compute the full QR decomposition of a magic square test matrix by specifying two output arguments.Verify that A=QR, within machine precision."
 },
 {
    "code": "load west0479 \n A = west0479; \n [Q,R,P] = qr(A); \n norm(A*P-Q*R,\"fro\") \n [Q,R,p] = qr(A,\"vector\"); \n norm(A(:,p) - Q*R,\"fro\") \n [Q1,R1] = qr(A); \n spy(R1)",
    "comment": "Compute the QR decomposition of the west0479 sparse matrix. Specify three outputs to return a permutation matrix that satisfies AP=QR.Verify that A*P = Q*R for the permutation matrix P, within machine precision.Now specify the \"vector\" option to return p as a permutation vector.Verify that A(:,p) = Q*R for the permutation vector p, within machine precision.Verify that the use of a permutation matrix or permutation vector in the decomposition results in an R factor with fewer nonzeros for sparse inputs compared to a nonpermuted decomposition."
 },
 {
    "code": "B = A.'",
    "comment": "it returns the nonconjugate transpose of A, that is, interchanges the row and column index for each element. If A contains complex elements, then A.' does not affect the sign of the imaginary parts. For example, if A(3,2) is 1+2i and B = A.', then the element B(2,3) is also 1+2i."
 },
 {
    "code": "B = transpose(A)",
    "comment": "it is an alternate way to execute A.' and enables operator overloading for classes."
 },
 {
    "code": "A = magic(4) \n  B = A.'",
    "comment": "Create a matrix of real numbers and compute its transpose. B has the same elements as A, but the rows of B are the columns of A and the columns of B are the rows of A."
 },
 {
    "code": "A = [1 3 4-1i 2+2i; 0+1i 1-1i 5 6-1i] \n  B = A.'",
    "comment": "Create a matrix containing complex elements and compute its nonconjugate transpose. B contains the same elements as A, except the rows and columns are interchanged. The signs of the imaginary parts are unchanged."
 },
 {
    "code": "B = A'",
    "comment": "it computes the complex conjugate transpose of A."
 },
 {
    "code": "B = ctranspose(A)",
    "comment": "it is an alternate way to execute A', but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [2 1; 9 7; 2 8; 3 5] \n  B = A'",
    "comment": "Create a 4-by-2 matrix.Find the conjugate transpose of A."
 },
 {
    "code": "A = [0-1i 2+1i;4+2i 0-2i] \n  B = A'",
    "comment": "Create a 2-by-2 matrix with complex elements.Find the conjugate transpose of A."
 },
 {
    "code": "Y = pagetranspose(X)",
    "comment": "it applies the nonconjugate transpose to each page of N-D array X. Each page of the output Y(:,:,i) is found by transposing the corresponding page in X, as in X(:,:,i).'."
 },
 {
    "code": "r = repelem(1:3,3,1); \n A = cat(3,r,2*r,3*r) \n B = pagetranspose(A)",
    "comment": "Create a 3-D array A, and then use pagetranspose to transpose each page of the array."
 },
 {
    "code": "Y = pagectranspose(X)",
    "comment": "it applies the complex conjugate transpose to each page of N-D array X. Each page of the output Y(:,:,i) is the conjugate transpose of the corresponding page in X, as in X(:,:,i)'."
 },
 {
    "code": "r = repelem(1:3,3,1); \n A = cat(3,r,2*r,3*r); \n A = A + 1i \n B = pagectranspose(A)",
    "comment": "Create a 3-D complex array A, and then use pagectranspose to find the complex conjugate transpose of each page of the array."
 },
 {
    "code": "C = A*B",
    "comment": " is the matrix product of A and B. If A is an m-by-p and B is a p-by-n matrix"
 },
 {
    "code": "A = [1 1 0 0]; \n B = [1; 2; 3; 4]; \n C = A*B \n C = B*A \n ",
    "comment": "Create a 1-by-4 row vector, A, and a 4-by-1 column vector, B.Multiply A times B. and Multiply B times A."
 },
 {
    "code": "A = [1 3 5; 2 4 7]; \n B = [-5 8 11; 3 9 21; 4 0 8]; \n C = A*B \n A(2,:)*B(:,3)",
    "comment": "Create two arrays, A and B.Calculate the product of A and B.Calculate the inner product of the second row of A and the third column of B."
 },
 {
    "code": "C = A^B",
    "comment": "it computes A to the B power and returns the result in C."
 },
 {
    "code": "C = mpower(A,B)",
    "comment": "it is an alternate way to execute A^B, but is rarely used. It enables operator overloading for classes."
 },
 {
    "code": "A = [1 2; 3 4]; \n C = A^2",
    "comment": "Create a 2-by-2 matrix and square it."
 },
 {
    "code": "B = [0 1; 1 0]; \n C = 2^B \n [V,D] = eig(B) \n C = V*2^D/V",
    "comment": "Create a 2-by-2 matrix and use it as the exponent for a scalar.Compute C by first finding the eigenvalues D and eigenvectors V of the matrix B.Next, use the formula 2^B = V*2^D/V to compute the power."
 },
 {
    "code": "X = sqrtm(A)",
    "comment": "it returns the principal square root of the matrix A, that is, X*X = A."
 },
 {
    "code": "[X,residual] = sqrtm(A)",
    "comment": "it also returns the residual, residual = norm(A-X^2,1)/norm(A,1). "
 },
 {
    "code": "[X,alpha,condx] = sqrtm(A)",
    "comment": "it returns stability factor alpha and an estimate of the matrix square root condition number of X in 1-norm, condx. "
 },
 {
    "code": "A = [5 -4 1 0 0; -4 6 -4 1 0; 1 -4 6 -4 1; 0 1 -4 6 -4; 0 0 1 -4 6] \n  X = round(sqrtm(A))",
    "comment": "Create a matrix representation of the fourth difference operator, A. This matrix is symmetric and positive definite.Calculate the unique positive definite square root of A using sqrtm. X is the matrix representation of the second difference operator."
 },
 {
    "code": "Y = expm(X)",
    "comment": "it computes the matrix exponential of X. Although it is not computed this way, if X has a full set of eigenvectors V with corresponding eigenvalues D, then [V,D] = eig(X) and expm(X) = V*diag(exp(diag(D)))/V"
 },
 {
    "code": "A = [1 1 0; 0 0 2; 0 0 -1]; \n exp(A) \n expm(A)",
    "comment": "Compute and compare the exponential of A with the matrix exponential of A."
 },
 {
    "code": "L = logm(A)",
    "comment": "it is the principal matrix logarithm of A, the inverse of expm(A). "
 },
 {
    "code": "A = [1 1 0; 0 0 2; 0 0 -1]; \n Y = expm(A) \n P = logm(Y) \n Q = log(A)",
    "comment": "Calculate the matrix exponential of a matrix, A.Calculate the matrix logarithm of Y to reproduce the original matrix, A.log(A) involves taking the logarithm of zero, so it produces inferior results."
 },
 {
    "code": "C = cross(A,B)",
    "comment": "it returns the cross product of A and B."
 },
 {
    "code": "C = cross(A,B,dim)",
    "comment": "it evaluates the cross product of arrays A and B along dimension, dim. A and B must have the same size, and both size(A,dim) and size(B,dim) must be 3. The dim input is a positive integer scalar."
 },
 {
    "code": "A = [4 -2 1]; \n B = [1 -1 3]; \n C = cross(A,B) \n dot(C,A)==0 & dot(C,B)==0",
    "comment": "Create two 3-D vectors.Find the cross product of A and B. The result, C, is a vector that is perpendicular to both A and B.Use dot products to verify that C is perpendicular to A and B."
 },
 {
    "code": "A = randi(15,3,5) \n  B = randi(25,3,5) \n  C = cross(A,B)",
    "comment": "Create two matrices containing random integers.Find the cross product of A and B."
 },
 {
    "code": "A = randi(10,3,3,3); \n B = randi(25,3,3,3); \n C = cross(A,B,2) \n D = cross(A,B,3)",
    "comment": "Create two 3-by-3-by-3 multidimensional arrays of random integers.Find the cross product of A and B, treating the rows as vectors.Find the cross product of A and B along the third dimension (dim = 3)."
 },
 {
    "code": "C = dot(A,B)",
    "comment": "it returns the scalar dot product of A and B."
 },
 {
    "code": "C = dot(A,B,dim)",
    "comment": "it evaluates the dot product of A and B along dimension, dim. The dim input is a positive integer scalar."
 },
 {
    "code": "A = [4 -1 2]; \n B = [2 -2 -1]; \n C = dot(A,B)",
    "comment": "Create two simple, three-element vectors.Calculate the dot product of A and B."
 },
 {
    "code": "A = [1+i 1-i -1+i -1-i]; \n B = [3-4i 6-2i 1+2i 4+3i]; \n C = dot(A,B) \n D = dot(A,A)",
    "comment": "Create two complex vectors.Calculate the dot product of A and B.Find the inner product of A with itself."
 },
 {
    "code": "A = [1 2 3;4 5 6;7 8 9]; \n B = [9 8 7;6 5 4;3 2 1]; \n C = dot(A,B) \n D = dot(A,B,2)",
    "comment": "Create two matrices.Find the dot product of A and B.Find the dot product of A and B, treating the rows as vectors."
 },
 {
    "code": "A = cat(3,[1 1;1 1],[2 3;4 5],[6 7;8 9]) \n  B = cat(3,[2 2;2 2],[10 11;12 13],[14 15; 16 17]) \n  C = dot(A,B,3)",
    "comment": "Create two multidimensional arrays.Calculate the dot product of A and B along the third dimension (dim = 3)."
 },
 {
    "code": "B = bandwidth(A,type)",
    "comment": "it returns the bandwidth of matrix A specified by type. Specify type as 'lower' for the lower bandwidth, or 'upper' for the upper bandwidth."
 },
 {
    "code": "A = tril(magic(6)) \n  B = bandwidth(A,'lower') \n  B = bandwidth(A,'upper')",
    "comment": "Create a 6-by-6 lower triangular matrix.Find the lower bandwidth of A by specifying type as 'lower'. The result is 5 since every diagonal below the main diagonal has nonzero elements.Find the upper bandwidth of A by specifying type as 'upper'. The result is 0 since there are no nonzero elements above the main diagonal."
 },
 {
    "code": "B = kron(speye(25),ones(4)); \n  full(B(1:10,1:10)) \n  [lower,upper] = bandwidth(B)",
    "comment": "Create a 100-by-100 sparse block matrix.View a 10-by-10 section of elements from the top left of B.Find both the lower and upper bandwidths of B by specifying two output arguments."
 },
 {
    "code": "L = tril(A)",
    "comment": "it returns the lower triangular portion of matrix A."
 },
 {
    "code": "L = tril(A,k)",
    "comment": "it returns the elements on and below the kth diagonal of A."
 },
 {
    "code": "A = ones(4) \n  B = tril(A) \n  C = tril(A,-1)",
    "comment": "Create a 4-by-4 matrix of ones. Extract the lower triangular portion.Extract only the elements below the main diagonal."
 },
 {
    "code": "U = triu(A)",
    "comment": "it returns the upper triangular portion of matrix A."
 },
 {
    "code": "U = triu(A,k)",
    "comment": "it returns the elements on and above the kth diagonal of A."
 },
 {
    "code": "A = ones(4) \n  B = triu(A) \n  C = triu(A,1)",
    "comment": "Create a 4-by-4 matrix of ones. Extract the upper triangular portion.Extract only the elements above the main diagonal."
 },
 {
    "code": "tf = isbanded(A,lower,upper)",
    "comment": "it returns logical 1 (true) if matrix A is within the specified lower bandwidth, lower, and upper bandwidth, upper; otherwise, it returns logical 0 (false)."
 },
 {
    "code": "A = [2 3 0 0 0 ; 1 -2 -3 0 0; 0 -1 2 3 0 ; 0 0 1 -2 -3; 0 0 0 -1 2] \n  isbanded(A,1,1) \n  isbanded(A,0,1)",
    "comment": "Create a 5-by-5 square matrix with nonzero diagonals above and below the main diagonal.Specify both bandwidths, lower and upper, as 1 to test if A is tridiagonal.Test if A has nonzero elements below the main diagonal by specifying lower as 0."
 },
 {
    "code": "A = [1 0 0 0 0; 2 1 0 0 0; 3 2 1 0 0] \n  isbanded(A,2,0)",
    "comment": "Create a 3-by-5 matrix.Test if A has nonzero elements above the main diagonal."
 },
 {
    "code": "B = kron(speye(25),ones(4)); \n  isbanded(B,1,1) \n  isbanded(B,3,3)",
    "comment": "Create a 100-by-100 sparse block matrix.Test if B has a lower and upper bandwidth of 1.Test if B has a lower and upper bandwidth of 3."
 },
 {
    "code": "tf = isdiag(A)",
    "comment": "it returns logical 1 (true) if A is a diagonal matrix; otherwise, it returns logical 0 (false)."
 },
 {
    "code": "I = eye(4) \n  isdiag(I)",
    "comment": "Create a 4-by-4 identity matrix.Test to see if the matrix is diagonal."
 },
 {
    "code": "A = 3*eye(4) + diag([2 2 2],1) \n  isdiag(A) \n  B = diag(diag(A)); \n  isdiag(B)",
    "comment": "Create a matrix with nonzero elements on the main and first diagonals.Test to see if the matrix is diagonal.Create a new matrix, B, from the main diagonal elements of A.Test to see if B is a diagonal matrix."
 },
 {
    "code": "tf = ishermitian(A)",
    "comment": "it returns logical 1 (true) if square matrix A is Hermitian; otherwise, it returns logical 0 (false)."
 },
 {
    "code": "tf = ishermitian(A,skewOption)",
    "comment": "it specifies the type of the test. Specify skewOption as 'skew' to determine if A is skew-Hermitian."
 },
 {
    "code": "A = [1 0 1i; 0 1 0; 1i 0 1] \n  tf = ishermitian(A) \n  A(3,1) = -1i; \n  tf = ishermitian(A)",
    "comment": "Create a 3-by-3 matrix.Test whether the matrix is Hermitian.Change the element in A(3,1) to be -1i.Determine if the modified matrix is Hermitian."
 },
 {
    "code": "A = [-1i -1 1-i;1 -1i -1;-1-i 1 -1i] \n  tf = ishermitian(A,'skew')",
    "comment": "Create a 3-by-3 matrix.Specify skewOption as 'skew' to determine whether the matrix is skew-Hermitian."
 },
 {
    "code": "tf = issymmetric(A)",
    "comment": "it returns logical 1 (true) if square matrix A is symmetric; otherwise, it returns logical 0 (false)."
 },
 {
    "code": "tf = issymmetric(A,skewOption)",
    "comment": "it specifies the type of the test. Specify skewOption as 'skew' to determine if A is skew-symmetric."
 },
 {
    "code": "A = [1 0 1i; 0 1 0;-1i 0 1] \n  tf = issymmetric(A) \n  A(3,1) = 1i; \n  tf = issymmetric(A)",
    "comment": "Create a 3-by-3 matrix.Test whether the matrix is symmetric.Change the element in A(3,1) to be 1i.Determine whether the modified matrix is symmetric."
 },
 {
    "code": "A = [0 1 -2 5; -1 0 3 -4; 2 -3 0 6; -5 4 -6 0] \n  tf = issymmetric(A,'skew')",
    "comment": "Create a 4-by-4 matrix.Specify skewOption as 'skew' to determine whether the matrix is skew-symmetric."
 },
 {
    "code": "tf = istril(A)",
    "comment": "it returns logical 1 (true) if A is a lower triangular matrix; otherwise, it returns logical 0 (false)."
 },
 {
    "code": "D = tril(magic(5)) \n  istril(D)",
    "comment": "Create a 5-by-5 matrix.Test D to see if it is lower triangular."
 },
 {
    "code": "Z = zeros(5); \n  istril(Z)",
    "comment": "Create a 5-by-5 matrix of zeros.Test Z to see if it is lower triangular."
 },
 {
    "code": "tf = istriu(A)",
    "comment": "it returns logical 1 (true) if A is an upper triangular matrix; otherwise, it returns logical 0 (false)."
 },
 {
    "code": "A = triu(magic(5)) \n  istriu(A)",
    "comment": "Create a 5-by-5 matrix.Test A to see if it is upper triangular."
 },
 {
    "code": "Z = zeros(5); \n  istriu(Z)",
    "comment": "Create a 5-by-5 matrix of zeros.Test Z to see if it is upper triangular."
 },
 {
    "code": "d = det(A)",
    "comment": "returns the determinant of square matrix A."
 },
 {
    "code": "A = [1 -2 4; -5 2 0; 1 0 3] \n  d = det(A)",
    "comment": "Create a 3-by-3 square matrix, A.Calculate the determinant of A."
 },
 {
    "code": "A = diag([24 46 64 78 88 94 96 94 88 78 64 46 24]); \n S = diag([-13 -24 -33 -40 -45 -48 -49 -48 -45 -40 -33 -24],1); \n A = A + S + rot90(S,2); \n spy(A) \n d = det(A)",
    "comment": "Create a 13-by-13 diagonally dominant singular matrix A and view the pattern of nonzero elements.Calculate the determinant of A."
 },
 {
    "code": "Z = null(A)",
    "comment": "returns an orthonormal basis for the null space of A."
 },
 {
    "code": "Z = null(A,tol)",
    "comment": "also specifies a tolerance. Singular values of A less than tol are treated as zero, which can affect the number of columns in Z."
 },
 {
    "code": "Z = null(A,\"rational\")",
    "comment": "returns a rational basis for the null space of A that is typically not orthonormal. If A is a small matrix with small integer elements, then the elements of Z are ratios of small integers. This method is numerically less accurate than null(A)."
 },
 {
    "code": "A = ones(3) \n  x1 = null(A) \n  norm(A*x1)",
    "comment": "Create a 3-by-3 matrix of ones. This matrix is rank deficient, with two of the singular values being equal to zero.Calculate an orthonormal basis for the null space of A. Confirm that Ax=b within roundoff error."
 },
 {
    "code": "k = rank(A)",
    "comment": "returns the rank of matrix A."
 },
 {
    "code": "k = rank(A,tol)",
    "comment": "specifies a different tolerance to use in the rank computation. The rank is computed as the number of singular values of A that are larger than tol."
 },
 {
    "code": "A = [3 2 4; -1 1 2; 9 5 10] \n  rank(A) \n  size(A,2)",
    "comment": "Create a 3-by-3 matrix. The values in the third column are twice as large as those in the second column.Calculate the rank of the matrix. If the matrix is full rank, then the rank is equal to the number of columns, size(A,2)."
 },
 {
    "code": "A = [10 0 0 0; 0 25 0 0; 0 0 34 0; 0 0 0 1e-15] \n  rank(A) \n  rank(A,1e-16)",
    "comment": "Create a 4-by-4 diagonal matrix. The diagonal has one small value equal to 1e-15.Calculate the rank of the matrix.Calculate the rank of the matrix again, but specify a tolerance of 1e-16."
 },
 {
    "code": "R = rref(A)",
    "comment": "returns the reduced row echelon form of A using Gauss-Jordan elimination with partial pivoting."
 },
 {
    "code": "R = rref(A,tol)",
    "comment": "specifies a pivot tolerance that the algorithm uses to determine negligible columns."
 },
 {
    "code": "[R,p] = rref(A)",
    "comment": "also returns the nonzero pivots p."
 },
 {
    "code": "A = magic(3) \n  RA = rref(A) \n  B = magic(4) \n  [RB,p] = rref(B)",
    "comment": "Create a matrix and calculate the reduced row echelon form. In this form, the matrix has leading 1s in the pivot position of each column.Now, calculate the reduced row echelon form of the 4-by-4 magic square matrix. Specify two outputs to return the nonzero pivot columns. Since this matrix is rank deficient, the result is not an identity matrix"
 },
 {
    "code": "A = magic(3); \n A(:,4) = [1; 1; 1] \n R = rref(A) \n x = R(:,end) \n A = [magic(3) eye(3)] \n R = rref(A) \n inv_A = R(:,4:end)",
    "comment": "Create a 3-by-3 magic square matrix. Add an additional column to the end of the matrix. This augmented matrix represents a linear system Ax=b, with the extra column corresponding to b.Calculate the reduced row echelon form of A. Index into R to extract the entries in the extra (augmented) column, which contains the solution to the linear system.Create a similar magic square matrix, but this time append an identity matrix of the same size to the end columns.Calculate the reduced row echelon form of A. In this form the extra columns contain the inverse matrix for the 3-by-3 magic square matrix."
 },
 {
    "code": "A = [1  1  5; \n      2  1  8; \n      1  2  7; \n     -1  1 -1]; \n b = [6 8 10 2]'; \n M = [A b]; \n R = rref(M)",
    "comment": "Consider a linear system of equations with four equations and three unknowns.x1+x2+5x3=6 , 2x1+x2+8x3=8 , x1+2x2+7x3=10 , x1+x2x3=2. Create an augmented matrix that represents the system of equations."
 },
 {
    "code": "X = rand",
    "comment": "returns a random scalar drawn from the uniform distribution in the interval (0,1)."
 },
 {
    "code": "X = rand(n)",
    "comment": "returns an n-by-n matrix of uniformly distributed random numbers."
 },
 {
    "code": "X = rand(sz1,...,szN)",
    "comment": "returns an sz1-by-...-by-szN array of random numbers where sz1,...,szN indicate the size of each dimension. For example, rand(3,4) returns a 3-by-4 matrix."
 },
 {
    "code": "X = rand(sz)",
    "comment": "returns an array of random numbers where size vector sz defines size(X). For example, rand([3 4]) returns a 3-by-4 matrix."
 },
 {
    "code": "X = rand(___,typename)",
    "comment": "returns an array of random numbers of data type typename. The typename input can be either \"single\" or \"double\". You can use any of the input arguments in the previous syntaxes."
 },
 {
    "code": "X = rand(___,\"like\",p)",
    "comment": "returns an array of random numbers like p; that is, of the same data type and complexity (real or complex) as p. You can specify either typename or \"like\", but not both."
 },
 {
    "code": "X = rand(s,___)",
    "comment": "generates numbers from random number stream s instead of the default global stream. To create a stream, use RandStream. You can specify s followed by any of the input argument combinations in previous syntaxes."
 },
 {
    "code": "r = rand(5)",
    "comment": "Generate a 5-by-5 matrix of uniformly distributed random numbers between 0 and 1."
 },
 {
    "code": "r = -5 + (5+5)*rand(10,1)",
    "comment": "Generate a 10-by-1 column vector of uniformly distributed numbers in the interval (-5,5)."
 },
 {
    "code": "r = randi([10 50],1,5)",
    "comment": "Use the randi function (instead of rand) to generate 5 random integers from the uniform distribution between 10 and 50."
 },
 {
    "code": "s = rng; \n r = rand(1,5) \n rng(s); \n r1 = rand(1,5)",
    "comment": "Save the current state of the random number generator and create a 1-by-5 vector of random numbers.Restore the state of the random number generator to s, and then create a new 1-by-5 vector of random numbers. The values are the same as before."
 },
 {
    "code": "X = rand([3,2,3])",
    "comment": "Create a 3-by-2-by-3 array of random numbers."
 },
 {
    "code": "r = rand(1,4,\"single\") \n  class(r)",
    "comment": "Create a 1-by-4 vector of random numbers whose elements are single precision."
 },
 {
    "code": "A = [3 2; -2 1]; \n sz = size(A); \n X = rand(sz) \n X = rand(size(A));",
    "comment": "Create a matrix of uniformly distributed random numbers with the same size as an existing array.It is a common pattern to combine the previous two lines of code into a single line:"
 },
 {
    "code": "p = single([3 2; -2 1]); \n  X = rand(size(p),\"like\",p) \n class(X)",
    "comment": "Create a 2-by-2 matrix of single-precision random numbers.Create an array of random numbers that is the same size and data type as p."
 },
 {
    "code": "a = rand(10,1,\"like\",1i)",
    "comment": "Generate 10 random complex numbers from the uniform distribution over a square domain with real and imaginary parts in the interval (0,1)."
 },
 {
    "code": "X = randn",
    "comment": "returns a random scalar drawn from the standard normal distribution."
 },
 {
    "code": "X = randn(n)",
    "comment": "returns an n-by-n matrix of normally distributed random numbers."
 },
 {
    "code": "X = randn(sz1,...,szN)",
    "comment": "returns an sz1-by-...-by-szN array of random numbers where sz1,...,szN indicate the size of each dimension. For example, randn(3,4) returns a 3-by-4 matrix."
 },
 {
    "code": "X = randn(sz)",
    "comment": "returns an array of random numbers where size vector sz defines size(X). For example, randn([3 4]) returns a 3-by-4 matrix."
 },
 {
    "code": "r = randn(5)",
    "comment": "Generate a 5-by-5 matrix of normally distributed random numbers."
 },
 {
    "code": "mu = [1 2]; \n sigma = [1 0.5; 0.5 2]; \n R = chol(sigma); \n z = repmat(mu,10,1) + randn(10,2)*R",
    "comment": "Generate values from a bivariate normal distribution with specified mean vector and covariance matrix."
 },
 {
    "code": "s = rng; \n r = randn(1,5) \n rng(s); \n r1 = randn(1,5)",
    "comment": "Save the current state of the random number generator and create a 1-by-5 vector of random numbers.Restore the state of the random number generator to s, and then create a new 1-by-5 vector of random numbers. The values are the same as before."
 },
 {
    "code": "X = randn([3,2,3])",
    "comment": "Create a 3-by-2-by-3 array of random numbers."
 },
 {
    "code": "r = randn(1,4,\"single\") \n  class(r)",
    "comment": "Create a 1-by-4 vector of random numbers whose elements are single precision."
 },
 {
    "code": "A = [3 2; -2 1]; \n sz = size(A); \n X = randn(sz) \n X = randn(size(A));",
    "comment": "Create a matrix of normally distributed random numbers with the same size as an existing array.It is a common pattern to combine the previous two lines of code into a single line."
 },
 {
    "code": "p = single([3 2; -2 1]); \n  X = randn(size(p),\"like\",p) \n  class(X)",
    "comment": "Create a 2-by-2 matrix of single-precision random numbers.Create an array of random numbers that is the same size and data type as p."
 },
 {
    "code": "a = randn(10,1,\"like\",1i)",
    "comment": "Generate 10 random complex numbers from the standard complex normal distribution."
 },
 {
    "code": "p = randperm(n)",
    "comment": "returns a row vector containing a random permutation of the integers from 1 to n without repeating elements."
 },
 {
    "code": "p = randperm(n,k)",
    "comment": "returns a row vector containing k unique integers selected randomly from 1 to n."
 },
 {
    "code": "p = randperm(s,___)",
    "comment": "generates a random permutation of integers from random number stream s instead of the default global stream. To create a stream, use RandStream. Specify s followed by any of the argument combinations in previous syntaxes."
 },
 {
    "code": "r = randperm(6)",
    "comment": "Generate a random permutation of the integers from 1 to 6. The input to randperm indicates the largest integer in the sampling interval (the smallest integer in the interval is 1)."
 },
 {
    "code": "r1 = randperm(8,4) \n  r2 = randperm(8,4)",
    "comment": "Generate a random permutation of four unique integers (without repeating elements) selected randomly from the integers 1 to 8.Generate another random permutation of four unique integers."
 },
 {
    "code": "s = rng; \n r = randperm(8) \n rng(s) \n r1 = randperm(8)",
    "comment": "Save the current state of the random number generator and create a random permutation of the integers from 1 to 8.Restore the state of the random number generator to s, and then create a new random permutation of the integers from 1 to 8. The permutation is the same as before."
 },
 {
    "code": "x = 0:pi/4:2*pi;  \n v = sin(x); \n xq = 0:pi/16:2*pi; \n figure \n vq1 = interp1(x,v,xq); \n plot(x,v,'o',xq,vq1,':.'); \n xlim([0 2*pi]); \n title('(Default) Linear Interpolation'); \n figure \n vq2 = interp1(x,v,xq,'spline'); \n plot(x,v,'o',xq,vq2,':.'); \n xlim([0 2*pi]); \n title('Spline Interpolation');",
    "comment": "Define the sample points, x, and corresponding sample values, v.Define the query points to be a finer sampling over the range of x.Interpolate the function at the query points and plot the result.Now evaluate v at the same points using the 'spline' method."
 },
 {
    "code": "v = [0  1.41  2  1.41  0  -1.41  -2  -1.41 0]; \n  xq = 1.5:8.5; \n  vq = interp1(v,xq); \n  figure \n plot((1:9),v,'o',xq,vq,'*'); \n legend('v','vq');",
    "comment": "Define a set of function values.Define a set of query points that fall between the default points, 1:9. In this case, the default points are 1:9 because v contains 9 values.Evaluate v at xq.Plot the result."
 },
 {
    "code": "x = 1:10; \n  v = (5*x)+(x.^2*1i); \n  xq = 1:0.25:10; \n  vq = interp1(x,v,xq); \n  figure \n plot(x,real(v),'*r',xq,real(vq),'-r'); \n hold on \n plot(x,imag(v),'*b',xq,imag(vq),'-b');",
    "comment": "Define a set of sample points.Define the values of the function, v(x)=5x+ix^2, at the sample points.Define the query points to be a finer sampling over the range of x.Interpolate v at the query points.Plot the real part of the result in red and the imaginary part in blue."
 },
 {
    "code": "x = [1 2 3 4 5]; \n v = [12 16 31 10 6]; \n xq = [0 0.5 1.5 5.5 6]; \n vq1 = interp1(x,v,xq,'pchip') \n vq2 = interp1(x,v,xq,'linear') \n vq3 = interp1(x,v,xq,'linear','extrap')",
    "comment": "Define the sample points, x, and corresponding sample values, v.Specify the query points, xq, that extend beyond the domain of x.Evaluate v at xq using the 'pchip' method.Next, evaluate v at xq using the 'linear' method.Now, use the 'linear' method with the 'extrap' option."
 },
 {
    "code": "x = [-3 -2 -1 0 1 2 3]; \n v = 3*x.^2; \n xq = [-4 -2.5 -0.5 0.5 2.5 4]; \n vq = interp1(x,v,xq,'pchip',27)",
    "comment": "Define the sample points, x, and corresponding sample values, v.Specify the query points, xq, that extend beyond the domain of x.Now evaluate v at xq using the 'pchip' method and assign any values outside the domain of x to the value, 27."
 },
 {
    "code": "x = (-5:5)'; \n  v1 = x.^2; \n v2 = 2*x.^2 + 2; \n v3 = 3*x.^2 + 4; \n v = [v1 v2 v3]; \n xq = -5:0.1:5; \n vq = interp1(x,v,xq,'pchip'); \n figure \n plot(x,v,'o',xq,vq); \n h = gca; \n h.XTick = -5:5;",
    "comment": "Define the sample points.Sample three different parabolic functions at the points defined in x.Create matrix v, whose columns are the vectors, v1, v2, and v3.Define a set of query points, xq, to be a finer sampling over the range of x.Evaluate all three functions at xq and plot the results."
 },
 {
    "code": "[X,Y] = meshgrid(-3:3); \n V = peaks(X,Y); \n figure \n surf(X,Y,V) \n title('Original Sampling'); \n [Xq,Yq] = meshgrid(-3:0.25:3); \n Vq = interp2(X,Y,V,Xq,Yq); \n figure \n surf(Xq,Yq,Vq); \n title('Linear Interpolation Using Finer Grid');",
    "comment": "Coarsely sample the peaks function.Plot the coarse sampling.Create the query grid with spacing of 0.25.Interpolate at the query points.Plot the result."
 },
 {
    "code": "[X,Y] = meshgrid(-3:3); \n V = peaks(7); \n figure \n surf(X,Y,V) \n title('Original Sampling'); \n [Xq,Yq] = meshgrid(-3:0.25:3); \n Vq = interp2(X,Y,V,Xq,Yq,'cubic'); \n figure \n surf(Xq,Yq,Vq); \n title('Cubic Interpolation Over Finer Grid'); \n ",
    "comment": "Coarsely sample the peaks function.Plot the coarse sampling.Create the query grid with spacing of 0.25.Interpolate at the query points, and specify cubic interpolation.Plot the result."
 },
 {
    "code": "fun = @sin; \n x1 = 0; \n x2 = 2*pi; \n x = fminbnd(fun,x1,x2)",
    "comment": "Find the point where the sin(x) function takes its minimum in the range 0<x<2."
 },
 {
    "code": "a = 9/7; \n fun = @(x)sin(x-a); \n x = fminbnd(fun,1,2*pi)",
    "comment": "Minimize a function when there is an extra parameter. The function sin(xa) has a minimum that depends on the value of the parameter a. Create an anonymous function of x that includes the value of the parameter a. Minimize this function over the interval 0<x<2."
 },
 {
    "code": "fun = @sin; \n x1 = 0; \n x2 = 2*pi; \n options = optimset('Display','iter'); \n x = fminbnd(fun,x1,x2,options)",
    "comment": "Monitor the steps fminbnd takes to minimize the sin(x) function for 0<x<2."
 },
 {
    "code": "fun = @sin; \n [x,fval] = fminbnd(fun,1,2*pi)",
    "comment": "Find the location of the minimum of sin(x) and the value of the minimum for 0<x<2."
 },
 {
    "code": "fun = @sin; \n x1 = 0; \n x2 = 2*pi; \n options = optimset('PlotFcns',@optimplotfval); \n [x,fval,exitflag,output] = fminbnd(fun,x1,x2,options)",
    "comment": "Return all information about the fminbnd solution process by requesting all outputs. Also, monitor the solution process using a plot function."
 },
 {
    "code": "fun = @sin; \n x0 = 3; \n x = fzero(fun,x0)",
    "comment": "Calculate  by finding the zero of the sine function near 3."
 },
 {
    "code": "fun = @cos; \n x0 = [1 2]; \n x = fzero(fun,x0)",
    "comment": "Find the zero of cosine between 1 and 2."
 },
 {
    "code": "x = 0:pi/100:2*pi; \n y = sin(x); \n plot(x,y)",
    "comment": "Create x as a vector of linearly spaced values between 0 and 2. Use an increment of /100 between the values. Create y as sine values of x. Create a line plot of the data."
 },
 {
    "code": "x = linspace(-2*pi,2*pi); \n y1 = sin(x); \n y2 = cos(x); \n figure \n plot(x,y1,x,y2)",
    "comment": "Define x as 100 linearly spaced values between 2 and 2. Define y1 and y2 as sine and cosine values of x. Create a line plot of both sets of data."
 },
 {
    "code": "Y = magic(4) \n  figure \n plot(Y)",
    "comment": "Define Y as the 4-by-4 matrix returned by the magic function.Create a 2-D line plot of Y. MATLAB plots each matrix column as a separate line."
 },
 {
    "code": "x = 0:pi/100:2*pi; \n y1 = sin(x); \n y2 = sin(x-0.25); \n y3 = sin(x-0.5); \n figure \n plot(x,y1,x,y2,'--',x,y3,':')",
    "comment": "Plot three sine curves with a small phase shift between each line. Use the default line style for the first line. Specify a dashed line style for the second line and a dotted line style for the third line."
 },
 {
    "code": "x = 0:pi/10:2*pi; \n y1 = sin(x); \n y2 = sin(x-0.25); \n y3 = sin(x-0.5); \n figure \n plot(x,y1,'g',x,y2,'b--o',x,y3,'c*')",
    "comment": "Plot three sine curves with a small phase shift between each line. Use a green line with no markers for the first sine curve. Use a blue dashed line with circle markers for the second sine curve. Use only cyan star markers for the third sine curve."
 },
 {
    "code": "x = linspace(0,10); \n y = sin(x); \n plot(x,y,'-o','MarkerIndices',1:5:length(y))",
    "comment": "Create a line plot and display markers at every fifth data point by specifying a marker symbol and setting the MarkerIndices property as a name-value pair."
 },
 {
    "code": "x = -pi:pi/10:pi; \n y = tan(sin(x)) - sin(tan(x)); \n  \n figure \n plot(x,y,'--gs',... \n     'LineWidth',2,... \n     'MarkerSize',10,... \n     'MarkerEdgeColor','b',... \n     'MarkerFaceColor',[0.5,0.5,0.5])",
    "comment": "Create a line plot and use the LineSpec option to specify a dashed green line with square markers. Use Name,Value pairs to specify the line width, marker size, and marker colors. Set the marker edge color to blue and set the marker face color using an RGB color value."
 },
 {
    "code": "x = linspace(0,10,150); \n y = cos(5*x); \n figure \n plot(x,y,'Color',[0,0.7,0.9]) \n title('2-D Line Plot') \n xlabel('x') \n ylabel('cos(5x)')",
    "comment": "Use the linspace function to define x as a vector of 150 values between 0 and 10. Define y as cosine values of x.Create a 2-D line plot of the cosine curve. Change the line color to a shade of blue-green using an RGB color value. Add a title and axis labels to the graph using the title, xlabel, and ylabel functions."
 },
 {
    "code": "t = 0:seconds(30):minutes(3); \n y = rand(1,7); \n plot(t,y,'DurationTickFormat','mm:ss')",
    "comment": "Define t as seven linearly spaced duration values between 0 and 3 minutes. Plot random data and specify the format of the duration tick marks using the 'DurationTickFormat' name-value pair argument."
 },
 {
    "code": "% Create data and 2-by-1 tiled chart layout \n x = linspace(0,3); \n y1 = sin(5*x); \n y2 = sin(15*x); \n tiledlayout(2,1) \n ax1 = nexttile; \n plot(ax1,x,y1) \n title(ax1,'Top Plot') \n ylabel(ax1,'sin(5x)') \n ax2 = nexttile; \n plot(ax2,x,y2) \n title(ax2,'Bottom Plot') \n ylabel(ax2,'sin(15x)')",
    "comment": "you can display a tiling of plots using the tiledlayout and nexttile functions. Call the tiledlayout function to create a 2-by-1 tiled chart layout. Call the nexttile function to create an axes object and return the object as ax1. Create the top plot by passing ax1 to the plot function. Add a title and y-axis label to the plot by passing the axes to the title and ylabel functions. Repeat the process to create the bottom plot."
 },
 {
    "code": "x = linspace(-2*pi,2*pi); \n y1 = sin(x); \n y2 = cos(x); \n p = plot(x,y1,x,y2);",
    "comment": "Define x as 100 linearly spaced values between 2 and 2. Define y1 and y2 as sine and cosine values of x. Create a line plot of both sets of data and return the two chart lines in p."
 },
 {
    "code": "r = 2; \n xc = 4; \n yc = 3; \n theta = linspace(0,2*pi); \n x = r*cos(theta) + xc; \n y = r*sin(theta) + yc; \n plot(x,y) \n axis equal",
    "comment": "Plot a circle centered at the point (4,3) with a radius equal to 2. Use axis equal to use equal data units along each coordinate direction."
 },
 {
    "code": "t = 0:pi/50:10*pi; \n st = sin(t); \n ct = cos(t); \n plot3(st,ct,t)",
    "comment": "Define t as a vector of values between 0 and 10. Define st and ct as vectors of sine and cosine values. Then plot st, ct, and t."
 },
 {
    "code": "t = 0:pi/500:pi; \n xt1 = sin(t).*cos(10*t); \n yt1 = sin(t).*sin(10*t); \n zt1 = cos(t); \n xt2 = sin(t).*cos(12*t); \n yt2 = sin(t).*sin(12*t); \n zt2 = cos(t); \n plot3(xt1,yt1,zt1,xt2,yt2,zt2)",
    "comment": "Create two sets of x-, y-, and z-coordinates.Call the plot3 function, and specify consecutive XYZ triplets."
 },
 {
    "code": "t = 0:pi/500:pi; \n X(1,:) = sin(t).*cos(10*t); \n X(2,:) = sin(t).*cos(12*t); \n X(3,:) = sin(t).*cos(20*t); \n Y(1,:) = sin(t).*sin(10*t); \n Y(2,:) = sin(t).*sin(12*t); \n Y(3,:) = sin(t).*sin(20*t); \n Z = cos(t); \n plot3(X,Y,Z)",
    "comment": "Create matrix X containing three rows of x-coordinates. Create matrix Y containing three rows of y-coordinates.Create matrix Z containing the z-coordinates for all three sets.Plot all three sets of coordinates on the same set of axes."
 },
 {
    "code": "t = 0:pi/500:40*pi; \n xt = (3 + cos(sqrt(32)*t)).*cos(t); \n yt = sin(sqrt(32) * t); \n zt = (3 + cos(sqrt(32)*t)).*sin(t); \n plot3(xt,yt,zt) \n axis equal \n xlabel('x(t)') \n ylabel('y(t)') \n zlabel('z(t)')",
    "comment": "Create vectors xt, yt, and zt.Plot the data, and use the axis equal command to space the tick units equally along each axis. Then specify the labels for each axis."
 },
 {
    "code": "t = 0:pi/20:10*pi; \n xt = sin(t); \n yt = cos(t); \n plot3(xt,yt,t,'o')",
    "comment": "Create vectors t, xt, and yt, and plot the points in those vectors using circular markers."
 },
 {
    "code": "t = 0:pi/20:10*pi; \n xt = sin(t); \n yt = cos(t); \n plot3(xt,yt,t,'-o','Color','b','MarkerSize',10,... \n     'MarkerFaceColor','#D9FFFF')",
    "comment": "Create vectors t, xt, and yt, and plot the points in those vectors as a blue line with 10-point circular markers. Use a hexadecimal color code to specify a light blue fill color for the markers."
 },
 {
    "code": "t = 0:pi/20:10*pi; \n xt1 = sin(t); \n yt1 = cos(t); \n xt2 = sin(2*t); \n yt2 = cos(2*t); \n plot3(xt1,yt1,t,xt2,yt2,t,'--')",
    "comment": "Create vector t. Then use t to calculate two sets of x and y values.Plot the two sets of values. Use the default line for the first set, and specify a dashed line for the second set."
 },
 {
    "code": "t = linspace(-10,10,1000); \n xt = exp(-t./10).*sin(5*t); \n yt = exp(-t./10).*cos(5*t); \n p = plot3(xt,yt,t);",
    "comment": "Create vectors t, xt, and yt, and plot the data in those vectors. Return the chart line in the output variable p."
 },
 {
    "code": "X = linspace(0,4*pi,40); \n Y = sin(X); \n figure \n stairs(Y)",
    "comment": "Create a stairstep plot of sine evaluated at 40 equally spaced values between 0 and 4."
 },
 {
    "code": "X = linspace(0,4*pi,50)'; \n Y = [0.5*cos(X), 2*cos(X)]; \n figure \n stairs(Y)",
    "comment": "Create a stairstep plot of two cosine functions evaluated at 50 equally spaced values between 0 and 4."
 },
 {
    "code": "X = linspace(0,4*pi,40); \n Y = sin(X); \n figure \n stairs(X,Y)",
    "comment": "Create a stairstep plot of a sine wave evaluated at equally spaced values between 0 and 4. Specify the set of x-values for the plot."
 },
 {
    "code": "X = linspace(0,4*pi,50)'; \n Y = [0.5*cos(X), 2*cos(X)]; \n figure \n stairs(X,Y)",
    "comment": "Create a stairstep plot of two cosine waves evaluated at equally spaced values between 0 and 4. Specify the set of x-values for the plot."
 },
 {
    "code": "x1 = linspace(0,2*pi)'; \n x2 = linspace(0,pi)'; \n X = [x1,x2]; \n Y = [sin(5*x1),exp(x2).*sin(5*x2)]; \n figure \n stairs(X,Y)",
    "comment": "Create a stairstep plot of two sine waves evaluated at different values. Specify a unique set of x-values for plotting each data series."
 },
 {
    "code": "X = linspace(0,4*pi,20); \n Y = sin(X); \n figure \n stairs(Y, '-.or')",
    "comment": "Create a stairstep plot and set the line style to a dot-dashed line, the marker symbol to circles, and the color to red."
 },
 {
    "code": "x = 1:10:100; \n y = [20 30 45 40 60 65 80 75 95 90]; \n err = 8*ones(size(y)); \n errorbar(x,y,err)",
    "comment": "Create vectors x and y. Plot y versus x. At each data point, display vertical error bars that are equal in length."
 },
 {
    "code": "x = 1:10:100; \n y = [20 30 45 40 60 65 80 75 95 90];  \n err = [5 8 2 9 3 3 8 3 9 3]; \n errorbar(x,y,err)",
    "comment": "Create a line plot with error bars at each data point. Vary the lengths of the error bars."
 },
 {
    "code": "x = 1:10:100; \n y = [20 30 45 40 60 65 80 75 95 90]; \n err = [1 3 5 3 5 3 6 4 3 3]; \n errorbar(x,y,err,'horizontal')",
    "comment": "Create a line plot with horizontal error bars at each data point."
 },
 {
    "code": "x = 1:10:100; \n y = [20 30 45 40 60 65 80 75 95 90]; \n err = [4 3 5 3 5 3 6 4 3 3]; \n errorbar(x,y,err,'both')",
    "comment": "Create a line plot with both vertical and horizontal error bars at each data point."
 },
 {
    "code": "x = 1:10:100; \n y = [20 30 45 40 60 65 80 75 95 90]; \n err = [4 3 5 3 5 3 6 4 3 3]; \n errorbar(x,y,err,\"both\",\"o\")",
    "comment": "Plot vectors y versus x. At each data point, display a circle marker with both vertical and horizontal error bars. Do not display the line that connects the data points by omitting the line style option for the linespec input argument."
 },
 {
    "code": "x = logspace(-1,2); \n y = 2.^x; \n loglog(x,y) \n grid on",
    "comment": "Define x as a vector of 50 logarithmically spaced numbers on the interval [10^1,10^2]. Define y as 2^x. Then plot x and y, and call the grid function to show the grid lines."
 },
 {
    "code": "x = logspace(-1,2); \n y1 = 10.^x; \n y2 = 1./10.^x; \n loglog(x,y1,x,y2) \n grid on",
    "comment": "Create a vector of x-coordinates and two vectors of y-coordinates. Plot two lines by passing comma-separated x-y pairs to loglog."
 },
 {
    "code": "x = logspace(-1,2,10000); \n y = 5 + 3*sin(x); \n loglog(x,y)",
    "comment": "Create a set of x- and y-coordinates and display them in a log-log plot."
 },
 {
    "code": "x = logspace(-1,2,20); \n y = 10.^x; \n loglog(x,y,'s','MarkerFaceColor',[0 0.447 0.741]) \n grid on",
    "comment": "Create a set of x- and y-coordinates and display them in a log-log plot. Specify the line style as 's' to display square markers without connecting lines. Specify the marker fill color as the RGB triplet [0 0.447 0.741], which corresponds to a dark shade of blue."
 },
 {
    "code": "x = logspace(-1,2,10000); \n y1 = 5 + 3*sin(x/4); \n y2 = 5 - 3*sin(x/4); \n loglog(x,y1,x,y2,'--') \n legend('Signal 1','Signal 2','Location','northwest')",
    "comment": "Create two sets of x- and y-coordinates and display them in a log-log plot. Display a legend in the upper left corner of the plot by calling the legend function and specifying the location as 'northwest'."
 },
 {
    "code": "y = [0.001 0.01 0.1 1 10 100]; \n loglog(y) \n grid on",
    "comment": "When you specify only one coordinate vector, loglog plots those coordinates against the values 1:length(y). For example, define y as a vector of 6 values between 0.001 and 100. Create a log-log plot of y."
 },
 {
    "code": "x = logspace(-1,2); \n y = x; \n semilogx(x,y) \n grid on",
    "comment": "Define x as a vector of logarithmically spaced values from 0.1 to 100, and define y as a copy of x. Create a linear-log plot of x and y, and call the grid function to show the grid lines."
 },
 {
    "code": "x = logspace(-1,2); \n y1 = x; \n y2 = -x; \n semilogx(x,y1,x,y2) \n grid on",
    "comment": "Create a vector of logarithmically spaced x-coordinates and two vectors of y-coordinates. Plot two lines by passing comma-separated x-y pairs to semilogx."
 },
 {
    "code": "f = logspace(1,5,100); \n v = linspace(-50,50,100); \n gain = (1-exp(5*(2.5*v.^2)./7500))/14; \n semilogx(f,gain) \n grid on",
    "comment": "Define f as a vector containing the frequencies from 10 Hz to 100,000 Hz. Define gain as a vector of power gain values in decibels. Then plot the gain values against frequency."
 },
 {
    "code": "x = logspace(-1,2,15); \n y = 12 + x; \n semilogx(x,y,'o','MarkerFaceColor',[0 0.447 0.741]) \n grid on",
    "comment": "Create a set of x- and y-coordinates and display them in a linear-log plot. Specify the line style as 'o' to display circular markers without connecting lines. Specify the marker fill color as the RGB triplet [0 0.447 0.741], which corresponds to a dark shade of blue."
 },
 {
    "code": "x = logspace(1,4,100); \n v = linspace(-50,50,100); \n y1 = 100*exp(-1*((v+5).^2)./200); \n y2 = 100*exp(-1*(v.^2)./200); \n semilogx(x,y1,x,y2,'--') \n legend('Measured','Estimated') \n grid on",
    "comment": "Create a vector of logarithmically spaced x-coordinates and two vectors of y-coordinates. Then plot two lines by passing comma-separated x-y pairs to semilogx. Display a legend by calling the legend function."
 },
 {
    "code": "y = [0 10 20 30 40]; \n semilogx(y) \n grid on",
    "comment": "When you specify only one coordinate vector, semilogx plots those coordinates against the values 1:length(y). For example, define y as a vector of 5 values between 0 and 40. Create a linear-log plot of y."
 },
 {
    "code": "x = 1:100; \n y = x.^2; \n semilogy(x,y) \n grid on",
    "comment": "Create a vector of x-coordinates and a vector of y-coordinates. Create a log-linear plot of x and y, and call the grid function to show the grid lines."
 },
 {
    "code": "x = 1:100; \n y1 = x.^2; \n y2 = x.^3; \n semilogy(x,y1,x,y2) \n grid on",
    "comment": "Create a vector of x-coordinates and two vectors of y-coordinates. Plot two lines by passing comma-separated x-y pairs to semilogy."
 },
 {
    "code": "P = 1000;  \n npayments = 240;   \n rate = 0.08/12;  \n mpayment = P*(rate*(1+rate)^npayments)/(((1+rate)^npayments) - 1); \n x = 1:240; \n y = x * mpayment; \n semilogy(x,y); \n grid on",
    "comment": "Define vector x as the installments on a 20 year loan. Define vector y as the cumulative cost of a $1000 loan with an interest rate of 8%. Plot the cumulative cost at each installment."
 },
 {
    "code": "x = linspace(1,1000,15); \n y = (1./x) * 10000; \n semilogy(x,y,'o','MarkerFaceColor',[0 0.447 0.741]) \n grid on",
    "comment": "Create a set of x- and y-coordinates and plot them in a log-linear plot. Specify the line style as 'o' to display circular markers without connecting lines. Specify the marker fill color as the RGB triplet [0 0.447 0.741], which corresponds to a dark shade of blue."
 },
 {
    "code": "fplot(@(x) sin(x))",
    "comment": "Plot sin(x) over the default x interval [-5 5]."
 },
 {
    "code": "xt = @(t) cos(3*t); \n yt = @(t) sin(2*t); \n fplot(xt,yt)",
    "comment": "Plot the parametric curve x=cos(3t) and y=sin(2t)."
 },
 {
    "code": "fp = fplot(@(x) sin(x))",
    "comment": "Plot sin(x) and assign the function line object to a variable."
 },
 {
    "code": "fplot(@sin,[-2*pi 2*pi]) \n grid on \n title('sin(x) from -2\\pi to 2\\pi') \n xlabel('x'); \n ylabel('y');",
    "comment": "Plot sin(x) from 2 to 2 using a function handle. Display the grid lines. Then, add a title and label the x-axis and y-axis."
 },
 {
    "code": "fimplicit(@(x,y) x.^2 - y.^2 - 1)",
    "comment": "Plot the hyperbola described by the function x^2y^21=0 over the default interval of [-5 5] for x and y."
 },
 {
    "code": "f = @(x,y) x.^2 + y.^2 - 3; \n fimplicit(f,[-3 0 -2 2])",
    "comment": "Plot the function x^2+y^23=0 over the intervals [-3 0] for x and [-2 2] for y."
 },
 {
    "code": "f1 = @(x,y) x.^2 + y.^2 - 1; \n fimplicit(f1,':r') \n hold on \n f2 = @(x,y) x.^2 + y.^2 - 2; \n fimplicit(f2,'--g','LineWidth',2) \n hold off",
    "comment": "Plot two circles centered at (0,0) with different radius values. For the first circle, use a dotted, red line. For the second circle, use a dashed, green line with a line width of 2 points."
 },
 {
    "code": "fp = fimplicit(@(x,y) y.*sin(x) + x.*cos(y) - 1)",
    "comment": "Plot the implicit function ysin(x)+xcos(y)1=0 and assign the implicit function line object to the variable fp."
 },
 {
    "code": "function numLIS = countLIS(nums) /n      n = length(nums); /n      lengths = ones(1, n); % Initialize lengths array to 1 /n      for i = 2:n /n          for j = 1:i-1 /n             if nums(i) > nums(j) /n                 lengths(i) = max(lengths(i), lengths(j) + 1); /n             end /n         end /n     end /n  /n     maxLen = max(lengths); % Find the length of the longest increasing subsequence /n  /n     % Calculate the number of longest increasing subsequences /n     numLIS = 0; /n     for i = 1:n /n         if lengths(i) == maxLen /n             numLIS = numLIS + 1; /n         end /n     end /n end /n ",
    "comment": "Number of Longest Increasing Subsequence in an array"
 },
 {
    "code": "function sum = addTwoNumbers(a, b) /n     sum = a + b; /n end /n ",
    "comment": "Add Two Numbers"
 },
 {
    "code": "function sum = sum(a, b) /n     sum = a + b; /n end",
    "comment": "sum of Two Numbers"
 },
{
    "code": "function difference = difference(a, b) /n     difference = a - b; /n end /n ",
    "comment": "subtract Two Numbers"
 },
 {
    "code": "function subtract = subtractTwoNumbers(a, b) /n     subtraction = a - b; /n end /n ",
    "comment": "subtract Two Numbers"
 },
 {
    "code": "function product = multiplyTwoNumbers(a, b) /n     product = a * b; /n end /n ",
    "comment": "multiplication of Two Numbers"
 },
 {
    "code": "function product = productoftwonumber(a, b) /n     product = a * b; /n end /n ",
    "comment": "multiplication of Two Numbers"
 },
 {
    "code": "function quotient = divideTwoNumbers(a, b) /n     quotient = a / b; /n end",
    "comment": "division of Two Numbers"
 },
 {
    "code": "function quotient = divideTwoNumbers(a, b) /n     quotient = a / b; /n end /n ",
    "comment": "divide Two Numbers"
 },
 {
    "code": "function quotient = divideTwoNumbers(a, b) /n     quotient = a / b; /n end /n ",
    "comment": "quotient of Two Numbers"
 },
  {
    "code": "function quotient = divideTwoNumbers(a, b) /n     quotient = a / b; /n end /n ",
    "comment": "division of Two Numbers"
 },
 {
    "code": "function remainder = calculateModulus(a, b) /n     remainder = mod(a, b); /n end /n ",
    "comment": "mod of Two Numbers"
 },
 {
    "code": "function remainder = calculateModulus(a, b) /n     remainder = mod(a, b); /n end /n ",
    "comment": "Remainder of Two Numbers"
 },
 {
    "code": "function remainder = calculateModulus(a, b) /n     remainder = mod(a, b); /n end",
    "comment": "modulus of Two Numbers"
 },
 {
    "code": "function reversed = reverseInteger(num) /n     numStr = num2str(num); /n     reversedStr = fliplr(numStr); /n     reversed = str2double(reversedStr); /n end /n ",
    "comment": "Reverse Integer"
 },
 {
    "code": "function isPalindrome = checkPalindrome(num) /n     numStr = num2str(num); /n     reversedStr = fliplr(numStr); /n     isPalindrome = strcmp(numStr, reversedStr); /n end /n ",
    "comment": "Palindrome Number"
 },
 {
    "code": "function romanNumeral = intToRoman(num) /n     romanChars = {'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'}; /n     romanValues = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]; /n  /n     romanNumeral = ''; /n     for i = 1:numel(romanValues) /n         while num >= romanValues(i) /n             romanNumeral = [romanNumeral, romanChars{i}]; /n             num = num - romanValues(i); /n         end /n     end /n end /n ",
    "comment": "Integer to Roman"
 },
 {
    "code": "function integer = romanToInt(romanNumeral) /n     romanChars = {'M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I'}; /n     romanValues = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]; /n  /n     integer = 0; /n     i = 1; /n     while ~isempty(romanNumeral) && i <= numel(romanValues) /n         while startsWith(romanNumeral, romanChars{i}) /n             integer = integer + romanValues(i); /n             romanNumeral(1:length(romanChars{i})) = []; /n         end /n         i = i + 1; /n     end /n end /n ",
    "comment": "Roman to Integer"
 },
 {
    "code": "function quotient = divideIntegers(dividend, divisor) /n     if divisor == 0 /n         error('Division by zero is not allowed.'); /n     end /n  /n     % Perform integer division /n     quotient = floor(dividend / divisor); /n end /n ",
    "comment": "Divide Two Integers"
 },
 {
    "code": "function result = multiplyStrings(str1, str2) /n     num1 = str2double(str1); /n     num2 = str2double(str2); /n     resultNum = num1 * num2; /n     result = num2str(resultNum); /n end /n ",
    "comment": "Multiply Strings"
 },
 {
    "code": "function result = myPow(x, n) /n     result = power(x, n); /n end /n ",
    "comment": "Pow(x, n)"
 },
 {
    "code": "function permutation = getPermutation(n, k) /n     if n <= 0 || k <= 0 /n         error('n and k must be positive integers.'); /n     end /n  /n     nums = 1:n; /n     permutation = ''; /n  /n     for i = n:-1:1 /n         factorial_i = factorial(i - 1); /n         index = ceil(k / factorial_i); /n         k = mod(k - 1, factorial_i) + 1; /n  /n         permutation = [permutation, num2str(nums(index))]; /n         nums(index) = []; /n     end /n end /n ",
    "comment": "Permutation Sequence"
 },
 {
    "code": "function numPaths = uniquePaths(m, n) /n     if m <= 0 || n <= 0 /n         error('m and n must be positive integers.'); /n     end /n grid = zeros(m, n); /n     grid(1, :) = 1; /n     grid(:, 1) = 1; /n     for i = 2:m /n         for j = 2:n /n             grid(i, j) = grid(i - 1, j) + grid(i, j - 1); /n         end /n     end /n     numPaths = grid(m, n); /n end /n ",
    "comment": "Unique Paths"
 },
 {
    "code": "function result = plusOne(digits) /n     n = length(digits); /n     carry = 1; /n  /n     for i = n:-1:1 /n         digits(i) = digits(i) + carry; /n         if digits(i) <= 9 /n             carry = 0; /n             break; /n         else /n             digits(i) = 0; /n         end /n     end /n  /n     if carry /n         result = [1, digits]; /n     else /n         result = digits; /n     end /n end /n ",
    "comment": "Plus One"
 },
 {
    "code": "function sumBinary = addBinary(a, b) /n     m = length(a); /n     n = length(b); /n     maxLen = max(m, n); /n     a = [zeros(1, maxLen - m), a]; /n     b = [zeros(1, maxLen - n), b]; /n     sumBinary = ''; /n     carry = 0; /n     for i = maxLen:-1:1 /n         bitA = str2double(a(i)); /n         bitB = str2double(b(i)); /n         sumBit = bitA + bitB + carry; /n         if sumBit == 0 /n             sumBinary = ['0', sumBinary]; /n             carry = 0; /n         elseif sumBit == 1 /n             sumBinary = ['1', sumBinary]; /n             carry = 0; /n         elseif sumBit == 2 /n             sumBinary = ['0', sumBinary]; /n             carry = 1; /n         else /n             sumBinary = ['1', sumBinary]; /n             carry = 1; /n         end /n     end /n     if carry /n         sumBinary = ['1', sumBinary]; /n     end /n end /n ",
    "comment": "Add Binary"
 },
 {
    "code": "function sqrtValue = mySqrt(x) /n     sqrtValue = sqrt(x); /n end /n ",
    "comment": "calculate the square root of a number"
 },
 {
    "code": "function numWays = climbStairs(n) /n     if n <= 0 /n         error('Number of stairs must be a positive integer.'); /n     end /n  /n     if n == 1 /n         numWays = 1; /n     elseif n == 2 /n         numWays = 2; /n     else /n         ways = zeros(1, n); /n         ways(1) = 1; /n         ways(2) = 2; /n  /n         for i = 3:n /n             ways(i) = ways(i - 1) + ways(i - 2); /n         end /n  /n         numWays = ways(n); /n     end /n end /n ",
    "comment": "Climbing Stairs problem"
 },
 {
    "code": "function grayCode = generateGrayCode(n) /n     if n == 1 /n         grayCode = ['0', '1']; /n     else /n         prevGrayCode = generateGrayCode(n - 1); /n         grayCode = ['0', prevGrayCode; '1', flip(prevGrayCode, 2)]; /n         grayCode = reshape(grayCode', 1, []); /n     end /n end /n ",
    "comment": "generates a Gray code sequence of a given length"
 },
 {
    "code": "function numBSTs = numUniqueBSTs(n) /n     if n < 0 /n         error('n must be a non-negative integer.'); /n     end /n     numBSTsArray = zeros(1, n+1); /n     numBSTsArray(1) = 1; /n     for i = 2:n+1 /n         for j = 1:i-1 /n             numBSTsArray(i) = numBSTsArray(i) + numBSTsArray(j) * numBSTsArray(i-j-1); /n         end /n     end /n     numBSTs = numBSTsArray(n+1); /n end /n ",
    "comment": "Unique Binary Search Trees"
 },
 {
    "code": "function maxPoints = maxPointsOnLine(points) /n     if size(points, 1) < 2 /n         maxPoints = size(points, 1); /n         return; /n     end /n  /n     maxPoints = 0; /n     for i = 1:size(points, 1) /n         slopes = containers.Map; /n         vertical = 0; /n         duplicate = 0; /n         currMax = 0; /n  /n         for j = 1:size(points, 1) /n             if i ~= j /n                 x1 = points(i, 1); /n                 y1 = points(i, 2); /n                 x2 = points(j, 1); /n                 y2 = points(j, 2); /n  /n                 if x1 == x2 /n                     if y1 == y2 /n                         duplicate = duplicate + 1; /n                     else /n                         vertical = vertical + 1; /n                     end /n                 else /n                     slope = (y2 - y1) / (x2 - x1); /n                     if isKey(slopes, slope) /n                         slopes(slope) = slopes(slope) + 1; /n                     else /n                         slopes(slope) = 1; /n                     end /n ",
    "comment": "maximum number of points on a line"
 },
 {
    "code": "function result = evaluateRPN(tokens) /n     stack = []; /n     operators = {'+', '-', '*', '/'}; /n  /n     for i = 1:numel(tokens) /n         token = tokens{i}; /n         if ismember(token, operators) /n             operand2 = stack(end); /n             stack(end) = []; /n             operand1 = stack(end); /n             stack(end) = []; /n             switch token /n                 case '+' /n                     stack(end + 1) = operand1 + operand2; /n                 case '-' /n                     stack(end + 1) = operand1 - operand2; /n                 case '*' /n                     stack(end + 1) = operand1 * operand2; /n                 case '/' /n                     stack(end + 1) = operand1 / operand2; /n             end /n         else /n             stack(end + 1) = str2double(token); /n         end /n     end /n     result = stack; /n end /n ",
    "comment": "Evaluate Reverse Polish Notation"
 },
 {
    "code": "function recurringDecimal = fractionToRecurringDecimal(numerator, denominator) /n    if denominator == 0 /n         error('Division by zero is not allowed.'); /n     end /n if numerator == 0 /n         recurringDecimal = '0'; /n         return; /n     end /n     sign = ''; /n     if (numerator < 0 && denominator > 0) || (numerator > 0 && denominator < 0) /n         sign = '-'; /n     end /n     numerator = abs(numerator); /n     denominator = abs(denominator); /n     integerPart = fix(numerator / denominator); /n     remainder = mod(numerator, denominator); /n     recurringDecimal = [sign, num2str(integerPart)]; /n  /n     if remainder == 0 /n         return; /n     end /n     recurringDecimal = [recurringDecimal, '.']; /n     remainderMap = containers.Map('KeyType', 'double', 'ValueType', 'int32'); /n     index = length(recurringDecimal) + 1; /n     while remainder > 0 && ~isKey(remainderMap, remainder) /n         remainderMap(remainder) = index; /n         quotient = fix(remainder * 10 / denominator); /n         recurringDecimal = [recurringDecimal, num2str(quotient)]; /n         remainder = mod(remainder * 10, denominator); /n         index = index + 1; /n     end /n  /n     if remainder > 0 /n         insertIndex = remainderMap(remainder); /n         recurringDecimal = [recurringDecimal(1:insertIndex-1), '(', recurringDecimal(insertIndex:end), ')']; /n     end /n end /n ",
    "comment": "convert a fraction to Recurring Decimal"
 },
 {
    "code": "function rotatedArray = rotateArray(arr, k) /n     if k < 0 /n         error('Number of positions to rotate (k) must be non-negative.'); /n     end /n  /n     n = length(arr); /n     k = mod(k, n); /n  /n     if k == 0 /n         rotatedArray = arr; /n     else /n         rotatedArray = [arr(n-k+1:end), arr(1:n-k)]; /n     end /n end /n ",
    "comment": "Rotate Array"
 },
 {
    "code": "function count = countPrimes(n) /n     if n <= 2 /n         count = 0; /n         return; /n     end /n     isPrime = true(1, n); /n     isPrime(1) = false; /n     for num = 2:sqrt(n) /n         if isPrime(num) /n             isPrime(num*num:num:n) = false; /n         end /n     end /n     count = sum(isPrime) - 1; /n end /n ",
    "comment": "count the number of prime numbers less than a given number"
 },
 {
    "code": "function area = rectangleArea(A, B, C, D, E, F, G, H) /n     if E >= C || A >= G || F >= D || B >= H /n         area = (C - A) * (D - B) + (G - E) * (H - F); /n     elseoverlapWidth = min(C, G) - max(A, E); /n         overlapHeight = min(D, H) - max(B, F); /n         overlapArea = overlapWidth * overlapHeight; /n area = (C - A) * (D - B) + (G - E) * (H - F) - overlapArea; /n     end /n end /n ",
    "comment": "calculate the area of the rectangle formed by two overlapping rectangles"
 },
 {
    "code": "function result = basicCalculator(operator, operand1, operand2) /n     switch operator /n         case '+' /n             result = operand1 + operand2; /n         case '-' /n             result = operand1 - operand2; /n         case '*' /n             result = operand1 * operand2; /n         case '/' /n             if operand2 == 0 /n                 error('Cannot divide by zero.'); /n             else /n                 result = operand1 / operand2; /n             end /n         otherwise /n             error('Unsupported operator. Please use +, -, *, or /.'); /n     end /n end /n ",
    "comment": "Basic Calculator"
 },
 {
    "code": "function isPowerOfTwo = isPowerOfTwo(num) /n     if num <= 0 /n         isPowerOfTwo = false; /n         return; /n     end /n     binaryNum = dec2bin(num); /n     isPowerOfTwo = sum(binaryNum == '1') == 1; /n end /n ",
    "comment": "check if a given number is a power of two"
 },
 {
    "code": "function count = countDigitOne(n) /n     count = 0; /n     for i = 1:floor(log10(n)) /n         base = 10^i; /n         count = count + floor(n / (base * 10)) * base; /n         remainder = mod(n, base); /n         count = count + min(max(remainder - base + 1, 0), base); /n     end /n     count = count + (n >= 1); /n end /n ",
    "comment": "calculate the number of occurrences of the digit \"1\" in all numbers from 1 to a given number 'n' "
 },
 {
    "code": "function root = addDigits(num) /n     if num == 0 /n         root = 0; /n     else /n         root = 1 + mod(num - 1, 9); /n     end /n end /n ",
    "comment": "Add Digits problem"
 },
 {
    "code": "function missingNum = findMissingNumber(nums) /n     n = length(nums); /n     totalSum = n * (n + 1) / 2; /n     arraySum = sum(nums); /n     missingNum = totalSum - arraySum; /n end /n ",
    "comment": "find the missing number in an array containing unique integers from 0 to n"
 },
 {
    "code": "function word = integerToEnglishWords(num) /n     if num == 0 /n         word = 'Zero'; /n         return; /n     end /n    belowTwenty = {'', 'One', 'Two', 'Three', 'Four', 'Five', 'Six', 'Seven', 'Eight', 'Nine', 'Ten', 'Eleven', 'Twelve', 'Thirteen', 'Fourteen', 'Fifteen', 'Sixteen', 'Seventeen', 'Eighteen', 'Nineteen'}; /n     tens = {'', '', 'Twenty', 'Thirty', 'Forty', 'Fifty', 'Sixty', 'Seventy', 'Eighty', 'Ninety'}; /n     thousands = {'', 'Thousand', 'Million', 'Billion'}; /n     function word = convertThreeDigits(num) /n         word = ''; /n         hundreds = floor(num / 100); /n         num = mod(num, 100); /n          /n         if hundreds > 0 /n             word = [word, belowTwenty{hundreds + 1}, ' Hundred']; /n         end /n         if num == 0 /n             return; /n         end  /n         if ~isempty(word) /n             word = [word, ' ']; /n         end /n         if num < 20 /n             word = [word, belowTwenty{num + 1}]; /n         else /n             tensDigit = floor(num / 10); /n             num = mod(num, 10); /n             word = [word, tens{tensDigit + 1}];      /n             if num > 0 /n                 word = [word, ' ', belowTwenty{num + 1}]; /n             end /n         end /n     end /n     word = ''; /n     chunkIdx = 0; /n     while num > 0 /n         chunk = mod(num, 1000); /n         num = floor(num / 1000);      /n         if chunk > 0 /n             if chunkIdx > 0 /n                 word = [convertThreeDigits(chunk), ' ', thousands{chunkIdx + 1}, ' ', word]; /n             else /n                 word = [convertThreeDigits(chunk), word]; /n             end /n         end      /n         chunkIdx = chunkIdx + 1; /n     end /n end /n ",
    "comment": "Converting an integer to its English word"
 },
 {
    "code": "function squares = findPerfectSquares(n) /n     squares = []; /n     for num = 1:sqrt(n) /n         if num^2 <= n /n             squares = [squares, num^2]; /n         end /n     end /n end /n ",
    "comment": "Perfect Squares"
 },
 {
    "code": "function results = addOperators(num, target) /n     results = []; /n     expression = ''; /n     dfs(1, 0, 0); /n     function dfs(start, prevSum, prevAddend) /n         if start > numel(num) /n             if prevSum == target /n                 results{end+1} = expression; /n             end /n             return; /n         end /n         for i = start:numel(num) /n             if i > start && num(start) == '0' /n                 break; /n             end /n             currentStr = num(start:i); /n             currentNum = str2double(currentStr); /n             if start == 1 /n                 expression = currentStr; /n                 dfs(i + 1, currentNum, currentNum); /n                 expression = ''; /n             else /n                 expression = [expression, '+', currentStr]; /n                 dfs(i + 1, prevSum + currentNum, currentNum); /n                 expression(end) = '-'; /n                 dfs(i + 1, prevSum - currentNum, -currentNum); /n                 expression(end) = '*'; /n                 dfs(i + 1, prevSum - prevAddend + prevAddend * currentNum, prevAddend * currentNum); /n                 expression = expression(1:end-2); /n             end /n         end /n     end /n end /n ",
    "comment": "Expression Add Operators Problem"
 },
 {
    "code": "result = isPowerOfThree(n); /n disp(result); /n ",
    "comment": "check if a given number is a power of three or not?"
 },
 {
    "code": "function isPowerOfFour = isPowerOfFour(num) /n     epsilon = 1e-10; /n     isPowerOfFour = abs(log(num) / log(4) - round(log(num) / log(4))) < epsilon; /n end /n ",
    "comment": "To check if a given number is a power of four or not?"
 },
 {
    "code": "function count = countNumbersWithUniqueDigits(n) /n     if n == 0 /n         count = 1; /n     else /n         count = 10; /n         uniqueDigits = 9; /n         for i = 2:min(n, 10) /n             uniqueDigits = uniqueDigits * (11 - i); /n             count = count + uniqueDigits; /n         end /n     end /n end /n ",
    "comment": "Count Numbers with Unique Digits"
 },
 {
    "code": "function isPerfectSquare = isValidPerfectSquare(num) /n     sqrtNum = sqrt(num); /n     isPerfectSquare = sqrtNum == floor(sqrtNum); /n end /n ",
    "comment": "check if a given number is a valid perfect square or not?"
 },
 {
    "code": "function largestDivisibleSubset = largestDivisibleSubset(nums) /n     n = length(nums); /n     if n == 0 /n         largestDivisibleSubset = []; /n         return; /n     end     /n     nums = sort(nums); /n     dp = ones(1, n); % Initialize the dynamic programming array with all ones /n     for i = 2:n /n         for j = 1:i-1 /n             if mod(nums(i), nums(j)) == 0 /n                 dp(i) = max(dp(i), dp(j) + 1); /n             end /n         end /n     end /n     maxSubsetLength = max(dp); /n     lastElement = nums(dp == maxSubsetLength); /n     largestDivisibleSubset = lastElement; /n     for i = maxSubsetLength-1:-1:1 /n         idx = find(dp == i & lastElement(end) > nums, 1); /n         if ~isempty(idx) /n             lastElement = nums(idx); /n             largestDivisibleSubset = [lastElement, largestDivisibleSubset]; /n         end /n     end /n end /n ",
    "comment": "find Largest Divisible Subset of array"
 },
 {
    "code": "function sum = getSum(a, b) /n     while b ~= 0 /n         carry = bitand(a, b) << 1; /n         a = bitxor(a, b); /n         b = carry; /n     end /n     sum = a; /n end /n ",
    "comment": "Sum of Two Integers using XOR"
 },
 {
    "code": "function result = superPow(a, b, m) /n     if isempty(b) /n         result = 1; /n         return; /n     end /n     lastDigit = b(end); /n     b = b(1:end-1);  /n     result = mod(modularPow(a, lastDigit, m) * modularPow(superPow(a, b, m), 10, m), m); /n end /n function result = modularPow(a, b, m) /n     a = mod(a, m); /n     result = 1; /n     while b > 0 /n         if mod(b, 2) == 1 /n             result = mod(result * a, m); /n         end /n         a = mod(a * a, m); /n         b = floor(b / 2); /n     end /n end /n ",
    "comment": "Super Pow problem"
 },
 {
    "code": "function shuffledArray = shuffleArray(arr) /n     n = length(arr); /n     indices = randperm(n); /n     shuffledArray = arr(indices); /n end /n ",
    "comment": "Shuffle an Array randomly"
 },
 {
    "code": "function maxRotateFunction = rotateFunction(nums) /n     n = length(nums); /n     totalSum = sum(nums); /n     maxRotateSum = sum((0:n-1) .* nums); /n     for i = 1:n /n         maxRotateSum = maxRotateSum + (totalSum - n * nums(n - i + 1)); /n         maxRotateFunction = max(maxRotateFunction, maxRotateSum); /n     end /n end /n ",
    "comment": "Rotate Function problem"
 },
 {
    "code": "function digit = findNthDigit(n) /n     base = 9; /n     digitsCount = 1; /n     rangeStart = 1; /n     numbersInCurrentRange = 9; /n     while n > numbersInCurrentRange * digitsCount /n         n = n - numbersInCurrentRange * digitsCount; /n         digitsCount = digitsCount + 1; /n         base = base * 10; /n         rangeStart = rangeStart + numbersInCurrentRange; /n         numbersInCurrentRange = base * digitsCount; /n     end /n     number = rangeStart + ceil(n / digitsCount) - 1; /n     digitPosition = mod(n - 1, digitsCount) + 1; /n     digit = floor(number / 10^(digitsCount - digitPosition)) - floor(number / 10^(digitsCount - digitPosition + 1)) * 10; /n end /n ",
    "comment": "Nth Digit of the sequence"
 },
 {
    "code": "function hexStr = decimalToHexadecimal(num) /n     hexStr = dec2hex(num); /n end /n ",
    "comment": "Convert a Number to Hexadecimal"
 },
 {
    "code": "function rows = arrangeCoins(n) /n     rows = floor((-1 + sqrt(1 + 8 * n)) / 2); /n end /n ",
    "comment": "Arranging Coins problem"
 },
 {
    "code": "function totalDistance = totalHammingDistance(nums) /n     n = length(nums); /n     totalDistance = 0; /n     for bitPosition = 0:31 /n         countOnes = sum(bitget(nums, bitPosition)); /n         totalDistance = totalDistance + countOnes * (n - countOnes); /n     end /n end /n ",
    "comment": "Total Hamming Distance between all pairs of elements in an array"
 },
 {
    "code": "function largestPalindrome = largestPalindromeProduct(n) /n     if n == 1 /n         largestPalindrome = 9; /n         return; /n     end /n     maxNum = 10^n - 1; /n     minNum = 10^(n - 1); /n     largestPalindrome = 0; /n     for i = maxNum:-1:minNum /n         candidate = str2double([num2str(i), fliplr(num2str(i))]); /n         for j = maxNum:-1:minNum /n             if candidate / j > maxNum /n                 break; /n             end /n             if mod(candidate, j) == 0 /n                 largestPalindrome = max(largestPalindrome, candidate); /n                 break; /n             end /n         end /n     end /n end /n ",
    "comment": "Largest Palindrome Product of two n-digit numbers "
 },
 {
    "code": "function rectangle = constructRectangle(area, difference)/n    side1 = 0;/n    side2 = 0;/n    factors = factor(area);/n    numFactors = length(factors);/n    for i = 1:numFactors/n        if abs(factors(i) - area / factors(i)) == difference/n            side1 = max(factors(i), area / factors(i));/n            side2 = min(factors(i), area / factors(i));/n            break;/n        end/n    end/n    rectangle = [side1, side2];/nend/n",
    "comment": "Construct the Rectangle with the given area and the difference between the length and width"
 },
 {
    "code": "function base7Str = decimalToBase7(num) /n    base7Str = dec2base(num, 7); /nend /n",
    "comment": "decimal to Base 7 conversion"
 },
 {
    "code": "function base7Str = decimalToBase7(num) /n    base7Str = dec2base(num, 7); /nend /n",
    "comment": "Base 10 to Base 7 conversion"
 },
 {
    "code": "function isPerfect = isPerfectNumber(num) /n    if num <= 0 /n        isPerfect = false; /n        return; /n    end /n    divisorSum = 0; /n    for divisor = 1 : num/2 /n        if mod(num, divisor) == 0 /n            divisorSum = divisorSum + divisor; /n        end /n    end /n    isPerfect = divisorSum == num; /nend /n",
    "comment": "Check Perfect Number or not"
 },
 {
    "code": "function fib = fibonacciRecursive(n) /n    if n <= 0 /n        fib = 0; /n    elseif n == 1 /n        fib = 1; /n    else /n        fib = fibonacciRecursive(n-1) + fibonacciRecursive(n-2); /n    end /nend /n",
    "comment": "find the nth Fibonacci number"
 },
 {
    "code": "function result = checkSubarraySum(nums, k) /n    n = length(nums); /n    if n < 2 /n        result = false; /n        return; /n    end     /n    prefixSum = 0; /n    prefixSumMap = containers.Map('KeyType', 'double', 'ValueType', 'any'); /n    prefixSumMap(0) = 0; /n    for i = 1:n /n        prefixSum = mod(prefixSum + nums(i), k); /n        if isKey(prefixSumMap, prefixSum) /n            if i - prefixSumMap(prefixSum) > 1 /n                result = true; /n                return; /n            end /n        else /n            prefixSumMap(prefixSum) = i; /n        end /n    end /n    result = false; /nend /n",
    "comment": "Continuous Subarray Sum"
 },
 {
    "code": "function result = complexNumberMultiplication(complexNum1, complexNum2) /n    result = complexNum1 * complexNum2; /nend /n",
    "comment": "Complex Number Multiplication"
 },
 {
    "code": "function result = fractionAddition(frac1, frac2) /n    commonDenominator = lcm(frac1(2), frac2(2)); /n    num1 = frac1(1) * (commonDenominator / frac1(2)); /n    num2 = frac2(1) * (commonDenominator / frac2(2)); /n    resultNumerator = num1 + num2; /n    resultDenominator = commonDenominator; /n    gcdValue = gcd(resultNumerator, resultDenominator); /n    result = [resultNumerator / gcdValue, resultDenominator / gcdValue]; /nend",
    "comment": "Fraction Addition"
 },
  {
    "code": "function result = fractionSubtraction(frac1, frac2) /n    commonDenominator = lcm(frac1(2), frac2(2)); /n    num1 = frac1(1) * (commonDenominator / frac1(2)); /n    num2 = frac2(1) * (commonDenominator / frac2(2)); /n    resultNumerator = num1 - num2; /n    resultDenominator = commonDenominator; /n    gcdValue = gcd(resultNumerator, resultDenominator); /n    result = [resultNumerator / gcdValue, resultDenominator / gcdValue]; /nend",
    "comment": "Fraction Subtraction"
 },
 {
    "code": "function isValid = validSquare(p1, p2, p3, p4) /n    function distSq = distanceSq(a, b) /n        distSq = (b(1) - a(1))^2 + (b(2) - a(2))^2; /n    end /n    points = [p1; p2; p3; p4]; /n    distances = zeros(6, 1); /n    idx = 1; /n    for i = 1:4 /n        for j = i+1:4 /n            distances(idx) = distanceSq(points(i, :), points(j, :)); /n            idx = idx + 1; /n        end /n    end /n     distances = sort(distances); /n    isValid = distances(1) > 0 && distances(1) == distances(2) && ... /n              distances(1) == distances(3) && distances(1) == distances(4) && ... /n              distances(5) > 0 && distances(5) == distances(6); /nend /n",
    "comment": "Valid Square"
 },
 {
    "code": "function result = sumOfSquareNumbers(num) /n    left = 0; /n    right = floor(sqrt(num)); /n    while left <= right /n        sumSquares = left^2 + right^2; /n        if sumSquares == num /n            result = true; /n            return; /n        elseif sumSquares < num /n            left = left + 1; /n        else /n            right = right - 1; /n        end /n    end  /n    result = false; /nend /n",
    "comment": "Sum of Square Numbers or not"
 },
 {
    "code": "function solution = solveLinearEquation(a, b) /n    if a == 0 /n        error('The coefficient \"a\" cannot be zero for a linear equation.'); /n    end /n    solution = -b / a; /nend /n",
    "comment": "Solve linear Equation"
 },
 {
    "code": "function solutions = solveQuadraticEquation(a, b, c) /n    if a == 0 /n        error('The coefficient \"a\" cannot be zero for a quadratic equation.'); /n    end /n    discriminant = b^2 - 4*a*c; /n    if discriminant > 0 /n        solutions = [(-b + sqrt(discriminant)) / (2*a), (-b - sqrt(discriminant)) / (2*a)]; /n    elseif discriminant == 0 /n        solutions = -b / (2*a); /n    else /n        solutions = []; % No real solutions (complex roots) /n    end /nend /n",
    "comment": "Solve quadratic Equation"
 },
 {
    "code": "function selfDividingNumbers = findSelfDividingNumbers(left, right) /n    selfDividingNumbers = []; /n    for num = left:right /n        if isSelfDividingNumber(num) /n            selfDividingNumbers = [selfDividingNumbers, num]; /n        end /n    end /nend /nfunction isSelfDividing = isSelfDividingNumber(num) /n    numStr = num2str(num); /n    for i = 1:length(numStr) /n        digit = str2double(numStr(i)); /n        if digit == 0 || mod(num, digit) ~= 0 /n            isSelfDividing = false; /n            return; /n        end /n    end /n    isSelfDividing = true; /nend /n",
    "comment": "Self Dividing Numbers"
 },
 {
    "code": "function result = splitArraySameAverage(nums) /n    n = length(nums); /n    sumNums = sum(nums); /n    if n <= 1 /n        result = false; /n        return; /n    end /n    dp = false(n, sumNums + 1); /n    dp(1, nums(1)) = true;  /n    for i = 2:n /n        dp(i, nums(i)) = true; /n        for j = 1:sumNums /n            if dp(i-1, j) /n                dp(i, j) = true; /n                dp(i, j + nums(i)) = true; /n            end /n        end /n    end /n     halfSum = sumNums / 2; /n    for i = 1:n /n        if dp(i, halfSum) /n            result = true; /n            return; /n        end /n    end   /n    result = false; /nend /n",
    "comment": "Split Array With Same Average"
 },
 {
    "code": "function largestArea = largestTriangleArea(points) /n    n = size(points, 1); /n    largestArea = 0; /n    function area = calcTriangleArea(p1, p2, p3) /n        area = 0.5 * abs(p1(1)*(p2(2)-p3(2)) + p2(1)*(p3(2)-p1(2)) + p3(1)*(p1(2)-p2(2))); /n    end    /n    for i = 1:n /n        for j = i+1:n /n            for k = j+1:n /n                area = calcTriangleArea(points(i,:), points(j,:), points(k,:)); /n                largestArea = max(largestArea, area); /n            end /n        end /n    end /nend /n",
    "comment": "Largest Triangle Area"
 },
 {
    "code": "function numWays = consecutiveNumbersSum(N) /n    function numOddDivisors = countOddDivisors(num) /n        count = 0; /n        for i = 1:num /n            if mod(num, i) == 0 && mod(i, 2) ~= 0 /n                count = count + 1; /n            end /n        end /n        numOddDivisors = count; /n    end /n    numWays = countOddDivisors(N); /nend /n",
    "comment": "Consecutive Numbers Sum problem"
 },
 {
    "code": "function largestPrimePalindrome = findLargestPrimePalindrome(limit) /n    largestPrimePalindrome = 0; /n    for num = limit:-1:2 /n        if isPalindromeNumber(num) && isPrimeNumber(num) /n            largestPrimePalindrome = num; /n            return; /n        end /n    end /nend /n",
    "comment": "Prime Palindrome"
 },
 {
    "code": "function result = reorderedPowerOf2(N) /n    % Function to check if a number is a power of 2 /n    function isPowerOf2 = isPowerOfTwo(num) /n        isPowerOf2 = bitand(num, num-1) == 0; /n    end /n /n    % Function to generate all permutations of a string /n    function permsArray = generatePermutations(str) /n        n = numel(str); /n        permsArray = cell(1, factorial(n)); /n        idx = 1; /n /n        function permuteString(s, k) /n            if k == n /n                permsArray{idx} = s; /n                idx = idx + 1; /n            else /n                for i = k:n /n                    s([k,i]) = s([i,k]); /n                    permuteString(s, k+1); /n                    s([k,i]) = s([i,k]); % backtrack /n                end /n            end /n        end /n /n        permuteString(str, 1); /n    end /n /n    numStr = num2str(N); /n    numPermutations = generatePermutations(numStr); /n /n    for i = 1:numel(numPermutations) /n        numPerm = str2double(numPermutations{i}); /n        if numPerm > 0 && isPowerOfTwo(numPerm) /n            result = true; /n            return; /n        end /n    end /n /n    result = false; /nend /n",
    "comment": "Reordered Power of 2"
 },
 {
    "code": "function result = threeEqualParts(A) /n    totalSum = sum(A); /n    if mod(totalSum, 3) ~= 0 /n        result = [-1, -1]; /n        return; /n    end /n    targetSum = totalSum / 3; /n    n = length(A); /n    partSum = 0; /n    firstSplit = -1; /n    secondSplit = -1; /n    for i = 1:n /n        partSum = partSum + A(i); /n        if partSum == targetSum /n            firstSplit = i; /n        elseif partSum == 2 * targetSum /n            secondSplit = i; /n            break; /n        end /n    end /n    if firstSplit == -1 || secondSplit == -1 /n        result = [-1, -1]; /n        return; /n    end /n    trailingZeros = n - secondSplit; /n    if trailingZeros >= n - firstSplit /n        result = [-1, -1]; /n        return; /n    end /n    result = [firstSplit, secondSplit + trailingZeros + 1]; /nend /n",
    "comment": "divide an array into Three Equal Parts"
 },
 {
    "code": "function minArea = minAreaRect(points) /n    n = size(points, 1); /n    minArea = Inf; /n    function distance = calcDistance(p1, p2) /n        distance = sqrt((p1(1) - p2(1))^2 + (p1(2) - p2(2))^2); /n    end /n    for i = 1:n /n        for j = i+1:n /n            p1 = points(i, :); /n            p2 = points(j, :); /n            dist = calcDistance(p1, p2); /n            angle = atan2(p2(2) - p1(2), p2(1) - p1(1)); /n                if k == i || k == j /n                    continue; /n                end /n                p3 = points(k, :); /n                angleDiff = abs(atan2(p3(2) - p1(2), p3(1) - p1(1)) - angle); /n                if abs(angleDiff - pi/2) < 1e-9 /n                    p4 = [p2(1) + p3(1) - p1(1), p2(2) + p3(2) - p1(2)]; /n                    area = dist * calcDistance(p2, p3); /n                    minArea = min(minArea, area); /n                end /n            end /n        end /n    end /n    if isinf(minArea) /n        minArea = 0; /n    end /nend /n",
    "comment": "find Minimum Area Rectangle"
 },
 {
    "code": "function largestPerimeter = largestPerimeterTriangle(A) /n    function isValid = isTriangle(a, b, c) /n        isValid = a + b > c && a + c > b && b + c > a; /n    end /n    n = length(A); /n    sortedA = sort(A, 'descend'); /n    for i = 1:n-2 /n        if isTriangle(sortedA(i), sortedA(i+1), sortedA(i+2)) /n            largestPerimeter = sortedA(i) + sortedA(i+1) + sortedA(i+2); /n            return; /n        end /n    end /n    largestPerimeter = 0; % If no valid triangle found, return 0. /nend /n",
    "comment": "Largest Perimeter Triangle"
 },
 {
    "code": "function result = baseNeg2(N) /n    if N == 0 /n        result = '0'; /n        return; /n    end /n    base = -2; /n    result = ''; /n    while N ~= 0 /n        remainder = mod(N, base); /n        N = floor(N / base); /n        if remainder < 0 /n            remainder = remainder + abs(base); /n            N = N + 1; /n        end /n        result = [num2str(remainder), result]; /n    end /nend /n",
    "comment": "Convert to Base -2"
 },
 {
    "code": "function result = simplifiedFractions(n) /n    result = {}; /n    function gcdVal = gcd(a, b) /n        if b == 0 /n            gcdVal = a; /n        else /n            gcdVal = gcd(b, mod(a, b)); /n        end /n    end /n    for numerator = 1:n /n        for denominator = 2:n /n            if numerator < denominator && gcd(numerator, denominator) == 1 /n                result = [result; {numerator, denominator}]; /n            end /n        end /n    end /nend /n",
    "comment": "Simplified Fractions"
 },
 {
    "code": "function count = countOddNumbers(start, ending) /n    if start > ending /n        error('Starting number must be less than or equal to the ending number.'); /n    end /n    if mod(start, 2) == 0 /n        start = start + 1; /n    end /n    if mod(ending, 2) == 0 /n        ending = ending - 1; /n    end /n    count = (ending - start) / 2 + 1; /nend /n",
    "comment": "Count Odd Numbers in an Interval Range"
 },
 {
    "code": "function sumDigits = sumDigitsBaseK(N, K) /n    sumDigits = 0; /n    while N > 0 /n        sumDigits = sumDigits + mod(N, K); /n        N = floor(N / K); /n    end /nend /n",
    "comment": "Sum of Digits in Base K"
 },
 {
    "code": "function arrayGCD = findArrayGCD(arr) /n    arrayGCD = arr(1); /n    function gcdVal = gcd(a, b) /n        if b == 0 /n            gcdVal = a; /n        else /n            gcdVal = gcd(b, mod(a, b)); /n        end /n    end /n    for i = 2:length(arr) /n        arrayGCD = gcd(arrayGCD, arr(i)); /n    end /nend /n",
    "comment": "find Greatest Common Divisor of an Array"
 },
 {
    "code": "function arrayGCD = findArrayGCD(arr) /n    arrayGCD = arr(1); /n    function gcdVal = gcd(a, b) /n        if b == 0 /n            gcdVal = a; /n        else /n            gcdVal = gcd(b, mod(a, b)); /n        end /n    end /n    for i = 2:length(arr) /n        arrayGCD = gcd(arrayGCD, arr(i)); /n    end /nend",
    "comment": "GCD of an Array"
 },
 {
    "code": "function palindromes = findFixedLengthPalindromes(length) /n    if length < 1 /n        error('Length must be a positive integer.'); /n    end /n    palindromes = {}; /n    function isPalindrome = isPalindromic(str) /n        isPalindrome = strcmp(str, flip(str)); /n    end /n    chars = 'abcdefghijklmnopqrstuvwxyz'; /n    numChars = length(chars); /n    for i = 1:numChars /n        middleChar = chars(i); /n        for j = 1:numChars /n            firstChar = chars(j); /n            lastChar = chars(numChars - j + 1); /n            if length == 1 /n                palindromes = [palindromes; {middleChar}]; /n            else /n                palindrome = [firstChar, middleChar, lastChar]; /n                if isPalindromic(palindrome) /n                    palindromes = [palindromes; {palindrome}]; /n                end /n            end /n        end /n    end /nend /n",
    "comment": "Find Palindrome With Fixed Length"
 },
 
 {
    "code": "function strictlyPalindromicNumbers = findStrictlyPalindromicNumbers(startNum, endNum) /n    strictlyPalindromicNumbers = []; /n    function isStrictlyPalindromic = isStrictlyPalindromicNumber(num) /n        numStr = num2str(num); /n        numLength = length(numStr); /n        isStrictlyPalindromic = true; /n        for i = 1:numLength-1 /n            if numStr(i) >= numStr(i+1) /n                isStrictlyPalindromic = false; /n                break; /n            end /n        end /n    end /n    for num = startNum:endNum /n        if isStrictlyPalindromicNumber(num) /n            strictlyPalindromicNumbers = [strictlyPalindromicNumbers, num]; /n        end /n    end /nend /n",
    "comment": "find Strictly Palindromic Number"
 },
 {
    "code": "function numCommonFactors = findCommonFactors(a, b) /n    function gcdVal = gcd(a, b) /n        if b == 0 /n            gcdVal = a; /n        else /n            gcdVal = gcd(b, mod(a, b)); /n        end /n    end /n    function numDivisors = countDivisors(number) /n        numDivisors = 0; /n        for i = 1:number /n            if mod(number, i) == 0 /n                numDivisors = numDivisors + 1; /n            end /n        end /n    end /n    gcdAB = gcd(a, b); /n    numCommonFactors = countDivisors(gcdAB); /nend /n",
    "comment": "Number of Common Factors"
 },
 {
    "code": "function reversedNum = reverseNumber(num) /n    reversedNum = 0; /n    while num ~= 0 /n        digit = mod(num, 10); /n        reversedNum = reversedNum * 10 + digit; /n        num = fix(num / 10); /n    end /nend /n",
    "comment": "Reverse of a number"
 },
 {
    "code": "function convertedTemp = convertTemperature(value, fromUnit, toUnit) /n    switch fromUnit /n        case 'Celsius' /n            switch toUnit /n                case 'Fahrenheit' /n                    convertedTemp = (value * 9/5) + 32; /n                case 'Kelvin' /n                    convertedTemp = value + 273.15; /n                otherwise /n                    error('Invalid target unit.'); /n            end /n        case 'Fahrenheit' /n            switch toUnit /n                case 'Celsius' /n                    convertedTemp = (value - 32) * 5/9; /n                case 'Kelvin' /n                    convertedTemp = (value - 32) * 5/9 + 273.15; /n                otherwise /n                    error('Invalid target unit.'); /n            end /n        case 'Kelvin' /n            switch toUnit /n                case 'Celsius' /n                    convertedTemp = value - 273.15; /n                case 'Fahrenheit' /n                    convertedTemp = (value - 273.15) * 9/5 + 32; /n                otherwise /n                    error('Invalid target unit.'); /n            end /n        otherwise /n            error('Invalid source unit.'); /n    end /nend /n",
    "comment": "Convert the Temperature"
 },
 {
    "code": "function count = countIntegersInRange(startNum, endNum, condition) /n    if startNum > endNum /n        error('Starting number must be less than or equal to the ending number.'); /n    end /n    count = 0; /n    for num = startNum:endNum /n        if condition(num) /n            count = count + 1; /n        end /n    end /nend /n",
    "comment": "Count of Integers"
 }
]